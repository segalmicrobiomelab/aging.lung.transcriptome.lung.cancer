# 05/08/23 ; Fares Darawshy ; Segal Lab 
#  Signatures of Early Lung Cancer. RNA sequencing. Analysis by age 

setwd("~/Dropbox (NYU Langone Health)/Fares Darawshyâ€™s files/Home/Projects/Early.Lung.Cancer/Analysis_by_Age")
#load libraries 
library(fgsea)
library(ggpubr)
library(tidyverse)
library(dplyr)
library(ggalt)
library(forcats)
library(car)
library(magrittr)
library(lubridate)
library(DESeq2)
library(edgeR)
library(limma)
library(Glimma)
library(RColorBrewer)
library(pheatmap)
library(ggplot2)
library(gplots)
library(ggrepel)
library(pathfindR)
library(scales)
library(data.table)
library(fBasics)
library(forcats)
library(omu)
library(maptools)
library(phyloseq)
library("vegan")
library(ade4)
library("reshape2")
library(dplyr)	
library(Matrix)
library(scales)
library(cowplot)
library(randomForest)
library(caret)
library("mlbench")
library(RCurl)
library(VennDiagram)
library(ranger)
library(xgboost)
library(rmarkdown)
library(glue)
library(ggtext)
library(ComplexHeatmap)
library(TCGAbiolinks)
library(table1)
library(pROC)
library(survival)
library(survminer)
library(pdftools)
library(grid)
library(gridExtra)
library(cluster)
library(umap)
###### NYU early stage data #########


#Load RNA Seq file 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

#load meadata 
map = "Data/Surgical.Cohort.Map.txt"
mapping.table = sample_data(read.table(map,header = T, sep = "\t", row.names = 1))

#Keep Only MetaData of RNASeq Samples
#Keep only samples with RNA ID that matches the RNA count data 
RNA.data = mapping.table[mapping.table$RNA_Seq_done_Final==1,]
RNA.data <- RNA.data[RNA.data$RNA_ID!= "n.a",]

#Pick up the column that have RNA ID in metadata 
#We want to match ID names in each element 
RNA.data$RNA_ID

#Order Meta Data by SampleId
RNA.data <- RNA.data[order(RNA.data$RNA_ID),]

#Order Count Data by SampleID and replace the X before each name 
colnames(mycounts) <- gsub("X", "", colnames(mycounts))
mycounts <- mycounts [, order(colnames(mycounts))]

#Confirm Sample IDs match for Count and Meta Data
table(colnames(mycounts)==as.character(RNA.data$RNA_ID))
rownames(RNA.data) <- RNA.data$RNA_ID

#confirm columns names of data and rownamnes of metadata are similar 
table(colnames(mycounts)==rownames(RNA.data))



######################Creating age groups ####################

#define age as numeric 
RNA.data$Age <- as.numeric(RNA.data$Age)

# find out the age cutoffs of three groups 
cut(RNA.data$Age, breaks = quantile(RNA.data$Age, probs = c(0, 1/3, 2/3, 1)))

#should get: Levels: (46,66] (66,74] (74,89]


#now build another column in the metadata that fit these three groups 
RNA.data$age_3_grps <- ifelse(RNA.data$Age >74, "old",
                                     ifelse(RNA.data$Age < 66, "young", 
                                            "middle"))

#keep only extremes 
RNA.data.extremes <- data.frame(RNA.data) %>% 
  dplyr::filter(age_3_grps!= "middle")

rownames(RNA.data.extremes)


#now keep only those from mycounts 
mycounts_age_extremes <- mycounts %>% 
  dplyr::select(rownames(RNA.data.extremes))

#check they match 
table(colnames(mycounts_age_extremes)==rownames(RNA.data.extremes))
#TRUE 176 samples (88 subjects)



######### Working on Creating Table 1 from metadata##########

Table.1.data <- RNA.data.extremes
Table.1.data <- Table.1.data %>% 
  dplyr::filter(Sample_Type_Involved=="Lung.Tissue.In")


#add statistical analysis column 
#define p value function 

pvalue <- function(x, ...) {
  # Construct vectors of data y, and groups (strata) g
  y <- unlist(x)
  g <- factor(rep(1:length(x), times=sapply(x, length)))
  if (is.numeric(y)) {
    # For numeric variables, perform a standard 2-sample t-test
    p <- t.test(y ~ g)$p.value
  } else {
    # For categorical variables, perform a chi-squared test of independence
    p <- chisq.test(table(y, g))$p.value
  }
  # Format the p-value, using an HTML entity for the less-than sign.
  # The initial empty string places the output on the line below the variable label.
  c("", sub("<", "&lt;", format.pval(p, digits=3, eps=0.001)))
}

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(Male_1) + factor(RACE) + as.numeric(Age) + factor(Smoking_status) + as.numeric(Pack_Years) 
       + factor(Stage) +factor(Outcome) + factor(Progression_Lab) + factor(ProgType_Lab)+ as.numeric(Size_cm) + factor(five_y_mortality)
       # set the variable you want to stratify by 
       | age_3_grps, 
       #set data 
       data=Table.1.data, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))
#now add stats (same as above except where notes added ) for these two groups only 
table1(~ 
         factor(Male_1) + factor(RACE) + as.numeric(Age) + factor(Smoking_status) + as.numeric(Pack_Years) 
       + factor(Stage) +factor(Outcome) + factor(Progression_Lab) + factor(ProgType_Lab)+ as.numeric(Size_cm) + factor(five_y_mortality)
       | age_3_grps, data=Table.1.data, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))

#stats for recurrence type without the group of no recurrence 
stats.table <- Table.1.data %>% 
  dplyr::filter(ProgType_Lab != "No.Recurrence")

chisq.test(stats.table$ProgType_Lab, stats.table$age_3_grps) #p=0.79

#get p value of numerical variables 
t.test(Table.1.data$Age ~ Table.1.data$age_3_grps)$p.value # p < 0.001
t.test(as.numeric(Table.1.data$Pack_Years) ~ Table.1.data$age_3_grps) #p-value = 0.001002

#copy and paste the above results and edit in excel / word 




####kaplan meier curvve of old vs young - recurrence #### 


#Load relevant packages 
library(dplyr)
library(survival)
library(survminer)

#Use subset of samples with tumor only 

tumor.table.extremes <- RNA.data.extremes %>% 
  dplyr::filter(Sample_Type_Involved=="Lung.Tissue.In")

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- data.frame(sample_data(tumor.table.extremes))

#search for columns to keep 
metadata$New_TTP
metadata$Progression

###plot for recurrence 
#Column to be used as time (in days) - New_TTP 
# column to be used as status is Progression Lab
survival.data <- metadata[, c("New_TTP","Progression", "age_3_grps" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- as.factor(survival.data$Age)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Old", "Young"), legend.title="Age",  
                            palette=c("blue3", "green4"), size=1,
                            title="Kaplan-Meier Curve for Recurrence Following Surgery According to Age",
                            ylab="Percent Without Recurrence",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot 
pdf(file = "Early.Lung.Cancer.Kaplan.Meier.by_age_extremes.pdf", width = 8, height = 8)
survival.plot
dev.off()




#############################Creating DESeq Object ############################

#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(mycounts_age_extremes, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(mycounts_age_extremes))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)

#Convert Model Variable into Factor
RNA.data.extremes$age_3_grps <- as.factor(RNA.data.extremes$age_3_grps)
RNA.data.extremes$Sample_Type_Involved <- as.factor(RNA.data.extremes$Sample_Type_Involved)
RNA.data.extremes$Progression_Lab_Inv <- as.factor(RNA.data.extremes$Progression_Lab_Inv)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = RNA.data.extremes, design = ~ age_3_grps + Progression_Lab_Inv)

#Normalization Step 
dds <- estimateSizeFactors(dds)

#Retrive normalized counts matrix 
normalized_counts <- counts(dds, normalized=TRUE)
#save it 
write.table(normalized_counts, file="Results/normalized_counts.txt", sep="\t", quote=F, col.names=NA)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#Drop Levels
dds$age_3_grps   <- droplevels(dds$age_3_grps)
vsd$age_3_grps   <- droplevels(vsd$age_3_grps)


###############################################################################
################Running Differential Analysis##################

#run old vs young 

###Subset for Tumor

dds_tumor <- dds[,dds$Sample_Type_Involved=="Lung.Tissue.In"]
vsd_tumor <- vsd[,vsd$Sample_Type_Involved=="Lung.Tissue.In"]


#### compare old vs young in tumor####


#define variables 
dds_tumor$age_3_grps
v= "age_3_grps"

#Set Reference Level for Comparison (Control Group)
dds_tumor[[v]] <- factor(dds_tumor[[v]])
dds_tumor[[v]] <- relevel(dds_tumor[[v]], ref = "young")

vsd_tumor[[v]] <- factor(vsd_tumor[[v]])
vsd_tumor[[v]] <- relevel(vsd_tumor[[v]], ref = "young")


######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_tumor)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_tumor), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ age_3_grps,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="age_3_grps",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ age_3_grps, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.Tumor_old_vs_young", paste0(v, paste0(".txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.Tumor.samples.age_3_grps_RNA.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= age_3_grps)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("green4", "blue3")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= age_3_grps), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= age_3_grps)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_Tumor <- assay(dds_tumor)

#get genes table and add 1
x= as(mycounts_Tumor, "matrix")
x= x+1 

#get Lung only table 
RNA_data_tumor <- RNA.data.extremes%>% 
  dplyr::filter(Sample_Type_Involved =="Lung.Tissue.In")

# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_tumor, "age_3_grps")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

dgeFull$samples

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_age_3_grp_tumor.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
  cols[res$logFC > 0 & res$FDR < alpha ] <- "blue3"
    cols[res$logFC < 0 & res$FDR < alpha ] <- "green4"
      
    
    #plot with labels 
    pdf(file = paste0("Figures/RNA/edgeR_Old_vs_Young_RNA_tumor", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
    ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
      geom_point(color = cols)+
      geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                                   ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                      size= 4, 
                      force = 25,
                      segment.colour="grey",
                      segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
      geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
      xlab("Effect size: log2(fold-change)") + #label X Axis
      ylab("-log10(adjusted p-value)")+  #label Y Axis
      theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
            panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
            panel.grid.minor = element_blank(),
            strip.background=element_blank(),
            axis.title=element_text(size=20,face="bold"),
            axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
            axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
            axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
            legend.position="none")
    dev.off()
    
  
######################
###subset for lung 
dds_lung <- dds[,dds$Sample_Type_Involved=="Lung.Tissue.UnIn"]
vsd_lung <- vsd[,vsd$Sample_Type_Involved=="Lung.Tissue.UnIn"]


#define variables 
dds_lung$age_3_grps
v= "age_3_grps"

#Set Reference Level for Comparison (Control Group)
dds_lung[[v]] <- factor(dds_lung[[v]])
dds_lung[[v]] <- relevel(dds_lung[[v]], ref = "young")

vsd_lung[[v]] <- factor(vsd_lung[[v]])
vsd_lung[[v]] <- relevel(vsd_lung[[v]], ref = "young")

######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_lung)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_lung), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ age_3_grps,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="age_3_grps",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ age_3_grps, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.lung_old_vs_young", paste0(v, paste0(".txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.lung.samples.age_3_grps_RNA.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= age_3_grps)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("green4", "blue3")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= age_3_grps), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= age_3_grps)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_lung <- assay(dds_lung)

#get genes table and add 1
x= as(mycounts_lung, "matrix")
x= x+1 

#get Lung only table 
RNA_data_lung <- RNA.data.extremes%>% 
  dplyr::filter(Sample_Type_Involved =="Lung.Tissue.UnIn")

# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_lung, "age_3_grps")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

dgeFull$samples

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_age_3_grp_lung.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
  cols[res$logFC > 0 & res$FDR < alpha ] <- "blue3"
    cols[res$logFC < 0 & res$FDR < alpha ] <- "green4"
      
    
    #plot with labels 
    pdf(file = paste0("Figures/RNA/edgeR_Old_vs_Young_RNA_lung", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
    ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
      geom_point(color = cols)+
      geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                                   ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                      size= 4, 
                      force = 25,
                      segment.colour="grey",
                      segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
      geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
      xlab("Effect size: log2(fold-change)") + #label X Axis
      ylab("-log10(adjusted p-value)")+  #label Y Axis
      theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
            panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
            panel.grid.minor = element_blank(),
            strip.background=element_blank(),
            axis.title=element_text(size=20,face="bold"),
            axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
            axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
            axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
            legend.position="none")
    dev.off()
    
################################################################################
##########Analysis according to recurrence ####################
    
########### Tumor subset first 
    
    ###Subset for Tumor old 
    
    dds_tumor_old  <- dds_tumor[,dds_tumor$age_3_grps =="old"]
    vsd_tumor_old  <- vsd_tumor[,dds_tumor$age_3_grps =="old"]
    
    #define variable 

    v= "Progression_Lab_Inv"
    
    dds_tumor_old[[v]] <- factor(dds_tumor_old[[v]])
    vsd_tumor_old[[v]] <- factor(vsd_tumor_old[[v]])
    
    ######################Plot PCoA
    
#Create Distance Matrix
    vegdist = vegdist(t(assay(vsd_tumor_old)), method = "bray")
    
    #Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
    CmdScale <- cmdscale(vegdist, k =10)
    #calculated Sample variance for each PC
    vars <- apply(CmdScale, 2, var)
    #Create Variable with the Percent Variance
    percentVar <- round(100 * (vars/sum(vars)))
    
    #Merge PC Data with MetaData
    newResults <- merge(x = CmdScale, y = colData(vsd_tumor_old), by = "row.names", all.x = TRUE)
    #Rename Variables for PC1 and PC2
    colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
    colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
    colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"
    
    #Calculate the Centroid Value
    centroids <- aggregate(cbind(PC1,PC2)~ Progression_Lab_Inv,data= newResults, mean)
    #Merge the Centroid Data into the PCOA Data
    newResults <- merge(newResults,centroids,by="Progression_Lab_Inv",suffixes=c("",".centroid"))

    #stats 
    x <- adonis2(vegdist ~ Progression_Lab_Inv, data = newResults)
    write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.Tumor_old_rec_vs_no_rec", paste0(v, paste0(".txt")))
                , sep = "\t", row.names = T)
    
    
    pdf(file = "Figures/RNA/Beta.Diversity.Bray.Tumor_old_rec_vs_no_rec_RNA.pdf", 
        height = 20, width = 18)
    ggplot(newResults, aes(PC1, PC2, color= Progression_Lab_Inv)) + # Graph PC1 and PC2
      geom_point(size=5) + # Set the size of the points
      xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
      ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
      #Set colors for each category, should be the same number of categories
      scale_color_manual(values=c("orange", "red")) + 
      #plot point and lines from centroid
      geom_point(data=centroids, aes(x=PC1, y=PC2, color= Progression_Lab_Inv), size=0) +
      geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= Progression_Lab_Inv)) + 
      #labels centroids should be same number of categories
      geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
      labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
      theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
    dev.off()
    
    ##############Differential Analysis###################
    
    #first select Lung samples only from metadata and counts table 
    mycounts_Tumor <-assay(dds_tumor_old)
    
    
    #get TUmor and old only table 
    RNA_data_tumor_old <- RNA.data.extremes%>% 
      dplyr::filter(Sample_Type_Involved =="Lung.Tissue.In") %>% 
      dplyr::filter(age_3_grps=="old")
    
    
    #get genes table and add 1
    x= as(mycounts_Tumor, "matrix")
    x= x+1 
    
    # get your group variable (the condition you want to analyze according to it)
    group = get_variable(RNA_data_tumor_old, "Progression_Lab_Inv")
    
    #create edgeR list 
    dgeFull <- DGEList(counts = x, 
                       group = group, 
                       remove.zeros = TRUE)
    
    # calculatee normalization method
    dgeFull <- calcNormFactors(dgeFull, method = "TMM")
    # Estimate dispersions
    dgeFull <- estimateCommonDisp(dgeFull)
    
    dgeFull <- estimateTagwiseDisp(dgeFull)
    
    dgeTest <- exactTest(dgeFull)
    
    dgeFull$samples
    
    #create table
    resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")
    
    ############continue edgeR here#############
    
    res <- resNoFilt$table
    #Reverse Directionality if you need to  
    #res$logFC <- res$logFC*(-1)
    
    #clean the results df 
    
    #Remove Any Data without LOGFC data
    res <- res[!is.na(res$logFC),]
    
    #Convert Important columns to Numeric
    res$FDR <-   as.numeric(as.character(res$FDR))
    res$logFC <-       as.numeric(as.character(res$logFC))
    
    # drop any NA values 
    res<- res %>% 
      drop_na(., FDR) %>% 
      dplyr::arrange(desc(FDR))
    
    #create gene symbol column 
    res<- res %>% 
      dplyr::mutate(Gene.symbol = rownames(.))
    
    # save results (can be used in IPA also)
    write.csv(res, file = "Results/RNA/edgeR.results_old_tumor_rec_vs_no_rec.csv")
    
    ###### volcano plot####
    # create color variable 
    res$sig <- -log10(res$FDR)
    
    # Create variable for color gradient of the dots in the Volcano Plot
    alpha = 0.2
    cols <- densCols(res$logFC, res$sig)
    cols[res$PValue ==0] <- "purple"
      cols[res$logFC > 0 & res$FDR < alpha ] <- "red"
        cols[res$logFC < 0 & res$FDR < alpha ] <- "orange"
          
        
        #plot with labels 
        pdf(file = paste0("Figures/RNA/edgeR_RNA_tumor_old_rec_vs_no_Rec", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
        ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
          geom_point(color = cols)+
          geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                                       ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                          size= 4, 
                          force = 25,
                          segment.colour="grey",
                          segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
          geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
          xlab("Effect size: log2(fold-change)") + #label X Axis
          ylab("-log10(adjusted p-value)")+  #label Y Axis
          theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
                panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
                panel.grid.minor = element_blank(),
                strip.background=element_blank(),
                axis.title=element_text(size=20,face="bold"),
                axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
                axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
                axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
                legend.position="none")
        dev.off()
        
###################################################################################
        
###########Repeat for YOung 
        
        
###Subset for Tumor young 
        
dds_tumor_young  <- dds_tumor[,dds_tumor$age_3_grps =="young"]
vsd_tumor_young  <- vsd_tumor[,dds_tumor$age_3_grps =="young"]

#define variable 

v= "Progression_Lab_Inv"

dds_tumor_young[[v]] <- factor(dds_tumor_young[[v]])
vsd_tumor_young[[v]] <- factor(vsd_tumor_young[[v]])

        
######################Plot PCoA
  
#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_tumor_young)), method = "bray")
        
        #Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
        CmdScale <- cmdscale(vegdist, k =10)
        #calculated Sample variance for each PC
        vars <- apply(CmdScale, 2, var)
        #Create Variable with the Percent Variance
        percentVar <- round(100 * (vars/sum(vars)))
        
        #Merge PC Data with MetaData
        newResults <- merge(x = CmdScale, y = colData(vsd_tumor_young), by = "row.names", all.x = TRUE)
        #Rename Variables for PC1 and PC2
        colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
        colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
        colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"
        
        #Calculate the Centroid Value
        centroids <- aggregate(cbind(PC1,PC2)~ Progression_Lab_Inv,data= newResults, mean)
        #Merge the Centroid Data into the PCOA Data
        newResults <- merge(newResults,centroids,by="Progression_Lab_Inv",suffixes=c("",".centroid"))
        
        #stats 
        x <- adonis2(vegdist ~ Progression_Lab_Inv, data = newResults)
        write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.Tumor_young_rec_vs_no_rec", paste0(v, paste0(".txt")))
                    , sep = "\t", row.names = T)
        
        
        pdf(file = "Figures/RNA/Beta.Diversity.Bray.Tumor_young_rec_vs_no_rec_RNA.pdf", 
            height = 20, width = 18)
        ggplot(newResults, aes(PC1, PC2, color= Progression_Lab_Inv)) + # Graph PC1 and PC2
          geom_point(size=5) + # Set the size of the points
          xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
          ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
          #Set colors for each category, should be the same number of categories
          scale_color_manual(values=c("lightblue", "blue")) + 
          #plot point and lines from centroid
          geom_point(data=centroids, aes(x=PC1, y=PC2, color= Progression_Lab_Inv), size=0) +
          geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= Progression_Lab_Inv)) + 
          #labels centroids should be same number of categories
          geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
          labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
          theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
        dev.off()
        
        ##############Differential Analysis###################
        
        #first select Lung samples only from metadata and counts table 
        mycounts_Tumor <- assay(dds_tumor_young)
        
        
        #get TUmor and young only table 
        RNA_data_tumor_young <- RNA.data.extremes%>% 
          dplyr::filter(Sample_Type_Involved =="Lung.Tissue.In") %>% 
          dplyr::filter(age_3_grps=="young")
        
        
        #get genes table and add 1
        x= as(mycounts_Tumor, "matrix")
        x= x+1 
        
        # get your group variable (the condition you want to analyze according to it)
        group = get_variable(RNA_data_tumor_young, "Progression_Lab_Inv")
        
        #create edgeR list 
        dgeFull <- DGEList(counts = x, 
                           group = group, 
                           remove.zeros = TRUE)
        
        # calculatee normalization method
        dgeFull <- calcNormFactors(dgeFull, method = "TMM")
        # Estimate dispersions
        dgeFull <- estimateCommonDisp(dgeFull)
        
        dgeFull <- estimateTagwiseDisp(dgeFull)
        
        dgeTest <- exactTest(dgeFull)
        
        dgeFull$samples
        
        #create table
        resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")
        
        ############continue edgeR here#############
        
        res <- resNoFilt$table
        #Reverse Directionality if you need to  
        #res$logFC <- res$logFC*(-1)
        
        #clean the results df 
        
        #Remove Any Data without LOGFC data
        res <- res[!is.na(res$logFC),]
        
        #Convert Important columns to Numeric
        res$FDR <-   as.numeric(as.character(res$FDR))
        res$logFC <-       as.numeric(as.character(res$logFC))
        
        # drop any NA values 
        res<- res %>% 
          drop_na(., FDR) %>% 
          dplyr::arrange(desc(FDR))
        
        #create gene symbol column 
        res<- res %>% 
          dplyr::mutate(Gene.symbol = rownames(.))
        
        # save results (can be used in IPA also)
        write.csv(res, file = "Results/RNA/edgeR.results_young_tumor_rec_vs_no_rec.csv")
        
        ###### volcano plot####
        # create color variable 
        res$sig <- -log10(res$FDR)
        
        # Create variable for color gradient of the dots in the Volcano Plot
        alpha = 0.2
        cols <- densCols(res$logFC, res$sig)
        cols[res$PValue ==0] <- "purple"
          cols[res$logFC > 0 & res$FDR < alpha ] <- "blue"
            cols[res$logFC < 0 & res$FDR < alpha ] <- "lightblue"
              
            
            #plot with labels 
            pdf(file = paste0("Figures/RNA/edgeR_RNA_tumor_young_rec_vs_no_Rec", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
            ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
              geom_point(color = cols)+
              geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                                           ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                              size= 4, 
                              force = 25,
                              segment.colour="grey",
                              segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
              geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
              xlab("Effect size: log2(fold-change)") + #label X Axis
              ylab("-log10(adjusted p-value)")+  #label Y Axis
              theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
                    panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
                    panel.grid.minor = element_blank(),
                    strip.background=element_blank(),
                    axis.title=element_text(size=20,face="bold"),
                    axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
                    axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
                    axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
                    legend.position="none")
            dev.off()
        
##############################################################################
#########################Repeat for lung#### 
            
###Subset for lung old 
            
dds_lung_old  <- dds_lung[,dds_lung$age_3_grps =="old"]
vsd_lung_old  <- vsd_lung[,dds_lung$age_3_grps =="old"]
            
#define variable 
v= "Progression_Lab_Inv"

dds_lung_old[[v]] <- factor(dds_lung_old[[v]])
vsd_lung_old[[v]] <- factor(vsd_lung_old[[v]])


######################Plot PCoA
            
            
#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_lung_old)), method = "bray")
            
#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))
            
#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_lung_old), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"
            
#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ Progression_Lab_Inv,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="Progression_Lab_Inv",suffixes=c("",".centroid"))
            
#stats 
x <- adonis2(vegdist ~ Progression_Lab_Inv, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.lung_old_rec_vs_no_rec", paste0(v, paste0(".txt")))
            , sep = "\t", row.names = T)
            
            
pdf(file = "Figures/RNA/Beta.Diversity.Bray.lung_old_rec_vs_no_rec_RNA.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= Progression_Lab_Inv)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("orangered", "darkred")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= Progression_Lab_Inv), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= Progression_Lab_Inv)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()
            
##############Differential Analysis###################
            
#first select Lung samples only from metadata and counts table 
mycounts_lung <- assay(dds_lung_old)
            
            
#get lung and old only table 
RNA_data_lung_old <- RNA.data.extremes%>% 
  dplyr::filter(Sample_Type_Involved =="Lung.Tissue.UnIn") %>% 
  dplyr::filter(age_3_grps=="old")
            
#get genes table and add 1
x= as(mycounts_lung, "matrix")
x= x+1 
            
# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_lung_old, "Progression_Lab_Inv")
            
            #create edgeR list 
            dgeFull <- DGEList(counts = x, 
                               group = group, 
                               remove.zeros = TRUE)
            
            # calculatee normalization method
            dgeFull <- calcNormFactors(dgeFull, method = "TMM")
            # Estimate dispersions
            dgeFull <- estimateCommonDisp(dgeFull)
            
            dgeFull <- estimateTagwiseDisp(dgeFull)
            
            dgeTest <- exactTest(dgeFull)
            
            dgeFull$samples
            
            #create table
            resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")
            
            ############continue edgeR here#############
            
            res <- resNoFilt$table
            #Reverse Directionality if you need to  
            #res$logFC <- res$logFC*(-1)
            
            #clean the results df 
            
            #Remove Any Data without LOGFC data
            res <- res[!is.na(res$logFC),]
            
            #Convert Important columns to Numeric
            res$FDR <-   as.numeric(as.character(res$FDR))
            res$logFC <-       as.numeric(as.character(res$logFC))
            
            # drop any NA values 
            res<- res %>% 
              drop_na(., FDR) %>% 
              dplyr::arrange(desc(FDR))
            
            #create gene symbol column 
            res<- res %>% 
              dplyr::mutate(Gene.symbol = rownames(.))
            
            # save results (can be used in IPA also)
            write.csv(res, file = "Results/RNA/edgeR.results_old_lung_rec_vs_no_rec.csv")
            
            ###### volcano plot####
            # create color variable 
            res$sig <- -log10(res$FDR)
            
            # Create variable for color gradient of the dots in the Volcano Plot
            alpha = 0.2
            cols <- densCols(res$logFC, res$sig)
            cols[res$PValue ==0] <- "purple"
              cols[res$logFC > 0 & res$FDR < alpha ] <- "darkred"
                cols[res$logFC < 0 & res$FDR < alpha ] <- "orangered"
                  
                
                #plot with labels 
                pdf(file = paste0("Figures/RNA/edgeR_RNA_lung_old_rec_vs_no_Rec", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
                ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
                  geom_point(color = cols)+
                  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                                  size= 4, 
                                  force = 25,
                                  segment.colour="grey",
                                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
                  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
                  xlab("Effect size: log2(fold-change)") + #label X Axis
                  ylab("-log10(adjusted p-value)")+  #label Y Axis
                  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
                        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
                        panel.grid.minor = element_blank(),
                        strip.background=element_blank(),
                        axis.title=element_text(size=20,face="bold"),
                        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
                        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
                        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
                        legend.position="none")
                dev.off()
                
                ###################################################################################
                
###########Repeat for YOung 
                
                
###Subset for lung young 

dds_lung_young  <- dds_lung[,dds_lung$age_3_grps =="young"]
vsd_lung_young  <- vsd_lung[,dds_lung$age_3_grps =="young"]


#define variable 
v= "Progression_Lab_Inv"

dds_lung_young[[v]] <- factor(dds_lung_young[[v]])
vsd_lung_young[[v]] <- factor(vsd_lung_young[[v]])

######################Plot PCoA
                
                #Create Distance Matrix
                vegdist = vegdist(t(assay(vsd_lung_young)), method = "bray")
                
                #Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
                CmdScale <- cmdscale(vegdist, k =10)
                #calculated Sample variance for each PC
                vars <- apply(CmdScale, 2, var)
                #Create Variable with the Percent Variance
                percentVar <- round(100 * (vars/sum(vars)))
                
                #Merge PC Data with MetaData
                newResults <- merge(x = CmdScale, y = colData(vsd_lung_young), by = "row.names", all.x = TRUE)
                #Rename Variables for PC1 and PC2
                colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
                colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
                colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"
                
                #Calculate the Centroid Value
                centroids <- aggregate(cbind(PC1,PC2)~ Progression_Lab_Inv,data= newResults, mean)
                #Merge the Centroid Data into the PCOA Data
                newResults <- merge(newResults,centroids,by="Progression_Lab_Inv",suffixes=c("",".centroid"))
                
                #stats 
                x <- adonis2(vegdist ~ Progression_Lab_Inv, data = newResults)
                write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.lung_young_rec_vs_no_rec", paste0(v, paste0(".txt")))
                            , sep = "\t", row.names = T)
                
                
                pdf(file = "Figures/RNA/Beta.Diversity.Bray.lung_young_rec_vs_no_rec_RNA.pdf", 
                    height = 20, width = 18)
                ggplot(newResults, aes(PC1, PC2, color= Progression_Lab_Inv)) + # Graph PC1 and PC2
                  geom_point(size=5) + # Set the size of the points
                  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
                  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
                  #Set colors for each category, should be the same number of categories
                  scale_color_manual(values=c("skyblue", "darkblue")) + 
                  #plot point and lines from centroid
                  geom_point(data=centroids, aes(x=PC1, y=PC2, color= Progression_Lab_Inv), size=0) +
                  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= Progression_Lab_Inv)) + 
                  #labels centroids should be same number of categories
                  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
                  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
                  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
                dev.off()
                
                ##############Differential Analysis###################
                
                #first select Lung samples only from metadata and counts table 
                mycounts_lung <- assay(dds_lung_young)
                
                
                #get lung and young only table 
                RNA_data_lung_young <- RNA.data.extremes%>% 
                  dplyr::filter(Sample_Type_Involved =="Lung.Tissue.UnIn") %>% 
                  dplyr::filter(age_3_grps=="young")
                
                #get genes table and add 1
                x= as(mycounts_lung, "matrix")
                x= x+1 
                
                # get your group variable (the condition you want to analyze according to it)
                group = get_variable(RNA_data_lung_young, "Progression_Lab_Inv")
                
                #create edgeR list 
                dgeFull <- DGEList(counts = x, 
                                   group = group, 
                                   remove.zeros = TRUE)
                
                # calculatee normalization method
                dgeFull <- calcNormFactors(dgeFull, method = "TMM")
                # Estimate dispersions
                dgeFull <- estimateCommonDisp(dgeFull)
                
                dgeFull <- estimateTagwiseDisp(dgeFull)
                
                dgeTest <- exactTest(dgeFull)
                
                dgeFull$samples
                
                #create table
                resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")
                
                ############continue edgeR here#############
                
                res <- resNoFilt$table
                #Reverse Directionality if you need to  
                #res$logFC <- res$logFC*(-1)
                
                #clean the results df 
                
                #Remove Any Data without LOGFC data
                res <- res[!is.na(res$logFC),]
                
                #Convert Important columns to Numeric
                res$FDR <-   as.numeric(as.character(res$FDR))
                res$logFC <-       as.numeric(as.character(res$logFC))
                
                # drop any NA values 
                res<- res %>% 
                  drop_na(., FDR) %>% 
                  dplyr::arrange(desc(FDR))
                
                #create gene symbol column 
                res<- res %>% 
                  dplyr::mutate(Gene.symbol = rownames(.))
                
                # save results (can be used in IPA also)
                write.csv(res, file = "Results/RNA/edgeR.results_young_lung_rec_vs_no_rec.csv")
                
                ###### volcano plot####
                # create color variable 
                res$sig <- -log10(res$FDR)
                
                # Create variable for color gradient of the dots in the Volcano Plot
                alpha = 0.2
                cols <- densCols(res$logFC, res$sig)
                cols[res$PValue ==0] <- "purple"
                  cols[res$logFC > 0 & res$FDR < alpha ] <- "darkblue"
                    cols[res$logFC < 0 & res$FDR < alpha ] <- "skyblue"
                      
                    
                    #plot with labels 
                    pdf(file = paste0("Figures/RNA/edgeR_RNA_lung_young_rec_vs_no_Rec", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
                    ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
                      geom_point(color = cols)+
                      geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                                                   ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                                      size= 4, 
                                      force = 25,
                                      segment.colour="grey",
                                      segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
                      geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
                      xlab("Effect size: log2(fold-change)") + #label X Axis
                      ylab("-log10(adjusted p-value)")+  #label Y Axis
                      theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
                            panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
                            panel.grid.minor = element_blank(),
                            strip.background=element_blank(),
                            axis.title=element_text(size=20,face="bold"),
                            axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
                            axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
                            axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
                            legend.position="none")
                    dev.off()
                    
################################################################################
#save image 
save.image("early_lung_cancer_by_age_RNA.RData")

                    
                    
                    
                    
########Heatmap of IPA results comparing rec vs no rec in each age group and tissue########

#read IPA results 
IPA_res <- read.csv(file = "IPA/IPA_early_lung_cancer_rec_vs_no_rec.csv")

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-3.71, 0, 3.873), c("blue", "white", "orange"))
col_fun(seq(-3.71, 0, 3.873))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/IPA_heatmap_by_age.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()


########################################################################################
############################# Cibersort Analysis ######################################

#read cibersort results 
cibersort_res <- read.table("~/Dropbox (NYU Langone Health)/Fares Darawshyâ€™s files/Home/Projects/Early.Lung.Cancer/RNA.seq.Surgical.cohort/Data/CIBERSORTx_Job5_Adjusted.txt", 
                              header = T, sep = "\t", row.names = 1)

#get clincal data 
RNA.data

## add necessary metadata elements 
cibersort_res<- cibersort_res %>% 
  mutate(., Sample_Type_Involved = RNA.data$Sample_Type_Involved) %>% 
  dplyr::mutate(Progression_Lab_Inv=RNA.data$Progression_Lab_Inv) %>% 
  dplyr::mutate(age_3_grps=RNA.data$age_3_grps)

#select only age extremes 
cibersort_res_extremes <- cibersort_res %>% 
  dplyr::filter(age_3_grps!= "middle")

#split into tumor and lung tissue 
cibersort_res_extremes_tumor <- cibersort_res_extremes %>% 
  dplyr::filter(Sample_Type_Involved=="Lung.Tissue.In")

cibersort_res_extremes_lung <- cibersort_res_extremes %>% 
  dplyr::filter(Sample_Type_Involved=="Lung.Tissue.UnIn")

#boxplot according to age adn progression 
#in each dataframe create another variable that describe prgoression and age 
cibersort_res_extremes_tumor$age_rec <- ifelse(cibersort_res_extremes_tumor$Progression_Lab_Inv=="In.No.Recurrence" & cibersort_res_extremes_tumor$age_3_grps=="old", "old_no_rec", 
                                               ifelse(cibersort_res_extremes_tumor$Progression_Lab_Inv=="In.Recurrence" & cibersort_res_extremes_tumor$age_3_grps=="old", "old_rec", 
                                                      ifelse(cibersort_res_extremes_tumor$Progression_Lab_Inv=="In.No.Recurrence" & cibersort_res_extremes_tumor$age_3_grps=="young", "young_rec", 
                                                             "young_no_rec")))
cibersort_res_extremes_tumor$age_rec <- factor(cibersort_res_extremes_tumor$age_rec)

cibersort_res_extremes_lung$age_rec <- ifelse(cibersort_res_extremes_lung$Progression_Lab_Inv=="UnIn.No.Recurrence" & cibersort_res_extremes_lung$age_3_grps=="old", "old_no_rec", 
                                               ifelse(cibersort_res_extremes_lung$Progression_Lab_Inv=="UnIn.Recurrence" & cibersort_res_extremes_lung$age_3_grps=="old", "old_rec", 
                                                      ifelse(cibersort_res_extremes_lung$Progression_Lab_Inv=="UnIn.No.Recurrence" & cibersort_res_extremes_lung$age_3_grps=="young", "young_rec", 
                                                             "young_no_rec")))
cibersort_res_extremes_lung$age_rec <- factor(cibersort_res_extremes_lung$age_rec)

#create one plot to examine it 
ggplot(cibersort_res_extremes_tumor, aes(x= age_rec, y=Neutrophils, fill=age_rec))+
  geom_boxplot()+
  geom_jitter(aes(alpha=0.7))+
  stat_compare_means(aes(label = after_stat(p.signif)), 
                     comparisons = list(c("old_no_rec", "old_rec"), 
                                        c("young_no_rec", "young_rec"), 
                                        c("old_no_rec", "young_no_rec"), 
                                        c("old_rec", "young_rec")))+
  scale_fill_manual(values = c("orange", "red","lightblue", "blue"))+
  scale_x_discrete(breaks= c("old_no_rec", "old_rec", "young_no_rec", "young_rec"),
                   labels= c(glue("Old<br>No Recurrence"),
                             glue("Old<br>Recurrence"),
                             glue("Young<br>No Recurrence"),
                             glue("Young<br>Recurrence")))+
  
  xlab("")+
  ylab("")+
  ggtitle("Neutrophils")+
  scale_y_log10()+
  theme_classic()+
  theme(plot.title = element_text(face="bold"), 
        axis.text.x = element_markdown(face = "bold", size=14), 
        axis.text.y = element_text(face = "bold", size = 14), 
        legend.position = "none")

#creating a variable to loop over 
col_names_cibersort <- colnames(cibersort_res_extremes_tumor)
col_names_cibersort <- col_names_cibersort[1:22]

#loop over columns 
for (i in col_names_cibersort){
  p <- ggplot(cibersort_res_extremes_tumor, aes_string(x= cibersort_res_extremes_tumor$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(aes(label = after_stat(p.signif)), 
                       comparisons = list(c("old_no_rec", "old_rec"), 
                                          c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "young_no_rec"), 
                                          c("old_rec", "young_rec")))+
    scale_color_manual(values = c("orange", "red","lightblue", "blue"))+
    scale_x_discrete(breaks= c("old_no_rec", "old_rec", "young_no_rec", "young_rec"),
                     labels= c(glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence"),
                               glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Cibersort/", paste0(i, paste0(".boxplot"), paste0(".Cibersort.by.age_recu"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}

cibersort_res_extremes_tumor$age_3_grps <- factor(cibersort_res_extremes_tumor$age_3_grps)


#creating a variable to loop over 
col_names_cibersort <- colnames(cibersort_res_extremes_tumor)
col_names_cibersort <- col_names_cibersort[1:22]

#loop over columns 
for (i in col_names_cibersort){
  p <- ggplot(cibersort_res_extremes_tumor, aes_string(x= cibersort_res_extremes_tumor$age_3_grps, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_3_grps))+
    stat_compare_means(aes(label = after_stat(p.signif)))+ 
    scale_color_manual(values = c("darkblue", "darkgreen"))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Cibersort/", paste0(i, paste0(".boxplot"), paste0(".Cibersort.by.age_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}

#repeat for lung 

#creating a variable to loop over 
col_names_cibersort <- colnames(cibersort_res_extremes_lung)
col_names_cibersort <- col_names_cibersort[1:22]

#loop over columns 
for (i in col_names_cibersort){
  p <- ggplot(cibersort_res_extremes_lung, aes_string(x= cibersort_res_extremes_lung$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(aes(label = after_stat(p.signif)), 
                       comparisons = list(c("old_no_rec", "old_rec"), 
                                          c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "young_no_rec"), 
                                          c("old_rec", "young_rec")))+
    scale_color_manual(values = c("orange", "red","lightblue", "blue"))+
    scale_x_discrete(breaks= c("old_no_rec", "old_rec", "young_no_rec", "young_rec"),
                     labels= c(glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence"),
                               glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Cibersort/", paste0(i, paste0(".boxplot"), paste0(".Cibersort.by.age_recu_lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}





cibersort_res_extremes_lung$age_3_grps <- factor(cibersort_res_extremes_lung$age_3_grps)


#creating a variable to loop over 
col_names_cibersort <- colnames(cibersort_res_extremes_lung)
col_names_cibersort <- col_names_cibersort[1:22]

#loop over columns 
for (i in col_names_cibersort){
  p <- ggplot(cibersort_res_extremes_lung, aes_string(x= cibersort_res_extremes_lung$age_3_grps, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_3_grps))+
    stat_compare_means(aes(label = after_stat(p.signif)))+ 
    scale_color_manual(values = c("darkblue", "darkgreen"))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Cibersort/", paste0(i, paste0(".boxplot"), paste0(".Cibersort.by.age_lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}

########################################################################################
############################## NYU early stage according to median age ###################



#Load RNA Seq file 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

#load meadata 
map = "Data/Surgical.Cohort.Map.txt"
mapping.table = sample_data(read.table(map,header = T, sep = "\t", row.names = 1))

#Keep Only MetaData of RNASeq Samples
#Keep only samples with RNA ID that matches the RNA count data 
RNA.data = mapping.table[mapping.table$RNA_Seq_done_Final==1,]
RNA.data <- RNA.data[RNA.data$RNA_ID!= "n.a",]

#Pick up the column that have RNA ID in metadata 
#We want to match ID names in each element 
RNA.data$RNA_ID

#Order Meta Data by SampleId
RNA.data <- RNA.data[order(RNA.data$RNA_ID),]

#Order Count Data by SampleID and replace the X before each name 
colnames(mycounts) <- gsub("X", "", colnames(mycounts))
mycounts <- mycounts [, order(colnames(mycounts))]

#Confirm Sample IDs match for Count and Meta Data
table(colnames(mycounts)==as.character(RNA.data$RNA_ID))
rownames(RNA.data) <- RNA.data$RNA_ID

#confirm columns names of data and rownamnes of metadata are similar 
table(colnames(mycounts)==rownames(RNA.data))



######################Creating age groups ####################

#define age as numeric 
RNA.data$Age <- as.numeric(RNA.data$Age)

#calculate median (70)
median(RNA.data$Age)

#now build another column in the metadata that fit these three groups 
RNA.data$age_grp <- ifelse(RNA.data$Age >70, "old","young")


######### Working on Creating Table 1 from metadata##########

Table.1.data <- data.frame(RNA.data)
Table.1.data <- Table.1.data %>% 
  dplyr::filter(Sample_Type_Involved=="Lung.Tissue.In")


#add statistical analysis column 
#define p value function 

pvalue <- function(x, ...) {
  # Construct vectors of data y, and groups (strata) g
  y <- unlist(x)
  g <- factor(rep(1:length(x), times=sapply(x, length)))
  if (is.numeric(y)) {
    # For numeric variables, perform a standard 2-sample t-test
    p <- t.test(y ~ g)$p.value
  } else {
    # For categorical variables, perform a chi-squared test of independence
    p <- chisq.test(table(y, g))$p.value
  }
  # Format the p-value, using an HTML entity for the less-than sign.
  # The initial empty string places the output on the line below the variable label.
  c("", sub("<", "&lt;", format.pval(p, digits=3, eps=0.001)))
}

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(Male_1) + factor(RACE) + as.numeric(Age) + factor(Smoking_status) + as.numeric(Pack_Years) 
       + factor(Stage) +factor(Outcome) + factor(Progression_Lab) + factor(ProgType_Lab)+ as.numeric(Size_cm) + factor(five_y_mortality)
       # set the variable you want to stratify by 
       | age_grp, 
       #set data 
       data=Table.1.data, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))
#now add stats (same as above except where notes added ) for these two groups only 
table1(~ 
         factor(Male_1) + factor(RACE) + as.numeric(Age) + factor(Smoking_status) + as.numeric(Pack_Years) 
       + factor(Stage) +factor(Outcome) + factor(Progression_Lab) + factor(ProgType_Lab)+ as.numeric(Size_cm) + factor(five_y_mortality)
       | age_grp, data=Table.1.data, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))

#stats for recurrence type without the group of no recurrence 
stats.table <- Table.1.data %>% 
  dplyr::filter(ProgType_Lab != "No.Recurrence")

chisq.test(stats.table$ProgType_Lab, stats.table$age_grp) #p=0.321

#copy and paste the above results and edit in excel / word 




####kaplan meier curvve of old vs young - recurrence #### 


#Load relevant packages 
library(dplyr)
library(survival)
library(survminer)

#Use subset of samples with tumor only 

tumor.table.extremes <- data.frame(RNA.data) %>% 
  dplyr::filter(Sample_Type_Involved=="Lung.Tissue.In")

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tumor.table.extremes

#search for columns to keep 
metadata$New_TTP
metadata$Progression

###plot for recurrence 
#Column to be used as time (in days) - New_TTP 
# column to be used as status is Progression Lab
survival.data <- metadata[, c("New_TTP","Progression", "age_grp" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- as.factor(survival.data$Age)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Old", "Young"), legend.title="Age",  
                            palette=c("blue3", "green4"), size=1,
                            title="Kaplan-Meier Curve for Recurrence Following Surgery According to Age",
                            ylab="Percent Without Recurrence",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot 
pdf(file = "Early.Lung.Cancer.Kaplan.Meier.by_median_age.pdf", width = 8, height = 8)
survival.plot
dev.off()




#############################Creating DESeq Object ############################

#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(mycounts, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(mycounts))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)

#Convert Model Variable into Factor
RNA.data$age_grp <- as.factor(RNA.data$age_grp)
RNA.data$Sample_Type_Involved <- as.factor(RNA.data$Sample_Type_Involved)
RNA.data$Progression_Lab_Inv <- as.factor(RNA.data$Progression_Lab_Inv)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = RNA.data, design = ~ age_grp + Progression_Lab_Inv)

#Normalization Step 
dds <- estimateSizeFactors(dds)

#Retrive normalized counts matrix 
normalized_counts <- counts(dds, normalized=TRUE)
#save it 
write.table(normalized_counts, file="Results/normalized_counts.txt", sep="\t", quote=F, col.names=NA)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#Drop Levels
dds$age_grp   <- droplevels(dds$age_grp)
vsd$age_grp   <- droplevels(vsd$age_grp)


###############################################################################
################Running Differential Analysis##################

#run old vs young 

###Subset for Tumor

dds_tumor <- dds[,dds$Sample_Type_Involved=="Lung.Tissue.In"]
vsd_tumor <- vsd[,vsd$Sample_Type_Involved=="Lung.Tissue.In"]


#### compare old vs young in tumor####


#define variables 
dds_tumor$age_grp
v= "age_grp"

#Set Reference Level for Comparison (Control Group)
dds_tumor[[v]] <- factor(dds_tumor[[v]])
dds_tumor[[v]] <- relevel(dds_tumor[[v]], ref = "young")

vsd_tumor[[v]] <- factor(vsd_tumor[[v]])
vsd_tumor[[v]] <- relevel(vsd_tumor[[v]], ref = "young")


######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_tumor)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_tumor), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ age_grp,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="age_grp",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ age_grp, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.Tumor_old_vs_young", paste0(v, paste0(".txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.Tumor.samples.age_grp_RNA.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= age_grp)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("green4", "blue3")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= age_grp), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= age_grp)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_Tumor <- assay(dds_tumor)

#get genes table and add 1
x= as(mycounts_Tumor, "matrix")
x= x+1 

#get Lung only table 
RNA_data_tumor <- data.frame(RNA.data)%>% 
  dplyr::filter(Sample_Type_Involved =="Lung.Tissue.In")

# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_tumor, "age_grp")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

dgeFull$samples

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_age_grp_tumor.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "blue3"
cols[res$logFC < 0 & res$FDR < alpha ] <- "green4"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_Old_vs_Young_by_median_RNA_tumor", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


######################
###subset for lung 
dds_lung <- dds[,dds$Sample_Type_Involved=="Lung.Tissue.UnIn"]
vsd_lung <- vsd[,vsd$Sample_Type_Involved=="Lung.Tissue.UnIn"]


#define variables 
dds_lung$age_grp
v= "age_grp"

#Set Reference Level for Comparison (Control Group)
dds_lung[[v]] <- factor(dds_lung[[v]])
dds_lung[[v]] <- relevel(dds_lung[[v]], ref = "young")

vsd_lung[[v]] <- factor(vsd_lung[[v]])
vsd_lung[[v]] <- relevel(vsd_lung[[v]], ref = "young")

######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_lung)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_lung), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ age_grp,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="age_grp",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ age_grp, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.lung_old_vs_young", paste0(v, paste0(".txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.lung.samples.age_grp_RNA.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= age_grp)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("green4", "blue3")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= age_grp), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= age_grp)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_lung <- assay(dds_lung)

#get genes table and add 1
x= as(mycounts_lung, "matrix")
x= x+1 

#get Lung only table 
RNA_data_lung <- data.frame(RNA.data)%>% 
  dplyr::filter(Sample_Type_Involved =="Lung.Tissue.UnIn")

# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_lung, "age_grp")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

dgeFull$samples

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_age_grp_lung.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "blue3"
cols[res$logFC < 0 & res$FDR < alpha ] <- "green4"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_Old_vs_Young_by_median_RNA_lung", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()

################################################################################
##########Analysis according to recurrence ####################

########### Tumor subset first 

###Subset for Tumor old 

dds_tumor_old  <- dds_tumor[,dds_tumor$age_grp =="old"]
vsd_tumor_old  <- vsd_tumor[,dds_tumor$age_grp =="old"]

#define variable 

v= "Progression_Lab_Inv"

dds_tumor_old[[v]] <- factor(dds_tumor_old[[v]])
vsd_tumor_old[[v]] <- factor(vsd_tumor_old[[v]])

######################Plot PCoA

#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_tumor_old)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_tumor_old), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ Progression_Lab_Inv,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="Progression_Lab_Inv",suffixes=c("",".centroid"))

#stats 
x <- adonis2(vegdist ~ Progression_Lab_Inv, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.Tumor_old_rec_vs_no_rec", paste0(v, paste0(".txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.Tumor_old_rec_vs_no_rec_by_age_median.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= Progression_Lab_Inv)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("orange", "red")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= Progression_Lab_Inv), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= Progression_Lab_Inv)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_Tumor <-assay(dds_tumor_old)


#get TUmor and old only table 
RNA_data_tumor_old <- data.frame(RNA.data)%>% 
  dplyr::filter(Sample_Type_Involved =="Lung.Tissue.In") %>% 
  dplyr::filter(age_grp=="old")


#get genes table and add 1
x= as(mycounts_Tumor, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_tumor_old, "Progression_Lab_Inv")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

dgeFull$samples

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_old_tumor_rec_vs_no_rec_age_median.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "red"
cols[res$logFC < 0 & res$FDR < alpha ] <- "orange"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_RNA_tumor_old_rec_vs_no_Rec_age_median", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()

###################################################################################

###########Repeat for YOung 


###Subset for Tumor young 

dds_tumor_young  <- dds_tumor[,dds_tumor$age_grp =="young"]
vsd_tumor_young  <- vsd_tumor[,dds_tumor$age_grp =="young"]

#define variable 

v= "Progression_Lab_Inv"

dds_tumor_young[[v]] <- factor(dds_tumor_young[[v]])
vsd_tumor_young[[v]] <- factor(vsd_tumor_young[[v]])


######################Plot PCoA

#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_tumor_young)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_tumor_young), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ Progression_Lab_Inv,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="Progression_Lab_Inv",suffixes=c("",".centroid"))

#stats 
x <- adonis2(vegdist ~ Progression_Lab_Inv, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.Tumor_young_rec_vs_no_rec", paste0(v, paste0(".txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.Tumor_young_rec_vs_no_rec_age_median.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= Progression_Lab_Inv)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("lightblue", "blue")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= Progression_Lab_Inv), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= Progression_Lab_Inv)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_Tumor <- assay(dds_tumor_young)


#get TUmor and young only table 
RNA_data_tumor_young <- data.frame(RNA.data)%>% 
  dplyr::filter(Sample_Type_Involved =="Lung.Tissue.In") %>% 
  dplyr::filter(age_grp=="young")


#get genes table and add 1
x= as(mycounts_Tumor, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_tumor_young, "Progression_Lab_Inv")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

dgeFull$samples

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_young_tumor_rec_vs_no_rec_age_median.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "blue"
cols[res$logFC < 0 & res$FDR < alpha ] <- "lightblue"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_RNA_tumor_young_rec_vs_no_Rec_age_median", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()

##############################################################################
#########################Repeat for lung#### 

###Subset for lung old 

dds_lung_old  <- dds_lung[,dds_lung$age_grp =="old"]
vsd_lung_old  <- vsd_lung[,dds_lung$age_grp =="old"]

#define variable 
v= "Progression_Lab_Inv"

dds_lung_old[[v]] <- factor(dds_lung_old[[v]])
vsd_lung_old[[v]] <- factor(vsd_lung_old[[v]])


######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_lung_old)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_lung_old), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ Progression_Lab_Inv,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="Progression_Lab_Inv",suffixes=c("",".centroid"))

#stats 
x <- adonis2(vegdist ~ Progression_Lab_Inv, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.lung_old_rec_vs_no_rec", paste0(v, paste0(".txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.lung_old_rec_vs_no_rec_age_median.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= Progression_Lab_Inv)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("orangered", "darkred")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= Progression_Lab_Inv), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= Progression_Lab_Inv)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_lung <- assay(dds_lung_old)


#get lung and old only table 
RNA_data_lung_old <- data.frame(RNA.data)%>% 
  dplyr::filter(Sample_Type_Involved =="Lung.Tissue.UnIn") %>% 
  dplyr::filter(age_grp=="old")

#get genes table and add 1
x= as(mycounts_lung, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_lung_old, "Progression_Lab_Inv")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

dgeFull$samples

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_old_lung_rec_vs_no_rec_age_median.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "darkred"
cols[res$logFC < 0 & res$FDR < alpha ] <- "orangered"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_RNA_lung_old_rec_vs_no_Rec_age_median", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()

###################################################################################

###########Repeat for YOung 


###Subset for lung young 

dds_lung_young  <- dds_lung[,dds_lung$age_grp =="young"]
vsd_lung_young  <- vsd_lung[,dds_lung$age_grp =="young"]


#define variable 
v= "Progression_Lab_Inv"

dds_lung_young[[v]] <- factor(dds_lung_young[[v]])
vsd_lung_young[[v]] <- factor(vsd_lung_young[[v]])

######################Plot PCoA

#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_lung_young)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_lung_young), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ Progression_Lab_Inv,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="Progression_Lab_Inv",suffixes=c("",".centroid"))

#stats 
x <- adonis2(vegdist ~ Progression_Lab_Inv, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.lung_young_rec_vs_no_rec", paste0(v, paste0(".txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.lung_young_rec_vs_no_rec_RNA_age_median.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= Progression_Lab_Inv)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("skyblue", "darkblue")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= Progression_Lab_Inv), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= Progression_Lab_Inv)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_lung <- assay(dds_lung_young)


#get lung and young only table 
RNA_data_lung_young <- data.frame(RNA.data)%>% 
  dplyr::filter(Sample_Type_Involved =="Lung.Tissue.UnIn") %>% 
  dplyr::filter(age_grp=="young")

#get genes table and add 1
x= as(mycounts_lung, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_lung_young, "Progression_Lab_Inv")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

dgeFull$samples

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_young_lung_rec_vs_no_rec_age_median.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "darkblue"
cols[res$logFC < 0 & res$FDR < alpha ] <- "skyblue"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_RNA_lung_young_rec_vs_no_Rec_age_median", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()

################################################################################
#save image 
save.image("early_lung_cancer_by_age_RNA.RData")

########Heatmap of IPA results comparing rec vs no rec in each age group and tissue########

#read IPA results 
IPA_res <- read.csv(file = "IPA/IPA_early_lung_cancer_median_age.csv")

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.84, 0, 4.95), c("blue", "white", "orange"))
col_fun(seq(-2.84, 0, 4.95))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/IPA_heatmap_by_age_median.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()


##########plot tumor subset only

#read IPA results 
IPA_res <- read.csv(file = "IPA/IPA_early_lung_cancer_median_age.csv")

IPA_res <- IPA_res %>% 
  dplyr::select(-ends_with("lung"))

#get max and min values 
max(IPA_res$old_tumor, na.rm = TRUE)
max(IPA_res$young_tumor, na.rm = TRUE)
min(IPA_res$old_tumor, na.rm = TRUE)
min(IPA_res$young_tumor, na.rm = TRUE)

#arrange 
IPA_res <- IPA_res %>% 
  dplyr::arrange(desc(old_tumor))
#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2, 0, 2.828), c("blue", "white", "orange"))
col_fun(seq(-2, 0, 2.828))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/IPA_heatmap_by_age_median_tumor_subset.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()






#### plot lung subset only 


#read IPA results 
IPA_res <- read.csv(file = "IPA/IPA_early_lung_cancer_median_age.csv")

IPA_res <- IPA_res %>% 
  dplyr::select(-ends_with("tumor"))

#get max and min values 
max(IPA_res$old_lung, na.rm = TRUE)
max(IPA_res$young_lung, na.rm = TRUE)
min(IPA_res$old_lung, na.rm = TRUE)
min(IPA_res$young_lung, na.rm = TRUE)

#arrange 
IPA_res <- IPA_res %>% 
  dplyr::arrange(desc(old_lung))
#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.84, 0, 4.95), c("blue", "white", "orange"))
col_fun(seq(-2, 0, 2.828))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/IPA_heatmap_by_age_median_lung_subset.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()














########################################################################################
############################# TCGA Anlaysis data Validation ######################################

#install TCGA package 
BiocManager::install("TCGAbiolinks")
#load the package 
library(TCGAbiolinks)

#load the data you want from TCGA 
proj <- "TCGA-LUAD"
query <- GDCquery(
  project = proj,
  data.category = "Transcriptome Profiling", 
  data.type = "Gene Expression Quantification",
  workflow.type = "STAR - Counts"
)
#download the files you want 
GDCdownload(query)
data <- GDCprepare(query)

#get counts and metadata from summarized experiment object 
tcga_counts <- data.frame(assay(data))

#get metadata
tcga_metadata <- data.frame(data@colData)

#make counts table rownames genes names and not gene id 
names <- make.unique(data@rowRanges$gene_name)
rownames(tcga_counts) <- names

#replace metadata rownames format to match them to the columns of counts table 
rownames(tcga_metadata) <- gsub("-", ".", rownames(tcga_metadata))

#make sure counts table columns and rows of metadata are the same 
table(colnames(tcga_counts)==rownames(tcga_metadata))

#get information from metadata 
colnames(tcga_metadata)

#add clinical information you need from other data downloaded form www.cbioportal.org 
#read the file downloaded 
tcga_progression_data <- read.delim2("TCGA/KM_Plot__Disease_Free_(months).txt", header = TRUE)
tcga_progression_data<- tcga_progression_data %>% 
  dplyr::rename(patient=Patient_ID)

#add progression data to metadata 
tcga_metadata$patient
tcga_progression_data$patient
#before joining, get rownames of tcga data so you don't lose them and use them later 
tcga_rownames <- rownames(tcga_metadata)

#join and correct rownames 
tcga_metadata <- inner_join(tcga_metadata, tcga_progression_data, by="patient")
rownames(tcga_metadata) <- tcga_rownames

tcga_metadata$definition <- factor(tcga_metadata$definition)
tcga_metadata %>% 
  dplyr::group_by(definition) %>% 
  dplyr::summarise(n=dplyr::count(.))

#we have 539 primary tumors, 2 recurrent tumor and 59 normal tissue 
#will remove 2 recurrent tumor from analsys which wil leave out 598 samples  
tcga_metadata <- tcga_metadata %>% 
  dplyr::filter(definition != "Recurrent Solid Tumor")


#filter tcga counts so thery include only human genes 
tcga_counts_filtered <- tcga_counts %>% 
  dplyr::filter(rownames(.)%in%rownames(mycounts))

nrow(mycounts)
nrow(tcga_counts_filtered)


#remove those from counts table 
tcga_counts_filtered <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata))

#finally validate that count and clinical data table match 
table(rownames(tcga_metadata)==colnames(tcga_counts_filtered))


#create age group according to median 
median(tcga_metadata$age_at_index, na.rm = TRUE)

tcga_metadata$age_grp <- ifelse(tcga_metadata$age_at_index < 66, "young", "old")

#create age extremes that are similar to age groups of NYU cohort 
tcga_metadata$age_3_grps <- ifelse(tcga_metadata$age_at_index < 66, "young", ifelse(tcga_metadata$age_at_index > 72, "old", "middle"))
tcga_metadata %>% 
  dplyr::group_by(age_3_grps) %>% 
  dplyr::summarise(n=dplyr::count(.))


#create 5 year survival columns 
tcga_metadata$five_year <- (tcga_metadata$year_of_diagnosis +5)
tcga_metadata$year_of_death
tcga_metadata$dead_or_not_five_years <- ifelse(tcga_metadata$year_of_death < tcga_metadata$five_year, "dead", "alive")
tcga_metadata$dead_or_not_five_years[is.na(tcga_metadata$dead_or_not_five_years)] <- "alive"

#correct recurrence column 
tcga_metadata$DFS_STATUS <- gsub("0:DiseaseFree", "No.Recurrence",tcga_metadata$DFS_STATUS )
tcga_metadata$DFS_STATUS <- gsub("1:Recurred/Progressed", "Recurrence",tcga_metadata$DFS_STATUS)

#create smoking variable 
tcga_metadata$smoking_ever <- ifelse(tcga_metadata$cigarettes_per_day =="NA", "never", "ever")


############################# overall tcga table 1 according to median age ###################
#get tabel 1 information 

Table.1.data <- tcga_metadata

#filter for number of subjects only (516) ####notice that you choose finally 498 patients with age information so you can divide them ato age group 
Table.1.data.subjects <- Table.1.data %>% 
  distinct(patient,.keep_all = TRUE)

#calculate median age = 66 
median(Table.1.data.subjects$age_at_index, na.rm = TRUE)

#add statistical analysis column 
#define p value function 

pvalue <- function(x, ...) {
  # Construct vectors of data y, and groups (strata) g
  y <- unlist(x)
  g <- factor(rep(1:length(x), times=sapply(x, length)))
  if (is.numeric(y)) {
    # For numeric variables, perform a standard 2-sample t-test
    p <- t.test(y ~ g)$p.value
  } else {
    # For categorical variables, perform a chi-squared test of independence
    p <- chisq.test(table(y, g))$p.value
  }
  # Format the p-value, using an HTML entity for the less-than sign.
  # The initial empty string places the output on the line below the variable label.
  c("", sub("<", "&lt;", format.pval(p, digits=3, eps=0.001)))
}
colnames(Table.1.data.subjects)

Table.1.data.subjects <- Table.1.data.subjects %>% 
  dplyr::filter(age_grp!= "NA")

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever) +factor(dead_or_not_five_years)+factor(DFS_STATUS)
       # set the variable you want to stratify by 
       | age_grp, 
       #set data 
       data=Table.1.data.subjects, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))

#now add stats (same as above except where notes added )
table1(~ factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever)+factor(dead_or_not_five_years)+factor(DFS_STATUS)
       | age_grp, data=Table.1.data.subjects, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))

#copy and paste the above results and edit in excel / word 
#compare numeric variables 

compare_means(age_at_index~age_grp, data=Table.1.data.subjects)
compare_means(pack_years_smoked~age_grp, data=Table.1.data.subjects)
compare_means(days_to_death~age_grp, data=Table.1.data.subjects)

##########################################################################################
#repeat while looking at extreme age groups ( remove middle group  )

#get tabel 1 information 

Table.1.data <- tcga_metadata

#filter for number of subjects only (516) ####notice that you choose finally 498 patients with age information so you can divide them ato age group 
Table.1.data.subjects <- Table.1.data %>% 
  distinct(patient,.keep_all = TRUE)

Table.1.data.subjects <- Table.1.data.subjects %>% 
  dplyr::filter(age_3_grps!= "NA")

Table.1.data.subjects.extremes <- Table.1.data.subjects %>% 
  dplyr::filter(age_3_grps!="middle")

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever) +factor(dead_or_not_five_years)+factor(DFS_STATUS)
       # set the variable you want to stratify by 
       | age_3_grps, 
       #set data 
       data=Table.1.data.subjects.extremes, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))

#now add stats (same as above except where notes added )
table1(~ factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever)+factor(dead_or_not_five_years)+factor(DFS_STATUS)
       | age_3_grps, 
       data=Table.1.data.subjects.extremes, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))

#copy and paste the above results and edit in excel / word 
#compare numeric variables 

compare_means(age_at_index~age_3_grps, data=Table.1.data.subjects.extremes)
compare_means(pack_years_smoked~age_3_grps, data=Table.1.data.subjects.extremes)
compare_means(days_to_death~age_3_grps, data=Table.1.data.subjects.extremes)




##########################################################################################
##################now put the same table for samples #################

tcga_metadata_sample <- tcga_metadata %>% 
  dplyr::filter(age_grp!= "NA")

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(definition)
       # set the variable you want to stratify by 
       | age_grp, 
       #set data 
       data=tcga_metadata_sample, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))

tcga_metadata_sample$sample_type <- factor(tcga_metadata_sample$sample_type)
tcga_metadata_sample$age_grp <- factor(tcga_metadata_sample$age_grp)

chisq.test(tcga_metadata_sample$sample_type, tcga_metadata_sample$age_grp)


######################Kaplan Meier for survival (all patients) according to age median ##################################
#Load relevant packages 
library(survival)
library(survminer)

#use patients data 
Table.1.data.subjects

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- Table.1.data.subjects

#search for columns to keep 
#vital status give you alive or dead 
metadata$vital_status
#days to last follow up give follow up for alive only 
metadata$days_to_last_follow_up
#for dead, calculate time to death from diagnosis 
metadata$time_to_death <- (metadata$year_of_death - metadata$year_of_diagnosis) * 365

#create a new column that include both 
metadata$time_to_death_or_last_FU <- ifelse(metadata$vital_status == "Alive", metadata$days_to_last_follow_up, metadata$time_to_death)

###plot for survival 
#Column to be used as time (in days) - days_to_last_follow_up 
# column to be used as status is time_to_death_or_last_FU
survival.data <- metadata[, c("time_to_death_or_last_FU","vital_status", "age_grp" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

survival.data$status <- ifelse(survival.data$status=="Alive", 1, 0)

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- as.factor(survival.data$Age)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Old", "Young"), legend.title="Age",  
                            palette=c("blue3", "green4"), size=1,
                            title="Kaplan-Meier Curve for Survival According to Age",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot 
pdf(file = "TCGA_all_patients_survival.pdf", width = 8, height = 8)
survival.plot
dev.off()


######### Kaplan Meier recurrence curve according to age median, all patients ############


#use patients data 
Table.1.data.subjects

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- Table.1.data.subjects

#search for columns to keep 
#DFS status give recurrence or progression status 
metadata$DFS_STATUS
#DFS_MONTHS give time to recurrenc ein months, should convert this to days 
metadata$DFS_MONTHS
metadata$DFS_days <-  as.numeric(metadata$DFS_MONTHS) * 30.4167

###plot for recurrence 
#Column to be used as time (in days) - DFS_days 
# column to be used as status is DFS_STATUS
survival.data <- metadata[, c("DFS_days","DFS_STATUS", "age_grp" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

survival.data$status <- ifelse(survival.data$status=="Recurrence", 1, 0)

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- as.factor(survival.data$Age)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Old", "Young"), legend.title="Age",  
                            palette=c("blue3", "green4"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to Age",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot (export as PNG)




############ Early Lung cancer analysis according to median age ###############

########include stage I and II only ############

#get clinical metadata of early stage (overall n=464)
tcga_metadata$ajcc_pathologic_stage <- gsub(" ", "_", tcga_metadata$ajcc_pathologic_stage)
tcga_metadata$ajcc_pathologic_stage <- factor(tcga_metadata$ajcc_pathologic_stage)

tcga_metadata_early_stage <- tcga_metadata %>% 
  dplyr::filter(ajcc_pathologic_stage %in% c("Stage_I", "Stage_IA", "Stage_IB", "Stage_II", "Stage_IIA", "Stage_IIB"))


#get the cont table accordingly 
tcga_counts_early_stage <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_early_stage))

ncol(tcga_counts_early_stage) == nrow(tcga_metadata_early_stage)

############## Create summarized experiment object #########################

#Convert Model Variable into Factor
tcga_metadata_early_stage$age_grp <- factor(tcga_metadata_early_stage$age_grp)
tcga_metadata_early_stage$DFS_STATUS <- factor(tcga_metadata_early_stage$DFS_STATUS)


#remove any missing data without age or recurrence information (overall 423 for analysis)
tcga_metadata_early_stage_no_NA <- tcga_metadata_early_stage %>% 
  dplyr::filter(age_grp != "NA") %>% 
  dplyr::filter(DFS_STATUS != "NA")


#now select the final counts table 
tcga_counts_early_stage_no_NA <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_early_stage_no_NA))


#Deseq 
#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(tcga_counts_early_stage_no_NA, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(tcga_counts_early_stage_no_NA))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = tcga_metadata_early_stage_no_NA, design = ~ age_grp + DFS_STATUS)

#Normalization Step 
dds <- estimateSizeFactors(dds)

#Retrive normalized counts matrix 
normalized_counts <- counts(dds, normalized=TRUE)
#save it 
write.table(normalized_counts, file="Results/RNA/normalized_counts_tcga_early_stage_median_age.txt", sep="\t", quote=F, col.names=NA)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#Drop Levels
dds$age_grp   <- droplevels(dds$age_grp)
vsd$age_grp   <- droplevels(vsd$age_grp)

dds$DFS_STATUS   <- droplevels(dds$DFS_STATUS)
vsd$DFS_STATUS   <- droplevels(vsd$DFS_STATUS)

#subset tumor and lung objects 
dds_tumor <- dds[,dds$sample_type=="Primary Tumor"]
dds_lung <- dds[, dds$sample_type=="Solid Tissue Normal"]

vsd_tumor <- vsd[,vsd$sample_type=="Primary Tumor"]
vsd_lung <- vsd[, vsd$sample_type=="Solid Tissue Normal"]



######### Table 1 of early lung cancer by median age #######


#get tabel 1 information 

Table.1.data <- tcga_metadata_early_stage_no_NA

#filter for number of subjects only (363 patients)
Table.1.data.subjects <- Table.1.data %>% 
  distinct(patient,.keep_all = TRUE)

#calculate median age = 66 
median(Table.1.data.subjects$age_at_index, na.rm = TRUE)

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever) +factor(dead_or_not_five_years)+factor(DFS_STATUS)
       # set the variable you want to stratify by 
       | age_grp, 
       #set data 
       data=Table.1.data.subjects, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))

#now add stats (same as above except where notes added )
table1(~ factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever)+factor(dead_or_not_five_years)+factor(DFS_STATUS)
       | age_grp, data=Table.1.data.subjects, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))



################ Kaplan Meier for Recurrence early stage, by median age ########


#use patients data 
Table.1.data.subjects

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- Table.1.data.subjects

#search for columns to keep 
#DFS status give recurrence or progression status 
metadata$DFS_STATUS
#DFS_MONTHS give time to recurrenc ein months, should convert this to days 
metadata$DFS_MONTHS
metadata$DFS_days <-  as.numeric(metadata$DFS_MONTHS) * 30.4167

###plot for recurrence 
#Column to be used as time (in days) - DFS_days 
# column to be used as status is DFS_STATUS
survival.data <- metadata[, c("DFS_days","DFS_STATUS", "age_grp" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

survival.data$status <- ifelse(survival.data$status=="Recurrence", 1, 0)

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- as.factor(survival.data$Age)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Old", "Young"), legend.title="Age",  
                            palette=c("blue3", "green4"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to Age",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot (export as PNG)





#################### Tumor Subset Analysis  #run old vs young ##############

dds.analysis <- dds_tumor
vsd.analysis <- vsd_tumor

#define variables 
dds.analysis$age_grp
v= "age_grp"
tissue <- "tumor"
stage <- "early_stage_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_grp

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


####################### Repeat for Lung old vs young, early stage, by median age ####


dds.analysis <- dds_lung
vsd.analysis <- vsd_lung

#define variables 
dds.analysis$age_grp
v= "age_grp"
tissue <- "lung"
stage <- "early_stage_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_grp

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


################ Early stage Tumor tissue, comparing recurrence in age groups (according to median)#####

### subset for old and young tables 
dds_old <- dds[,dds$age_grp=="old"]
dds_young <- dds[,dds$age_grp=="young"]

vsd_old <- vsd[,vsd$age_grp=="old"]
vsd_young <- vsd[,vsd$age_grp=="young"]


####################################### Old subset#### 
#old tumor comparing recu to no rec 
dds.analysis <- dds_old[,dds_old$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Primary solid Tumor"]

#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "tumor"
stage <- "early_stage_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "red2"

#no rec
col2 <- "orange2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_median_age.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Primary solid Tumor"]



#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "tumor"
stage <- "early_stage_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "blue2"

#no rec
col2 <- "skyblue2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_median_age.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



################ Early stage Lung tissue, comparing recurrence in age groups (according to median)#####


####################################### Old subset#### 
#old tumor comparing recu to no rec 
dds.analysis <- dds_old[,dds_old$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Solid Tissue Normal"]

#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "Lung"
stage <- "early_stage_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "darkred"

#no rec
col2 <- "orangered"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_median_age.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Solid Tissue Normal"]



#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "Lung"
stage <- "early_stage_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "darkblue"

#no rec
col2 <- "skyblue"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.25
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_median_age.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


########### IPA TCGA early stage, tumor only, median age####
#read IPA results 
IPA_res <- read.csv(file = "IPA/TCGA/IPA_early_stage_TCGA_tumor_old_vs_young_median_age.csv")


#get max and min values 
max(IPA_res$tumor_old, na.rm = TRUE)
max(IPA_res$tumor_young, na.rm = TRUE)
min(IPA_res$tumor_old, na.rm = TRUE)
min(IPA_res$tumor_young, na.rm = TRUE)


 
#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.673, 0, 3.742), c("blue", "white", "orange"))
col_fun(seq(-2.673, 0, 3.742))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_early_stage_TCGA_tumor_old_vs_young_median_age.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()























############ Early Lung cancer analysis according to age extremes ###############

########include stage I and II only ############

#get clinical metadata of early stage (overall n=464)
tcga_metadata$ajcc_pathologic_stage <- gsub(" ", "_", tcga_metadata$ajcc_pathologic_stage)
tcga_metadata$ajcc_pathologic_stage <- factor(tcga_metadata$ajcc_pathologic_stage)

tcga_metadata_early_stage <- tcga_metadata %>% 
  dplyr::filter(ajcc_pathologic_stage %in% c("Stage_I", "Stage_IA", "Stage_IB", "Stage_II", "Stage_IIA", "Stage_IIB"))


#get the cont table accordingly 
tcga_counts_early_stage <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_early_stage))

ncol(tcga_counts_early_stage) == nrow(tcga_metadata_early_stage)

############## Create summarized experiment object #########################

#Convert Model Variable into Factor
tcga_metadata_early_stage$age_3_grps <- factor(tcga_metadata_early_stage$age_3_grps)
tcga_metadata_early_stage$DFS_STATUS <- factor(tcga_metadata_early_stage$DFS_STATUS)


#remove any missing data without age or recurrence information (overall 318 for analysis)
tcga_metadata_early_stage_age_extremes_no_NA <- tcga_metadata_early_stage %>% 
  dplyr::filter(age_3_grps != "NA") %>%
  dplyr::filter(age_3_grps != "middle") %>%
  dplyr::filter(DFS_STATUS != "NA")


#now select the final counts table 
tcga_counts_early_stage_no_NA <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_early_stage_age_extremes_no_NA))

ncol(tcga_counts_early_stage_no_NA) == nrow(tcga_metadata_early_stage_age_extremes_no_NA)


#Deseq 
#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(tcga_counts_early_stage_no_NA, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(tcga_counts_early_stage_no_NA))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = tcga_metadata_early_stage_age_extremes_no_NA, design = ~ age_grp + DFS_STATUS)

#Normalization Step 
dds <- estimateSizeFactors(dds)

#Retrive normalized counts matrix 
normalized_counts <- counts(dds, normalized=TRUE)
#save it 
write.table(normalized_counts, file="Results/RNA/normalized_counts_tcga_early_stage_age_extremes.txt", sep="\t", quote=F, col.names=NA)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#Drop Levels
dds$age_3_grps   <- droplevels(dds$age_3_grps)
vsd$age_3_grps   <- droplevels(vsd$age_3_grps)

dds$DFS_STATUS   <- droplevels(dds$DFS_STATUS)
vsd$DFS_STATUS   <- droplevels(vsd$DFS_STATUS)

#subset tumor and lung objects 
dds_tumor <- dds[,dds$sample_type=="Primary Tumor"]
dds_lung <- dds[, dds$sample_type=="Solid Tissue Normal"]

vsd_tumor <- vsd[,vsd$sample_type=="Primary Tumor"]
vsd_lung <- vsd[, vsd$sample_type=="Solid Tissue Normal"]



######### Table 1 of early lung cancer by age extremes #######


#get tabel 1 information 

Table.1.data <- tcga_metadata_early_stage_age_extremes_no_NA

#filter for number of subjects only (363 patients)
Table.1.data.subjects <- Table.1.data %>% 
  distinct(patient,.keep_all = TRUE)

#calculate median age = 66 
median(Table.1.data.subjects$age_at_index, na.rm = TRUE)

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever) +factor(dead_or_not_five_years)+factor(DFS_STATUS)
       # set the variable you want to stratify by 
       | age_3_grps, 
       #set data 
       data=Table.1.data.subjects, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))

#now add stats (same as above except where notes added )
table1(~ factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever)+factor(dead_or_not_five_years)+factor(DFS_STATUS)
       | age_3_grps, data=Table.1.data.subjects, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))



################ Kaplan Meier for Recurrence early stage, by age extremes  ########


#use patients data 
Table.1.data.subjects

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- Table.1.data.subjects

#search for columns to keep 
#DFS status give recurrence or progression status 
metadata$DFS_STATUS
#DFS_MONTHS give time to recurrenc ein months, should convert this to days 
metadata$DFS_MONTHS
metadata$DFS_days <-  as.numeric(metadata$DFS_MONTHS) * 30.4167

###plot for recurrence 
#Column to be used as time (in days) - DFS_days 
# column to be used as status is DFS_STATUS
survival.data <- metadata[, c("DFS_days","DFS_STATUS", "age_3_grps" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

survival.data$status <- ifelse(survival.data$status=="Recurrence", 1, 0)

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- as.factor(survival.data$Age)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Old", "Young"), legend.title="Age",  
                            palette=c("blue3", "green4"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to Age",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot (export as PNG)





#################### Tumor Subset Analysis  #run old vs young ##############

dds.analysis <- dds_tumor
vsd.analysis <- vsd_tumor

#define variables 
dds.analysis$age_3_grps
v= "age_3_grps"
tissue <- "tumor"
stage <- "early_stage_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_3_grps

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


 ####################### Repeat for Lung old vs young, early stage, by age extremes ####


dds.analysis <- dds_lung
vsd.analysis <- vsd_lung

#define variables 
dds.analysis$age_3_grps
v= "age_3_grps"
tissue <- "lung"
stage <- "early_stage_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_3_grps

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


################ Early stage Tumor tissue, comparing recurrence in age groups (according to age extremes)#####

### subset for old and young tables 
dds_old <- dds[,dds$age_3_grps=="old"]
dds_young <- dds[,dds$age_3_grps=="young"]

vsd_old <- vsd[,vsd$age_3_grps=="old"]
vsd_young <- vsd[,vsd$age_3_grps=="young"]


####################################### Old subset#### 
#old tumor comparing recu to no rec 
dds.analysis <- dds_old[,dds_old$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Primary solid Tumor"]

#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "tumor"
stage <- "early_stage_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "red2"

#no rec
col2 <- "orange2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_3_grps_.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Primary solid Tumor"]



#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "tumor"
stage <- "early_stage_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "blue2"

#no rec
col2 <- "skyblue2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_3_grps.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



################ Early stage Lung tissue, comparing recurrence in age groups (according to age extremes)#####


####################################### Old subset#### 
#old tumor comparing recu to no rec 
dds.analysis <- dds_old[,dds_old$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Solid Tissue Normal"]

#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "Lung"
stage <- "early_stage_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "darkred"

#no rec
col2 <- "orangered"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_3_grps.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Solid Tissue Normal"]



#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "Lung"
stage <- "early_stage_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "darkblue"

#no rec
col2 <- "skyblue"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.25
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_3_grps.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


########### IPA TCGA early stage, tumor only, age extremes####
#read IPA results 
IPA_res <- read.csv(file = "IPA/TCGA/IPA_early_stage_TCGA_tumor_old_vs_young_age_extremes.csv")


#get max and min values 
max(IPA_res$tumor_old, na.rm = TRUE)
max(IPA_res$tumor_young, na.rm = TRUE)
min(IPA_res$tumor_old, na.rm = TRUE)
min(IPA_res$tumor_young, na.rm = TRUE)



#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-3.051, 0, 3.302), c("blue", "white", "orange"))
col_fun(seq(-3.051, 0, 3.302))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_early_stage_TCGA_tumor_old_vs_young_age_extremes.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()














################################################################################
################ Advanced stage analysis by age median ########################


########include Stage_IIIA Stage_IIIB Stage_IV ############

#get clinical metadata of advanced stage (overall n=125)
tcga_metadata_advanced_stage <- tcga_metadata %>% 
  dplyr::filter(ajcc_pathologic_stage %in% c("Stage_IIIA", "Stage_IIIB", "Stage_IV"))

#creae avariable of survival after 2 years 
tcga_metadata_advanced_stage$days_to_death
tcga_metadata_advanced_stage$vital_status

tcga_metadata_advanced_stage$two_y_surv <- ifelse(tcga_metadata_advanced_stage$days_to_death < 730, "less_24", "greater_24")
tcga_metadata_advanced_stage$two_y_surv[is.na(tcga_metadata_advanced_stage$two_y_surv)] <- "greater_24"

#make it a factor 
tcga_metadata_advanced_stage$two_y_surv <- factor(tcga_metadata_advanced_stage$two_y_surv)

#calculate median age
median(tcga_metadata_advanced_stage$age_at_index, na.rm = TRUE)

#assign new age_grp according to this 
tcga_metadata_advanced_stage$age_grp <- ifelse(tcga_metadata_advanced_stage$age_at_index < 67, "young", "old")

#get the cont table accordingly 
tcga_counts_advanced_stage <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_advanced_stage))

ncol(tcga_counts_advanced_stage) == nrow(tcga_metadata_advanced_stage)

############## Create summarized experiment object #########################

#Convert Model Variable into Factor
tcga_metadata_advanced_stage$age_grp <- factor(tcga_metadata_advanced_stage$age_grp)
tcga_metadata_advanced_stage$two_y_surv <- factor(tcga_metadata_advanced_stage$two_y_surv)


#remove any missing data without age or recurrence information (overall 91 for analysis)
tcga_metadata_advanced_stage_no_NA <- tcga_metadata_advanced_stage %>% 
  dplyr::filter(age_grp != "NA") %>% 
  dplyr::filter(two_y_surv != "NA")


#now select the final counts table 
tcga_counts_advanced_stage_no_NA <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_advanced_stage_no_NA))


#Deseq 
#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(tcga_counts_advanced_stage_no_NA, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(tcga_counts_advanced_stage_no_NA))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = tcga_metadata_advanced_stage_no_NA, design = ~ age_grp + two_y_surv)

#Normalization Step 
dds <- estimateSizeFactors(dds)

#Retrive normalized counts matrix 
normalized_counts <- counts(dds, normalized=TRUE)
#save it 
write.table(normalized_counts, file="Results/RNA/normalized_counts_tcga_advanced_stage_median_age.txt", sep="\t", quote=F, col.names=NA)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#Drop Levels
dds$age_grp   <- droplevels(dds$age_grp)
vsd$age_grp   <- droplevels(vsd$age_grp)

dds$two_y_surv   <- droplevels(dds$two_y_surv)
vsd$two_y_surv   <- droplevels(vsd$two_y_surv)

#subset tumor and lung objects 
dds_tumor <- dds[,dds$sample_type=="Primary Tumor"]
dds_lung <- dds[, dds$sample_type=="Solid Tissue Normal"]

vsd_tumor <- vsd[,vsd$sample_type=="Primary Tumor"]
vsd_lung <- vsd[, vsd$sample_type=="Solid Tissue Normal"]



######### Table 1 of advanced lung cancer by median age #######


#get tabel 1 information 

Table.1.data <- tcga_metadata_advanced_stage_no_NA

#filter for number of subjects only (106 patients)
Table.1.data.subjects <- Table.1.data %>% 
  distinct(patient,.keep_all = TRUE)

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever) +factor(dead_or_not_five_years)
       # set the variable you want to stratify by 
       | age_grp, 
       #set data 
       data=Table.1.data.subjects, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))

#now add stats (same as above except where notes added )
table1(~ factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever)+factor(dead_or_not_five_years)
       | age_grp, data=Table.1.data.subjects, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))



################ Kaplan Meier for survival advanced stage, by median age ########


#use patients data 
Table.1.data.subjects

#We need data from our metadata that include time to death, status of death, mortality
metadata <- Table.1.data.subjects

#search for columns to keep 
#vital_status give death status 
metadata$vital_status

#calculate time to death or last follow up 
metadata$time_of_survival <- ifelse(metadata$vital_status =="Dead", metadata$days_to_death, metadata$days_to_last_follow_up)

###plot for survival
#Column to be used as time (in days) - time_of_survival 
# column to be used as status is vital_status
survival.data <- metadata[, c("time_of_survival","vital_status", "age_grp" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

survival.data$status <- ifelse(survival.data$status=="Dead", 1, 0)

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- as.factor(survival.data$Age)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Old", "Young"), legend.title="Age",  
                            palette=c("blue3", "green4"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to Age",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot (export as PNG)





#################### Tumor Subset Analysis  #run old vs young ##############

dds.analysis <- dds_tumor
vsd.analysis <- vsd_tumor

#define variables 
dds.analysis$age_grp
v= "age_grp"
tissue <- "tumor"
stage <- "advanced_stage_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_grp

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


####################### Repeat for Lung old vs young, advanced stage, by median age ####


dds.analysis <- dds_lung
vsd.analysis <- vsd_lung

#define variables 
dds.analysis$age_grp
v= "age_grp"
tissue <- "lung"
stage <- "advanced_stage_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_grp

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


################ advanced stage Tumor tissue, comparing 2 years sruvival in age groups (according to median)#####

### subset for old and young tables 
dds_old <- dds[,dds$age_grp=="old"]
dds_young <- dds[,dds$age_grp=="young"]

vsd_old <- vsd[,vsd$age_grp=="old"]
vsd_young <- vsd[,vsd$age_grp=="young"]


####################################### Old subset#### 
#old tumor comparing survival
dds.analysis <- dds_old[,dds_old$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Primary solid Tumor"]

#change design 
design(dds.analysis) <- ~ two_y_surv

#define variables 
dds.analysis$two_y_surv
v= "two_y_surv"
tissue <- "tumor"
stage <- "advanced_stage_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "greater_24")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "greater_24")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# < 24 
col1 <- "red3"

# > 24
col2 <- "gold3"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$two_y_surv

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("> 2 Years", "< 2 Years"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_median_age.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Primary solid Tumor"]



#change design 
design(dds.analysis) <- ~ two_y_surv

#define variables 
dds.analysis$two_y_surv
v= "two_y_surv"
tissue <- "tumor"
stage <- "advanced_stage_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "greater_24")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "greater_24")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "blue4"

#no rec
col2 <- "skyblue4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$two_y_surv

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("> 2 Years", "< 2 Years"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_median_age.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



################ advanced stage Lung tissue, comparing survival in age groups (according to median)#####


####################################### Old subset#### 
#old tumor comparing recu to no rec 
dds.analysis <- dds_old[,dds_old$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Solid Tissue Normal"]

#change design 
design(dds.analysis) <- ~ two_y_surv

#define variables 
dds.analysis$two_y_surv
v= "two_y_surv"
tissue <- "Lung"
stage <- "advanced_stage_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "greater_24")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "greater_24")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "purple3"

#no rec
col2 <- "orangered2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =8)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$two_y_surv

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("> 2 Years", "< 2 Years"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_median_age.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Solid Tissue Normal"]



#change design 
design(dds.analysis) <- ~ two_y_surv

#define variables 
dds.analysis$two_y_surv
v= "two_y_surv"
tissue <- "Lung"
stage <- "advanced_stage_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "greater_24")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "greater_24")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "cyan4"

#no rec
col2 <- "cyan3"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =5)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$two_y_surv

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("> 2 Years", "< 2 Years"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.25
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_median_age.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


########### IPA TCGA advanced stage, tumor only, median age####















############## Advanced stage TCGA by age extremes #################




########include Stage_IIIA Stage_IIIB Stage_IV ############

#get clinical metadata of advanced stage (overall n=125)
tcga_metadata_advanced_stage <- tcga_metadata %>% 
  dplyr::filter(ajcc_pathologic_stage %in% c("Stage_IIIA", "Stage_IIIB", "Stage_IV"))

#creae avariable of survival after 2 years 
tcga_metadata_advanced_stage$days_to_death
tcga_metadata_advanced_stage$vital_status

tcga_metadata_advanced_stage$two_y_surv <- ifelse(tcga_metadata_advanced_stage$days_to_death < 730, "less_24", "greater_24")
tcga_metadata_advanced_stage$two_y_surv[is.na(tcga_metadata_advanced_stage$two_y_surv)] <- "greater_24"

#make it a factor 
tcga_metadata_advanced_stage$two_y_surv <- factor(tcga_metadata_advanced_stage$two_y_surv)

#get the cont table accordingly 
tcga_counts_advanced_stage <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_advanced_stage))

ncol(tcga_counts_advanced_stage) == nrow(tcga_metadata_advanced_stage)

############## Create summarized experiment object #########################

#Convert Model Variable into Factor
tcga_metadata_advanced_stage$age_3_grps <- factor(tcga_metadata_advanced_stage$age_3_grps)
tcga_metadata_advanced_stage$two_y_surv <- factor(tcga_metadata_advanced_stage$two_y_surv)


#remove any missing data without age or recurrence information (overall 121 for analysis)
tcga_metadata_advanced_stage_no_NA <- tcga_metadata_advanced_stage %>% 
  dplyr::filter(age_3_grps != "NA") %>% 
  dplyr::filter(age_3_grps != "middle") %>% 
  dplyr::filter(two_y_surv != "NA")


#now select the final counts table 
tcga_counts_advanced_stage_no_NA <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_advanced_stage_no_NA))


#Deseq 
#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(tcga_counts_advanced_stage_no_NA, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(tcga_counts_advanced_stage_no_NA))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = tcga_metadata_advanced_stage_no_NA, design = ~ age_3_grps + two_y_surv)

#Normalization Step 
dds <- estimateSizeFactors(dds)

#Retrive normalized counts matrix 
normalized_counts <- counts(dds, normalized=TRUE)
#save it 
write.table(normalized_counts, file="Results/RNA/normalized_counts_tcga_advanced_stage_age_extremes.txt", sep="\t", quote=F, col.names=NA)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#Drop Levels
dds$age_3_grps   <- droplevels(dds$age_3_grps)
vsd$age_3_grps   <- droplevels(vsd$age_3_grps)

dds$two_y_surv   <- droplevels(dds$two_y_surv)
vsd$two_y_surv   <- droplevels(vsd$two_y_surv)

#subset tumor and lung objects 
dds_tumor <- dds[,dds$sample_type=="Primary Tumor"]
dds_lung <- dds[, dds$sample_type=="Solid Tissue Normal"]

vsd_tumor <- vsd[,vsd$sample_type=="Primary Tumor"]
vsd_lung <- vsd[, vsd$sample_type=="Solid Tissue Normal"]



######### Table 1 of advanced lung cancer by age extre,es  #######


#get tabel 1 information 

Table.1.data <- tcga_metadata_advanced_stage_no_NA

#filter for number of subjects only (106 patients)
Table.1.data.subjects <- Table.1.data %>% 
  distinct(patient,.keep_all = TRUE)

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever) +factor(dead_or_not_five_years)
       # set the variable you want to stratify by 
       | age_3_grps, 
       #set data 
       data=Table.1.data.subjects, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))

#now add stats (same as above except where notes added )
table1(~ factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever)+factor(dead_or_not_five_years)
       | age_3_grps, data=Table.1.data.subjects, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))

#numerical 
t.test(Table.1.data$age_at_index ~ Table.1.data$age_3_grps) #value < 2.2e-16
t.test(Table.1.data$pack_years_smoked ~ Table.1.data$age_3_grps) #value 0.372
t.test(Table.1.data$days_to_death ~ Table.1.data$age_3_grps) #value 0.973

################ Kaplan Meier for survival advanced stage, by median age ########


#use patients data 
Table.1.data.subjects

#We need data from our metadata that include time to death, status of death, mortality
metadata <- Table.1.data.subjects

#search for columns to keep 
#vital_status give death status 
metadata$vital_status

#calculate time to death or last follow up 
metadata$time_of_survival <- ifelse(metadata$vital_status =="Dead", metadata$days_to_death, metadata$days_to_last_follow_up)

###plot for survival
#Column to be used as time (in days) - time_of_survival 
# column to be used as status is vital_status
survival.data <- metadata[, c("time_of_survival","vital_status", "age_3_grps" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

survival.data$status <- ifelse(survival.data$status=="Dead", 1, 0)

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- as.factor(survival.data$Age)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Old", "Young"), legend.title="Age",  
                            palette=c("blue3", "green4"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to Age",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot (export as PNG)





#################### Tumor Subset Analysis  #run old vs young ##############

dds.analysis <- dds_tumor
vsd.analysis <- vsd_tumor

#define variables 
dds.analysis$age_3_grps
v= "age_3_grps"
tissue <- "tumor"
stage <- "advanced_stage_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_3_grps

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


####################### Repeat for Lung old vs young, advanced stage, by median age ####


dds.analysis <- dds_lung
vsd.analysis <- vsd_lung

#define variables 
dds.analysis$age_3_grps
v= "age_3_grps"
tissue <- "lung"
stage <- "advanced_stage_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_3_grps

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


################ advanced stage Tumor tissue, comparing 2 years sruvival in age groups (according to median)#####

### subset for old and young tables 
dds_old <- dds[,dds$age_3_grps=="old"]
dds_young <- dds[,dds$age_3_grps=="young"]

vsd_old <- vsd[,vsd$age_3_grps=="old"]
vsd_young <- vsd[,vsd$age_3_grps=="young"]


####################################### Old subset#### 
#old tumor comparing survival
dds.analysis <- dds_old[,dds_old$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Primary solid Tumor"]

#change design 
design(dds.analysis) <- ~ two_y_surv

#define variables 
dds.analysis$two_y_surv
v= "two_y_surv"
tissue <- "tumor"
stage <- "advanced_stage_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "greater_24")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "greater_24")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# < 24 
col1 <- "red3"

# > 24
col2 <- "gold3"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$two_y_surv

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_extremes.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_extremes.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("> 2 Years", "< 2 Years"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_extremes.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_extremes.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Primary solid Tumor"]



#change design 
design(dds.analysis) <- ~ two_y_surv

#define variables 
dds.analysis$two_y_surv
v= "two_y_surv"
tissue <- "tumor"
stage <- "advanced_stage_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "greater_24")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "greater_24")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "blue4"

#no rec
col2 <- "skyblue4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$two_y_surv

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_extremes.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_extremes.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("> 2 Years", "< 2 Years"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_extremes.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_extremes.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



################ advanced stage Lung tissue, comparing survival in age groups (according to median)#####


####################################### Old subset#### 
#old tumor comparing recu to no rec 
dds.analysis <- dds_old[,dds_old$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Solid Tissue Normal"]

#change design 
design(dds.analysis) <- ~ two_y_surv

#define variables 
dds.analysis$two_y_surv
v= "two_y_surv"
tissue <- "Lung"
stage <- "advanced_stage_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "greater_24")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "greater_24")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "purple3"

#no rec
col2 <- "orangered2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =4)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$two_y_surv

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_extremes.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_extremes.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("> 2 Years", "< 2 Years"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_extremes.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_extremes.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Solid Tissue Normal"]



#change design 
design(dds.analysis) <- ~ two_y_surv

#define variables 
dds.analysis$two_y_surv
v= "two_y_surv"
tissue <- "Lung"
stage <- "advanced_stage_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "greater_24")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "greater_24")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "cyan4"

#no rec
col2 <- "cyan3"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =5)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$two_y_surv

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_extremes.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_extremes.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("> 2 Years", "< 2 Years"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_extremes.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.25
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_extremes.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



###############################################################################
############# IPA advanced stage age extremes ############
#read IPA results 
IPA_res <- read.csv(file = "IPA/TCGA/IPA_TCGA_advanced_stage_age_extremes.csv")

max(IPA_res$Tumor_old, na.rm = TRUE)
min(IPA_res$Tumor_old, na.rm = TRUE)
max(IPA_res$Tumor_young, na.rm = TRUE)
min(IPA_res$Tumor_young, na.rm = TRUE)
max(IPA_res$Lung_old, na.rm = TRUE)
min(IPA_res$Lung_old, na.rm = TRUE)
max(IPA_res$Lung_young, na.rm = TRUE)
min(IPA_res$Lung_young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-3.71, 0, 2.309), c("blue", "white", "orange"))
col_fun(seq(-3.71, 0, 2.309))

#convert data to matrix 
IPA_res_mat <- IPA_res

#arrange by lung old 
IPA_res_mat <- IPA_res_mat %>% 
  dplyr::arrange(desc(Lung_old))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_heatmap_advanced_Stage_age_extremes.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()


#tumor subset only 
IPA_res <- read.csv(file = "IPA/TCGA/IPA_TCGA_advanced_stage_age_extremes.csv")

IPA_res <- IPA_res %>% dplyr::select(Pathway, starts_with("Tumor"))

max(IPA_res$Tumor_old, na.rm = TRUE)
min(IPA_res$Tumor_old, na.rm = TRUE)
max(IPA_res$Tumor_young, na.rm = TRUE)
min(IPA_res$Tumor_young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.646, 0, 2.268), c("blue", "white", "orange"))
col_fun(seq(-2.646, 0, 2.268))

#convert data to matrix 
IPA_res_mat <- IPA_res

#arrange by lung old 
IPA_res_mat <- IPA_res_mat %>% 
  dplyr::arrange(desc(Tumor_old))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_heatmap_advanced_Stage_age_extremes_tumor.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()



#Lung subset only 
IPA_res <- read.csv(file = "IPA/TCGA/IPA_TCGA_advanced_stage_age_extremes.csv")

IPA_res <- IPA_res %>% dplyr::select(Pathway, starts_with("Lung"))

max(IPA_res$Lung_old, na.rm = TRUE)
min(IPA_res$Lung_old, na.rm = TRUE)
max(IPA_res$Lung_young, na.rm = TRUE)
min(IPA_res$Lung_young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-3.71, 0, 2.309), c("blue", "white", "orange"))
col_fun(seq(-3.71, 0, 2.309))

#convert data to matrix 
IPA_res_mat <- IPA_res

#arrange by lung old 
IPA_res_mat <- IPA_res_mat %>% 
  dplyr::arrange(desc(Lung_old))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_heatmap_advanced_Stage_age_extremes_lung.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()














################################################################################
###################### TCGA Stage I only #########################

#get clinical metadata of stage I
tcga_metadata_stage_I <- tcga_metadata %>% 
  dplyr::filter(ajcc_pathologic_stage %in% c("Stage_I", "Stage_IA", "Stage_IB"))


#get the cont table accordingly 
tcga_counts_stage_I <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_stage_I))

ncol(tcga_counts_stage_I) == nrow(tcga_metadata_stage_I)

############## Create summarized experiment object #########################

#Convert Model Variable into Factor
tcga_metadata_stage_I$age_3_grps <- factor(tcga_metadata_stage_I$age_3_grps)
tcga_metadata_stage_I$DFS_STATUS <- factor(tcga_metadata_stage_I$DFS_STATUS)


#remove any missing data without age or recurrence information (overall 224 for analysis)
tcga_metadata_stage_I_age_extremes_no_NA <- tcga_metadata_stage_I %>% 
  dplyr::filter(age_3_grps != "NA") %>%
  dplyr::filter(age_3_grps != "middle") %>%
  dplyr::filter(DFS_STATUS != "NA")


#now select the final counts table 
tcga_counts_stage_I_no_NA <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_stage_I_age_extremes_no_NA))

ncol(tcga_counts_stage_I_no_NA) == nrow(tcga_metadata_stage_I_age_extremes_no_NA)


#Deseq 
#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(tcga_counts_stage_I_no_NA, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(tcga_counts_stage_I_no_NA))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = tcga_metadata_stage_I_age_extremes_no_NA, design = ~ age_grp + DFS_STATUS)

#Normalization Step 
dds <- estimateSizeFactors(dds)

#Retrive normalized counts matrix 
normalized_counts <- counts(dds, normalized=TRUE)
#save it 
write.table(normalized_counts, file="Results/RNA/normalized_counts_tcga_stage_I_age_extremes.txt", sep="\t", quote=F, col.names=NA)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#Drop Levels
dds$age_3_grps   <- droplevels(dds$age_3_grps)
vsd$age_3_grps   <- droplevels(vsd$age_3_grps)

dds$DFS_STATUS   <- droplevels(dds$DFS_STATUS)
vsd$DFS_STATUS   <- droplevels(vsd$DFS_STATUS)

#subset tumor and lung objects 
dds_tumor <- dds[,dds$sample_type=="Primary Tumor"]
dds_lung <- dds[, dds$sample_type=="Solid Tissue Normal"]

vsd_tumor <- vsd[,vsd$sample_type=="Primary Tumor"]
vsd_lung <- vsd[, vsd$sample_type=="Solid Tissue Normal"]



######### Table 1 of stage I cancer by age extremes #######


#get tabel 1 information 

Table.1.data <- tcga_metadata_stage_I_age_extremes_no_NA

#filter for number of subjects only (363 patients)
Table.1.data.subjects <- Table.1.data %>% 
  distinct(patient,.keep_all = TRUE)

#calculate median age = 66 
median(Table.1.data.subjects$age_at_index, na.rm = TRUE)

library(table1)
#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever) +factor(dead_or_not_five_years)+factor(DFS_STATUS)
       # set the variable you want to stratify by 
       | age_3_grps, 
       #set data 
       data=Table.1.data.subjects, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))

#now add stats (same as above except where notes added )
table1(~ factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever)+factor(dead_or_not_five_years)+factor(DFS_STATUS)
       | age_3_grps, data=Table.1.data.subjects, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))

# p value of numerical variables 
t.test(as.numeric(Table.1.data$pack_years_smoked) ~ Table.1.data$age_3_grps, na.action = na.omit) #p-value = 0.4297
t.test(as.numeric(Table.1.data$age_at_index) ~ Table.1.data$age_3_grps, na.action = na.omit) #p-value = < 0.001
t.test(as.numeric(Table.1.data$days_to_death) ~ Table.1.data$age_3_grps, na.action = na.omit) #p-value = < 0.001

################ Kaplan Meier for Recurrence stage I, by age extremes  ########


#use patients data 
Table.1.data.subjects

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- Table.1.data.subjects

#search for columns to keep 
#DFS status give recurrence or progression status 
metadata$DFS_STATUS
#DFS_MONTHS give time to recurrenc ein months, should convert this to days 
metadata$DFS_MONTHS
metadata$DFS_days <-  as.numeric(metadata$DFS_MONTHS) * 30.4167

###plot for recurrence 
#Column to be used as time (in days) - DFS_days 
# column to be used as status is DFS_STATUS
survival.data <- metadata[, c("DFS_days","DFS_STATUS", "age_3_grps" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

survival.data$status <- ifelse(survival.data$status=="Recurrence", 1, 0)

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- as.factor(survival.data$Age)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Old", "Young"), legend.title="Age",  
                            palette=c("blue3", "green4"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to Age",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot (export as PNG)





#################### Tumor Subset Analysis  #run old vs young ##############

dds.analysis <- dds_tumor
vsd.analysis <- vsd_tumor

#define variables 
dds.analysis$age_3_grps
v= "age_3_grps"
tissue <- "tumor"
stage <- "stage_I_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_3_grps

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


####################### Repeat for Lung old vs young, stage I, by age extremes ####


dds.analysis <- dds_lung
vsd.analysis <- vsd_lung

#define variables 
dds.analysis$age_3_grps
v= "age_3_grps"
tissue <- "lung"
stage <- "stage_I_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_3_grps

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


################ stage I Tumor tissue, comparing recurrence in age groups (according to age extremes)#####

### subset for old and young tables 
dds_old <- dds[,dds$age_3_grps=="old"]
dds_young <- dds[,dds$age_3_grps=="young"]

vsd_old <- vsd[,vsd$age_3_grps=="old"]
vsd_young <- vsd[,vsd$age_3_grps=="young"]


####################################### Old subset#### 
#old tumor comparing recu to no rec 
dds.analysis <- dds_old[,dds_old$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Primary solid Tumor"]

#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "tumor"
stage <- "stage_I_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "red2"

#no rec
col2 <- "orange2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_3_grps_.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Primary solid Tumor"]



#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "tumor"
stage <- "stage_I_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "blue2"

#no rec
col2 <- "skyblue2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_3_grps.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



################  stage I Lung tissue, comparing recurrence in age groups (according to age extremes)#####


####################################### Old subset#### 
#old tumor comparing recu to no rec 
dds.analysis <- dds_old[,dds_old$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Solid Tissue Normal"]

#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "Lung"
stage <- "stage_I_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "darkred"

#no rec
col2 <- "orangered"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =7)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_3_grps.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Solid Tissue Normal"]



#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "Lung"
stage <- "stage_I_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "darkblue"

#no rec
col2 <- "skyblue"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_3_grps.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.25
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_3_grps.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


########### IPA TCGA stage I, , age extremes####
#read IPA results 
IPA_res <- read.csv(file = "IPA/TCGA/IPA_stage_I_TCGA_tumor_old_vs_young_age_extremes.csv")


#get max and min values 
max(IPA_res$tumor_old, na.rm = TRUE)
max(IPA_res$tumor_young, na.rm = TRUE)
min(IPA_res$tumor_old, na.rm = TRUE)
min(IPA_res$tumor_young, na.rm = TRUE)
max(IPA_res$lung_old, na.rm = TRUE)
max(IPA_res$lung_young, na.rm = TRUE)
min(IPA_res$lung_old, na.rm = TRUE)
min(IPA_res$lung_young, na.rm = TRUE)



#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.333, 0, 3.656), c("blue", "white", "orange"))
col_fun(seq(-2.333, 0, 3.656))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_stage_I_TCGA_old_vs_young_age_extremes.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()


#split lung and tumor 
IPA_res_lung <- IPA_res %>% dplyr::select(Pathway, starts_with("lung"))
IPA_res_tumor <- IPA_res %>% dplyr::select(Pathway, starts_with("tumor"))


#plot lung subset only, remove pathways with NA values in both young and old for another modified figure 
IPA_res_lung_modified <- IPA_res_lung[! (is.na(IPA_res$lung_old)& is.na(IPA_res$lung_young)),]


#get max and min values 
min(IPA_res_lung$lung_old, na.rm = TRUE)
min(IPA_res_lung$lung_young, na.rm = TRUE)
max(IPA_res_lung$lung_old, na.rm = TRUE)
max(IPA_res_lung$lung_young, na.rm = TRUE)

#arrange by lung old 
IPA_res_lung <- IPA_res_lung %>% dplyr::arrange(desc(lung_old))

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.449, 0, 3.464), c("blue", "white", "orange"))
col_fun(seq(-2.449, 0, 3.464))

#convert data to matrix 
IPA_res_lung_mat <- IPA_res_lung

#set pathways as rownames
rownames(IPA_res_lung_mat) <- IPA_res_lung_mat$Pathway

#get rid of extra columns
IPA_res_lung_mat <- IPA_res_lung_mat[,-1]

#convert to matrix 
IPA_res_lung_mat <- as.matrix(IPA_res_lung_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_stage_I_TCGA_Lung_only_old_vs_young_age_extremes.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_lung_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res_lung$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()


######### plot lung without NA values in both groups 
IPA_res_lung_modified 

#get max and min values 
min(IPA_res_lung_modified$lung_old, na.rm = TRUE)
min(IPA_res_lung_modified$lung_young, na.rm = TRUE)
max(IPA_res_lung_modified$lung_old, na.rm = TRUE)
max(IPA_res_lung_modified$lung_young, na.rm = TRUE)

#arrange by lung old 
IPA_res_lung_modified <- IPA_res_lung_modified %>% dplyr::arrange(desc(lung_old))

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.449, 0, 3.464), c("blue", "white", "orange"))
col_fun(seq(-2.449, 0, 3.464))

#convert data to matrix 
IPA_res_lung_modified_mat <- IPA_res_lung_modified

#set pathways as rownames
rownames(IPA_res_lung_modified_mat) <- IPA_res_lung_modified_mat$Pathway

#get rid of extra columns
IPA_res_lung_modified_mat <- IPA_res_lung_modified_mat[,-1]

#convert to matrix 
IPA_res_lung_modified_mat <- as.matrix(IPA_res_lung_modified_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_stage_I_TCGA_Lung_only_modified_old_vs_young_age_extremes.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_lung_modified_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res_lung_modified$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()



################# Plot tumor only 
IPA_res_tumor

#get max and min values 
min(IPA_res_tumor$tumor_old, na.rm = TRUE)
min(IPA_res_tumor$tumor_young, na.rm = TRUE)
max(IPA_res_tumor$tumor_old, na.rm = TRUE)
max(IPA_res_tumor$tumor_young, na.rm = TRUE)

#arrange by tumor old 
IPA_res_tumor <- IPA_res_tumor %>% dplyr::arrange(desc(tumor_young))

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.333, 0, 3.656), c("blue", "white", "orange"))
col_fun(seq(-2.333, 0, 3.656))

#convert data to matrix 
IPA_res_tumor_mat <- IPA_res_tumor

#set pathways as rownames
rownames(IPA_res_tumor_mat) <- IPA_res_tumor_mat$Pathway

#get rid of extra columns
IPA_res_tumor_mat <- IPA_res_tumor_mat[,-1]

#convert to matrix 
IPA_res_tumor_mat <- as.matrix(IPA_res_tumor_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_stage_I_TCGA_tumor_only_old_vs_young_age_extremes.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_tumor_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res_tumor$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()











##################### TCGA Stage I median Age ##################

tcga_metadata_stage_I$


########include stage I and II only ############

#get clinical metadata of early stage (overall n=464)

tcga_metadata_stage_I <- tcga_metadata %>% 
  dplyr::filter(ajcc_pathologic_stage %in% c("Stage_I", "Stage_IA", "Stage_IB"))


#get the cont table accordingly 
tcga_counts_stage_I <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_stage_I))

ncol(tcga_counts_stage_I) == nrow(tcga_metadata_stage_I)

############## Create summarized experiment object #########################

#Convert Model Variable into Factor
tcga_metadata_stage_I$age_grp <- factor(tcga_metadata_stage_I$age_grp)
tcga_metadata_stage_I$DFS_STATUS <- factor(tcga_metadata_stage_I$DFS_STATUS)


#remove any missing data without age or recurrence information (overall 423 for analysis)
tcga_metadata_stage_I_no_NA <- tcga_metadata_stage_I %>% 
  dplyr::filter(age_grp != "NA") %>% 
  dplyr::filter(DFS_STATUS != "NA")


#now select the final counts table 
tcga_counts_stage_I_no_NA <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_stage_I_no_NA))


#Deseq 
#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(tcga_counts_stage_I_no_NA, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(tcga_counts_stage_I_no_NA))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = tcga_metadata_stage_I_no_NA, design = ~ age_grp + DFS_STATUS)

#Normalization Step 
dds <- estimateSizeFactors(dds)

#Retrive normalized counts matrix 
normalized_counts <- counts(dds, normalized=TRUE)
#save it 
write.table(normalized_counts, file="Results/RNA/normalized_counts_tcga_stage_I_median_age.txt", sep="\t", quote=F, col.names=NA)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#Drop Levels
dds$age_grp   <- droplevels(dds$age_grp)
vsd$age_grp   <- droplevels(vsd$age_grp)

dds$DFS_STATUS   <- droplevels(dds$DFS_STATUS)
vsd$DFS_STATUS   <- droplevels(vsd$DFS_STATUS)

#subset tumor and lung objects 
dds_tumor <- dds[,dds$sample_type=="Primary Tumor"]
dds_lung <- dds[, dds$sample_type=="Solid Tissue Normal"]

vsd_tumor <- vsd[,vsd$sample_type=="Primary Tumor"]
vsd_lung <- vsd[, vsd$sample_type=="Solid Tissue Normal"]



######### Table 1 of early lung cancer by median age #######


#get tabel 1 information 

Table.1.data <- tcga_metadata_stage_I_no_NA

#filter for number of subjects only (363 patients)
Table.1.data.subjects <- Table.1.data %>% 
  distinct(patient,.keep_all = TRUE)

#calculate median age = 66 
median(Table.1.data.subjects$age_at_index, na.rm = TRUE)

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever) +factor(dead_or_not_five_years)+factor(DFS_STATUS)
       # set the variable you want to stratify by 
       | age_grp, 
       #set data 
       data=Table.1.data.subjects, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))

#now add stats (same as above except where notes added )
table1(~ factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever)+factor(dead_or_not_five_years)+factor(DFS_STATUS)
       | age_grp, data=Table.1.data.subjects, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))



################ Kaplan Meier for Recurrence early stage, by median age ########


#use patients data 
Table.1.data.subjects

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- Table.1.data.subjects

#search for columns to keep 
#DFS status give recurrence or progression status 
metadata$DFS_STATUS
#DFS_MONTHS give time to recurrenc ein months, should convert this to days 
metadata$DFS_MONTHS
metadata$DFS_days <-  as.numeric(metadata$DFS_MONTHS) * 30.4167

###plot for recurrence 
#Column to be used as time (in days) - DFS_days 
# column to be used as status is DFS_STATUS
survival.data <- metadata[, c("DFS_days","DFS_STATUS", "age_grp" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

survival.data$status <- ifelse(survival.data$status=="Recurrence", 1, 0)

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- as.factor(survival.data$Age)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Old", "Young"), legend.title="Age",  
                            palette=c("blue3", "green4"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to Age",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot (export as PNG)





#################### Tumor Subset Analysis  #run old vs young ##############

dds.analysis <- dds_tumor
vsd.analysis <- vsd_tumor

#define variables 
dds.analysis$age_grp
v= "age_grp"
tissue <- "tumor"
stage <- "stage_I_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_grp

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


####################### Repeat for Lung old vs young, early stage, by median age ####


dds.analysis <- dds_lung
vsd.analysis <- vsd_lung

#define variables 
dds.analysis$age_grp
v= "age_grp"
tissue <- "lung"
stage <- "stage_I_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_grp

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


################ Early stage Tumor tissue, comparing recurrence in age groups (according to median)#####

### subset for old and young tables 
dds_old <- dds[,dds$age_grp=="old"]
dds_young <- dds[,dds$age_grp=="young"]

vsd_old <- vsd[,vsd$age_grp=="old"]
vsd_young <- vsd[,vsd$age_grp=="young"]


####################################### Old subset#### 
#old tumor comparing recu to no rec 
dds.analysis <- dds_old[,dds_old$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Primary solid Tumor"]

#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "tumor"
stage <- "stage_I_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "red2"

#no rec
col2 <- "orange2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_median_age.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Primary solid Tumor"]



#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "tumor"
stage <- "stage_I_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "blue2"

#no rec
col2 <- "skyblue2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_median_age.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



################ stage I Lung tissue, comparing recurrence in age groups (according to median)#####


####################################### Old subset#### 
#old tumor comparing recu to no rec 
dds.analysis <- dds_old[,dds_old$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Solid Tissue Normal"]

#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "Lung"
stage <- "stage_I_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "darkred"

#no rec
col2 <- "orangered"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_median_age.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Solid Tissue Normal"]



#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "Lung"
stage <- "stage_I_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "darkblue"

#no rec
col2 <- "skyblue"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_median_age.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.25
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_median_age.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()






########### IPA TCGA stage I, , median_age####
#read IPA results 
IPA_res <- read.csv(file = "IPA/TCGA/IPA_stage_I_TCGA_old_vs_young_median_age.csv")


#get max and min values 
max(IPA_res$tumor_old, na.rm = TRUE)
max(IPA_res$tumor_young, na.rm = TRUE)
min(IPA_res$tumor_old, na.rm = TRUE)
min(IPA_res$tumor_young, na.rm = TRUE)
max(IPA_res$lung_old, na.rm = TRUE)
max(IPA_res$lung_young, na.rm = TRUE)
min(IPA_res$lung_old, na.rm = TRUE)
min(IPA_res$lung_young, na.rm = TRUE)



#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-7.543, 0, 3.656), c("blue", "white", "orange"))
col_fun(seq(-7.543, 0, 3.656))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_stage_I_TCGA_old_vs_young_median_age.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()


#split lung and tumor 
IPA_res_lung <- IPA_res %>% dplyr::select(Pathway, starts_with("lung"))
IPA_res_tumor <- IPA_res %>% dplyr::select(Pathway, starts_with("tumor"))


#plot lung subset only, remove pathways with NA values in both young and old for another modified figure 
IPA_res_lung_modified <- IPA_res_lung[! (is.na(IPA_res$lung_old)& is.na(IPA_res$lung_young)),]


#get max and min values 
min(IPA_res_lung$lung_old, na.rm = TRUE)
min(IPA_res_lung$lung_young, na.rm = TRUE)
max(IPA_res_lung$lung_old, na.rm = TRUE)
max(IPA_res_lung$lung_young, na.rm = TRUE)

#arrange by lung old 
IPA_res_lung <- IPA_res_lung %>% dplyr::arrange(desc(lung_old))

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-7.543, 0, 3.051), c("blue", "white", "orange"))
col_fun(seq(-7.543, 0, 3.051))

#convert data to matrix 
IPA_res_lung_mat <- IPA_res_lung

#set pathways as rownames
rownames(IPA_res_lung_mat) <- IPA_res_lung_mat$Pathway

#get rid of extra columns
IPA_res_lung_mat <- IPA_res_lung_mat[,-1]

#convert to matrix 
IPA_res_lung_mat <- as.matrix(IPA_res_lung_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_stage_I_TCGA_Lung_only_old_vs_young_median_age.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_lung_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res_lung$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()


######### plot lung without NA values in both groups 
IPA_res_lung_modified 

#get max and min values 
min(IPA_res_lung_modified$lung_old, na.rm = TRUE)
min(IPA_res_lung_modified$lung_young, na.rm = TRUE)
max(IPA_res_lung_modified$lung_old, na.rm = TRUE)
max(IPA_res_lung_modified$lung_young, na.rm = TRUE)

#arrange by lung old 
IPA_res_lung_modified <- IPA_res_lung_modified %>% dplyr::arrange(desc(lung_old))

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-7.543, 0, 3.051), c("blue", "white", "orange"))
col_fun(seq(-7.543, 0, 3.051))

#convert data to matrix 
IPA_res_lung_modified_mat <- IPA_res_lung_modified

#set pathways as rownames
rownames(IPA_res_lung_modified_mat) <- IPA_res_lung_modified_mat$Pathway

#get rid of extra columns
IPA_res_lung_modified_mat <- IPA_res_lung_modified_mat[,-1]

#convert to matrix 
IPA_res_lung_modified_mat <- as.matrix(IPA_res_lung_modified_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_stage_I_TCGA_Lung_only_modified_old_vs_young_median_age.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_lung_modified_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res_lung_modified$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()



################# Plot tumor only 
IPA_res_tumor

#get max and min values 
min(IPA_res_tumor$tumor_old, na.rm = TRUE)
min(IPA_res_tumor$tumor_young, na.rm = TRUE)
max(IPA_res_tumor$tumor_old, na.rm = TRUE)
max(IPA_res_tumor$tumor_young, na.rm = TRUE)

#arrange by tumor old 
IPA_res_tumor <- IPA_res_tumor %>% dplyr::arrange(desc(tumor_young))

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.887, 0, 3.656), c("blue", "white", "orange"))
col_fun(seq(-2.887, 0, 3.656))

#convert data to matrix 
IPA_res_tumor_mat <- IPA_res_tumor

#set pathways as rownames
rownames(IPA_res_tumor_mat) <- IPA_res_tumor_mat$Pathway

#get rid of extra columns
IPA_res_tumor_mat <- IPA_res_tumor_mat[,-1]

#convert to matrix 
IPA_res_tumor_mat <- as.matrix(IPA_res_tumor_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_stage_I_TCGA_tumor_only_old_vs_young_median_age.pdf", height = 24, width = 18)
ComplexHeatmap::Heatmap(IPA_res_tumor_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res_tumor$Pathway, 
                        width = unit(2, "cm"), height = unit(38, "cm"))
dev.off()


sessionInfo()







################################################################################
######################## NYU advanced stage cohort ##########

#read counts 
mycounts_advanced <- read.delim2(file = "NYU_advanced_stage/LungCA_RNAseq_TRIO_Count_Table.txt", sep = "\t", header = TRUE, row.names = 1)

##change X in the begining of columnames
colnames(mycounts_advanced) <- gsub("X", "", colnames(mycounts_advanced))


#read metadata 
NYU_adv_metadata <- read.delim2(file = "NYU_advanced_stage/220726_IO_metadata_deidentified1.txt", sep = "\t", header = TRUE, row.names = 1)

#choose relevant metadata 
NYU_adv_metadata_filtered <- NYU_adv_metadata %>% 
  dplyr::filter(Sample_Type == "BAL") %>% 
  dplyr::filter(Visit=="V1") %>% 
  dplyr::filter(Laterality_Inv_BK=="Inv")

#select the genes table 
mycounts_advanced <- mycounts_advanced %>% 
  dplyr::select(rownames(NYU_adv_metadata_filtered))

#confirm columns names of data and rownamnes of metadata are similar 
table(colnames(mycounts_advanced)==rownames(NYU_adv_metadata_filtered))


### Thats leave 61 samples (one sample per subject)

### perpare variables for analysis (age group, mortality)

#group by median age 
median(NYU_adv_metadata_filtered$Age)
NYU_adv_metadata_filtered$age_grp <- ifelse(NYU_adv_metadata_filtered$Age <= 69, "young", "old")

#by age extremes (results are similar to early stage and TCGA data, so will keep it ) you get three gorups 42-66, 66-73, 73-86
cut(NYU_adv_metadata_filtered$Age, breaks = quantile(NYU_adv_metadata_filtered$Age, probs= c(0,1/3, 2/3, 1)))
NYU_adv_metadata_filtered$age_3_grps <- ifelse(NYU_adv_metadata_filtered$Age < 66, "young", ifelse(NYU_adv_metadata_filtered$Age >= 73, "old", "middle"))

#calculate time to death (only for dead)
NYU_adv_metadata_filtered$time_to_death <- as.Date(NYU_adv_metadata_filtered$death_date, format = "%m/%d/%y") - as.Date(NYU_adv_metadata_filtered$Visit_Date, format = "%m/%d/%y")

#overall survival 
NYU_adv_metadata_filtered$OS_days <- as.Date(NYU_adv_metadata_filtered$date_last_known_or_death, format = "%m/%d/%y") - as.Date(NYU_adv_metadata_filtered$Visit_Date, format = "%m/%d/%y")

#2 years mortality 
NYU_adv_metadata_filtered <- NYU_adv_metadata_filtered %>% 
  dplyr::mutate(two_y_mort = case_when(
    death=="1" & OS_days > 760 ~ "greater_24", 
    death=="1" & OS_days < 760 ~ "less_24", 
    death=="0" & OS_days > 760 ~ "greater_24", 
    death=="0" & OS_days < 760 ~ "NA", 
    ))

#5 years mortality 
NYU_adv_metadata_filtered <- NYU_adv_metadata_filtered %>% 
  dplyr::mutate(five_y_mort = case_when(
    death=="1" & OS_days > 1825 ~ "greater_24", 
    death=="1" & OS_days < 1825 ~ "less_24", 
    death=="0" & OS_days > 1825 ~ "greater_24", 
    death=="0" & OS_days < 1825 ~ "NA", 
  ))


############### NYU advanced stage comparison by median age #################

#table 1 
#get tabel 1 information 

Table.1.data <- NYU_adv_metadata_filtered

#calculate median age = 69
median(Table.1.data$Age, na.rm = TRUE)

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(Adenocacarcinoma) + factor(Squamous_cell_carcinoma)+ factor(PD_L1_expression) + as.numeric(Age) + factor(Race) + as.numeric(Pack_years)+as.numeric(BMI)
       + factor(Stage) +factor(Sex) + factor(death) + as.numeric(OS_days) + factor(Smoking) +factor(two_y_mort)+factor(five_y_mort)
       # set the variable you want to stratify by 
       | age_grp, 
       #set data 
       data=Table.1.data, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))

#now add stats (same as above except where notes added )
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(Adenocacarcinoma) + factor(Squamous_cell_carcinoma)+ factor(PD_L1_expression) + as.numeric(Age) + factor(Race) + as.numeric(Pack_years)+as.numeric(BMI)
       + factor(Stage) +factor(Sex) + factor(death) + as.numeric(OS_days) + factor(Smoking) +factor(two_y_mort)+factor(five_y_mort)
       # set the variable you want to stratify by 
       | age_grp, 
       #set data 
       data=Table.1.data, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))


################ Kaplan Meier for Recurrence stage I, by age extremes  ########

#use patients data 
Table.1.data

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- Table.1.data

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$OS_days <- gsub("days", "", metadata$OS_days)

###plot for death 
#Column to be used as time (in days) - OS_days 
# column to be used as status is death
survival.data <- metadata[, c("OS_days","death", "age_grp" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- as.factor(survival.data$Age)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Old", "Young"), legend.title="Age",  
                            palette=c("darkred", "darkgreen"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to median Age",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot (export as PNG)

#### Differntial analysis 

############## Create summarized experiment object #########################

#Convert Model Variable into Factor
NYU_adv_metadata_filtered$age_grp<- factor(NYU_adv_metadata_filtered$age_grp)
NYU_adv_metadata_filtered$death <- factor(NYU_adv_metadata_filtered$death)


#Deseq 
#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(mycounts_advanced, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(mycounts_advanced))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = NYU_adv_metadata_filtered, design = ~ age_grp + two_y_mort)

#Normalization Step 
dds <- estimateSizeFactors(dds)

#Retrive normalized counts matrix 
normalized_counts <- counts(dds, normalized=TRUE)
#save it 
write.table(normalized_counts, file="Results/RNA/normalized_counts_NYU_advanced_median_age.txt", sep="\t", quote=F, col.names=NA)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#Drop Levels
dds$age_grp   <- droplevels(dds$age_grp)
vsd$age_grp   <- droplevels(vsd$age_grp)

dds$two_y_mort   <- droplevels(dds$two_y_mort)
vsd$two_y_mort   <- droplevels(vsd$two_y_mort)


#################### NYU advanced stage #run old vs young ##############

dds.analysis <- dds
vsd.analysis <- vsd

#define variables 
dds.analysis$age_grp
v= "age_grp"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "darkred"

#young
col2 <- "darkgreen"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_grp

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_NYU_advanced_stage", paste0("_", paste0("_", paste0(v, paste0(".txt")))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_NYU_advancedd_stage", paste0("_", paste0("_", paste0(v, paste0(".pdf"))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_NYU_advanced_stage_", paste0("_", paste0("_", paste0(v, paste0(".csv"))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_NYU_advanced_stage_", paste0("_", paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


####################### Repeat for old comparing two years mortality 

#subset old and yougn tables 
dds_old <- dds[,dds$age_grp =="old"]
dds_young <- dds[,dds$age_grp=="young"]

vsd_old <- vsd[,vsd$age_grp =="old"]
vsd_young <- vsd[,vsd$age_grp=="young"]

#start with old 
dds.analysis <- dds_old
vsd.analysis <- vsd_old

#remove any NA 
dds.analysis <- dds.analysis[,dds.analysis$two_y_mort!= "NA"]
vsd.analysis <- vsd.analysis[,vsd.analysis$two_y_mort!= "NA"]

#define variables 
dds.analysis$two_y_mort
v= "two_y_mort"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "greater_24")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "greater_24")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# less 24 months 
col1 <- "red2"

#greater 24 months 
col2 <- "dodgerblue2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$two_y_mort

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_NYU_advanced_stage_old_median_age_", paste0("_", paste0(v, paste0(".txt"))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_NYU_advancedd_stage_old_median_age_", paste0("_", paste0(v, paste0(".pdf")))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("> 24 Months", "< 24 Months"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_NYU_advanced_stage_old__median_age_", paste0("_", paste0("_", paste0(v, paste0(".csv"))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_NYU_advanced_stage_old_median_age_", paste0("_", paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



####### repeat for young 

#start with young 
dds.analysis <- dds_young
vsd.analysis <- vsd_young

#remove any NA 
dds.analysis <- dds.analysis[,dds.analysis$two_y_mort!= "NA"]
vsd.analysis <- vsd.analysis[,vsd.analysis$two_y_mort!= "NA"]

#define variables 
dds.analysis$two_y_mort
v= "two_y_mort"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "greater_24")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "greater_24")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# less 24 months 
col1 <- "orangered2"

# greater 24 months 
col2 <- "skyblue2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$two_y_mort

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_NYU_advanced_stage_young_median_age_", paste0("_", paste0(v, paste0(".txt"))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_NYU_advancedd_stage_young_median_age_", paste0("_", paste0(v, paste0(".pdf")))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("> 24 Months", "< 24 Months"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_NYU_advanced_stage_young_median_age_", paste0("_", paste0("_", paste0(v, paste0(".csv"))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_NYU_advanced_stage_young_median_age_", paste0("_", paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


################### IPA heatmap NYU advanced stage old vs young according to age median #### 










############### NYU advanced stage comparison by age extremes  #################

#remove middle age (reduce number of patients to 41)
NYU_adv_stage_age_extrem <- NYU_adv_metadata_filtered %>% dplyr::filter(age_3_grps!= "middle")

#get similar count data 
mycounts_advanced_Age_extremes <- mycounts_advanced %>% dplyr::select(rownames(NYU_adv_stage_age_extrem))

table(colnames(mycounts_advanced_Age_extremes)==rownames(NYU_adv_stage_age_extrem))


#table 1 
#get tabel 1 information 

Table.1.data <- NYU_adv_stage_age_extrem

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(Adenocacarcinoma) + factor(Squamous_cell_carcinoma)+ factor(PD_L1_expression) + as.numeric(Age) + factor(Race) + as.numeric(Pack_years)+as.numeric(BMI)
       + factor(Stage) +factor(Sex) + factor(death) + as.numeric(OS_days) + factor(Smoking) +factor(two_y_mort)+factor(five_y_mort)
       # set the variable you want to stratify by 
       | age_3_grps, 
       #set data 
       data=Table.1.data, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))

#now add stats (same as above except where notes added )
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(Adenocacarcinoma) + factor(Squamous_cell_carcinoma)+ factor(PD_L1_expression) + as.numeric(Age) + factor(Race) + as.numeric(Pack_years)+as.numeric(BMI)
       + factor(Stage) +factor(Sex) + factor(death) + as.numeric(OS_days) + factor(Smoking) +factor(two_y_mort)+factor(five_y_mort)
       # set the variable you want to stratify by 
       | age_3_grps, 
       #set data 
       data=Table.1.data, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))

#p value for numerical variables 
t.test(as.numeric(Table.1.data$Age) ~ Table.1.data$age_3_grps)# p-value = 1.563e-11
t.test(as.numeric(Table.1.data$Pack_years) ~ Table.1.data$age_3_grps)# p-value = 0.8884

################ Kaplan Meier for Recurrence stage I, by age extremes  ########

#use patients data 
Table.1.data

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- Table.1.data

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$OS_days <- gsub("days", "", metadata$OS_days)

###plot for death 
#Column to be used as time (in days) - OS_days 
# column to be used as status is death
survival.data <- metadata[, c("OS_days","death", "age_3_grps" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- as.factor(survival.data$Age)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Old", "Young"), legend.title="Age",  
                            palette=c("darkred", "darkgreen"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to median Age",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot (export as PNG)

#### Differntial analysis 

############## Create summarized experiment object #########################

#Convert Model Variable into Factor
NYU_adv_stage_age_extrem$age_3_grps<- factor(NYU_adv_stage_age_extrem$age_3_grps)
NYU_adv_stage_age_extrem$death <- factor(NYU_adv_stage_age_extrem$death)


#Deseq 
#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(mycounts_advanced_Age_extremes, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(mycounts_advanced_Age_extremes))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = NYU_adv_stage_age_extrem, design = ~ age_3_grps + two_y_mort)

#Normalization Step 
dds <- estimateSizeFactors(dds)

#Retrive normalized counts matrix 
normalized_counts <- counts(dds, normalized=TRUE)
#save it 
write.table(normalized_counts, file="Results/RNA/normalized_counts_NYU_advanced_extreme_age.txt", sep="\t", quote=F, col.names=NA)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#Drop Levels
dds$age_3_grps   <- droplevels(dds$age_3_grps)
vsd$age_3_grps   <- droplevels(vsd$age_3_grps)

dds$two_y_mort   <- droplevels(dds$two_y_mort)
vsd$two_y_mort   <- droplevels(vsd$two_y_mort)


#################### NYU advanced stage #run old vs young ##############

dds.analysis <- dds
vsd.analysis <- vsd

#define variables 
dds.analysis$age_3_grps
v= "age_3_grps"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "young")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "young")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "darkred"

#young
col2 <- "darkgreen"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_3_grps

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_NYU_advanced_stage", paste0("_", paste0("_", paste0(v, paste0(".txt")))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_NYU_advancedd_stage", paste0("_", paste0("_", paste0(v, paste0(".pdf"))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_NYU_advanced_stage_", paste0("_", paste0("_", paste0(v, paste0(".csv"))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_NYU_advanced_stage_", paste0("_", paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


####################### Repeat for old comparing two years mortality 

#subset old and yougn tables 
dds_old <- dds[,dds$age_3_grps =="old"]
dds_young <- dds[,dds$age_3_grps=="young"]

vsd_old <- vsd[,vsd$age_3_grps =="old"]
vsd_young <- vsd[,vsd$age_3_grps=="young"]

#start with old 
dds.analysis <- dds_old
vsd.analysis <- vsd_old

#remove any NA 
dds.analysis <- dds.analysis[,dds.analysis$two_y_mort!= "NA"]
vsd.analysis <- vsd.analysis[,vsd.analysis$two_y_mort!= "NA"]

#define variables 
dds.analysis$two_y_mort
v= "two_y_mort"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "greater_24")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "greater_24")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# less 24 months 
col1 <- "red2"

#greater 24 months 
col2 <- "dodgerblue2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$two_y_mort

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_NYU_advanced_stage_old_age_extremes", paste0("_", paste0(v, paste0(".txt"))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_NYU_advancedd_stage_old_age_extremes", paste0("_", paste0(v, paste0(".pdf")))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("> 24 Months", "< 24 Months"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_NYU_advanced_stage_old_age_extremes", paste0("_", paste0("_", paste0(v, paste0(".csv"))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_NYU_advanced_stage_old_age_extremes", paste0("_", paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



####### repeat for young 

#start with young 
dds.analysis <- dds_young
vsd.analysis <- vsd_young

#remove any NA 
dds.analysis <- dds.analysis[,dds.analysis$two_y_mort!= "NA"]
vsd.analysis <- vsd.analysis[,vsd.analysis$two_y_mort!= "NA"]

#define variables 
dds.analysis$two_y_mort
v= "two_y_mort"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "greater_24")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "greater_24")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# less 24 months 
col1 <- "orangered2"

# greater 24 months 
col2 <- "skyblue2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$two_y_mort

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_NYU_advanced_stage_young_age_extremes", paste0("_", paste0(v, paste0(".txt"))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_NYU_advancedd_stage_young_age_extremes", paste0("_", paste0(v, paste0(".pdf")))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("> 24 Months", "< 24 Months"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_NYU_advanced_stage_young_age_extremes", paste0("_", paste0("_", paste0(v, paste0(".csv"))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_NYU_advanced_stage_young_age_extremes", paste0("_", paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()

##################################### 
########################## IPA heatmap for NYU advanced stage ##################
IPA_res <- read.csv("IPA/IPA_comparison_NYU_advanced_stage_median_age.csv")

#get max and min values 
max(IPA_res$old, na.rm = TRUE)
max(IPA_res$young, na.rm = TRUE)
min(IPA_res$old, na.rm = TRUE)
min(IPA_res$young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-0.447, 0, 3.657), c("blue", "white", "orange"))
col_fun(seq(-0.447, 0, 3.657))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/NYU_advanced_stage_IPA_old_vs_young_age_median.pdf", height = 10, width = 8)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(1, "cm"), height = unit(10, "cm"))
dev.off()


###### age extremes 
IPA_res <- read.csv(file = "IPA/IPA_comparison_NYU_adv_stage_age_extremes.csv")


#get max and min values 
max(IPA_res$old, na.rm = TRUE)
max(IPA_res$young, na.rm = TRUE)
min(IPA_res$old, na.rm = TRUE)
min(IPA_res$young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-1.633, 0, 2.84), c("blue", "white", "orange"))
col_fun(seq(-1.633, 0, 2.84))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/NYU_advanced_stage_IPA_old_vs_young_age_extremes.pdf", height = 10, width = 8)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(1, "cm"), height = unit(10, "cm"))
dev.off()



















################################################################################
#################### Random Forest on NYU discovery cohorts #################### 

######## Random forest on NYU early stage tumor samples ########
setwd("~/Dropbox (NYU Langone Health)/Fares Darawshyâ€™s files/Home/Projects/Early.Lung.Cancer/Analysis_by_Age")

mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

#load genes dataset 
mycounts

#Order Count Data by SampleID and replace the X before each name 
colnames(mycounts) <- gsub("X", "", colnames(mycounts))
mycounts <- mycounts [, order(colnames(mycounts))]

#Confirm Sample IDs match for Count and Meta Data
table(colnames(mycounts)==as.character(RNA.data$RNA_ID))

#confirm columns names of data and rownamnes of metadata are similar 
table(colnames(mycounts)==rownames(RNA.data))


#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
d1 = data.frame(lapply(mycounts, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(mycounts))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)

#Convert Model Variable into Factor
RNA.data$Sample_Type_Involved <- as.factor(RNA.data$Sample_Type_Involved)
RNA.data$Progression_Lab_Inv <- as.factor(RNA.data$Progression_Lab_Inv)

dds <- DESeqDataSetFromMatrix(countData = d1, colData = RNA.data, design = ~ Sample_Type_Involved)

#Normalization Step 
dds <- estimateSizeFactors(dds)
#filter genes where there are less than 3 samples with normalized counts greater than or equal to 500.
idx <- rowSums( counts(dds, normalized=TRUE) >= 500 ) >= 3

dds <- dds[idx,]

genes <- mycounts %>% 
  dplyr::filter(., idx)


#get tumor samples only 
genes <- genes %>% 
  dplyr::select(starts_with("NYU"))

#transpose
genes.transposed <- as.data.frame(t(genes))

TUMOR.RNA.data <- subset_samples(RNA.data, Sample_Type_Involved == "Lung.Tissue.In")

#get metadata 
metadata.for.RF <- sample_data(TUMOR.RNA.data) %>% 
  data.frame()

#be sure to include the samples needed 
genes.transposed<- genes.transposed %>% 
  dplyr::filter(rownames(genes.transposed) %in% rownames(metadata.for.RF))

#define outcome 
outcome <- as.factor(metadata.for.RF$Progression_Lab)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data_complete, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)

# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

group_enrich

Gini$enrich_group <- group_enrich

#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::slice(1:4952)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
round(0.01*4952)
Genes.1.per <- Gini %>% 
  dplyr::slice(1:50)

#top 5%
round(0.05*4952)
Genes.5.per <- Gini %>% 
  dplyr::slice(1:248)

#top 10%
round(0.1*4952)
Genes.10.per <- Gini %>% 
  dplyr::slice(1:495)

#top 20%
round(0.2*4952)
Genes.20.per <- Gini %>% 
  dplyr::slice(1:990)

#top 50%
round(0.5*4952)
Genes.50.per <- Gini %>% 
  dplyr::slice(1:2476)

#top 75%
round(0.75*4952)
Genes.75.per <- Gini %>% 
  dplyr::slice(1:3714)

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [50:11560] <- NA
Ginidf.to.save$five_per [248:11560] <- NA
Ginidf.to.save$ten_per [495:11560] <- NA
Ginidf.to.save$twent_per [990:11560] <- NA
Ginidf.to.save$fifty_per [2476:11560] <- NA
Ginidf.to.save$sevent_fiv_per [3714:11560] <- NA

write.csv(Ginidf.to.save, file = "RF/RF_results_NYU_early_stage_Tumor_samples.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF/Figuers/roc.plot.NYU_early_stage_Tumor_samples_100_per.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_Stage_Tumor_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_Stage_Tumor_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_stage_Tumor_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_stage_Tumor_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/FIgures/roc.plot.NYU_early_stage_Tumor_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_stage_Tumor_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


##################################################################################

############################ NYU early stage Lung samples #######################

mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

#load genes dataset 
mycounts

#Order Count Data by SampleID and replace the X before each name 
colnames(mycounts) <- gsub("X", "", colnames(mycounts))
mycounts <- mycounts [, order(colnames(mycounts))]

#Confirm Sample IDs match for Count and Meta Data
table(colnames(mycounts)==as.character(RNA.data$RNA_ID))

#confirm columns names of data and rownamnes of metadata are similar 
table(colnames(mycounts)==rownames(RNA.data))


#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
d1 = data.frame(lapply(mycounts, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(mycounts))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)

#Convert Model Variable into Factor
RNA.data$Sample_Type_Involved <- as.factor(RNA.data$Sample_Type_Involved)
RNA.data$Progression_Lab_Inv <- as.factor(RNA.data$Progression_Lab_Inv)

dds <- DESeqDataSetFromMatrix(countData = d1, colData = RNA.data, design = ~ Sample_Type_Involved)

#Normalization Step 
dds <- estimateSizeFactors(dds)
#filter genes where there are less than 3 samples with normalized counts greater than or equal to 500.
idx <- rowSums( counts(dds, normalized=TRUE) >= 500 ) >= 3

dds <- dds[idx,]

genes <- mycounts %>% 
  dplyr::filter(., idx)


#get lung samples only 
genes <- genes %>% 
  dplyr::select(-starts_with("NYU"))

#transpose
genes.transposed <- as.data.frame(t(genes))

lung.RNA.data <- subset_samples(RNA.data, Sample_Type_Involved == "Lung.Tissue.UnIn")

#get metadata 
metadata.for.RF <- sample_data(lung.RNA.data) %>% 
  data.frame()

#be sure to include the samples needed 
genes.transposed<- genes.transposed %>% 
  dplyr::filter(rownames(genes.transposed) %in% rownames(metadata.for.RF))

#define outcome 
outcome <- as.factor(metadata.for.RF$Progression_Lab)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data_complete, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)

# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

group_enrich

Gini$enrich_group <- group_enrich

#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::slice(1:4627)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
round(0.01*4627)
Genes.1.per <- Gini %>% 
  dplyr::slice(1:46)

#top 5%
round(0.05*4627)
Genes.5.per <- Gini %>% 
  dplyr::slice(1:231)

#top 10%
round(0.1*4627)
Genes.10.per <- Gini %>% 
  dplyr::slice(1:463)

#top 20%
round(0.2*4627)
Genes.20.per <- Gini %>% 
  dplyr::slice(1:925)

#top 50%
round(0.5*4627)
Genes.50.per <- Gini %>% 
  dplyr::slice(1:2314)

#top 75%
round(0.75*4627)
Genes.75.per <- Gini %>% 
  dplyr::slice(1:3470)

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [47:11560] <- NA
Ginidf.to.save$five_per [232:11560] <- NA
Ginidf.to.save$ten_per [464:11560] <- NA
Ginidf.to.save$twent_per [926:11560] <- NA
Ginidf.to.save$fifty_per [2315:11560] <- NA
Ginidf.to.save$sevent_fiv_per [3471:11560] <- NA

write.csv(Ginidf.to.save, file = "RF/RF_results_NYU_early_stage_lung_samples.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF/Figures/roc.plot.NYU_early_stage_lung_samples_100_per.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_Stage_lung_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_Stage_lung_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_stage_lung_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_stage_lung_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/FIgures/roc.plot.NYU_early_stage_lung_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_stage_lung_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



################################################################################
############################## NYU advanced stage random forest ################

#tables to be used: 
mycounts_advanced_Age_extremes
NYU_adv_stage_age_extrem
#load metadata 
RNA.data <- NYU_adv_stage_age_extrem

#load genes dataset 
mycounts <- mycounts_advanced_Age_extremes

mycounts <- mycounts [, order(colnames(mycounts))]

#confirm columns names of data and rownamnes of metadata are similar 
table(colnames(mycounts)==rownames(RNA.data))


#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
d1 = data.frame(lapply(mycounts, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(mycounts))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)

#Convert Model Variable into Factor
RNA.data$two_y_mort <- as.factor(RNA.data$two_y_mort)

dds <- DESeqDataSetFromMatrix(countData = d1, colData = RNA.data, design = ~ death)

#Normalization Step 
dds <- estimateSizeFactors(dds)
#filter genes where there are less than 3 samples with normalized counts greater than or equal to 500.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3

dds <- dds[idx,]

genes <- mycounts %>% 
  dplyr::filter(., idx)

#transpose
genes.transposed <- as.data.frame(t(genes))
#get metadata 
metadata.for.RF <- RNA.data

#be sure to include the samples needed 
genes.transposed<- genes.transposed %>% 
  dplyr::filter(rownames(genes.transposed) %in% rownames(metadata.for.RF))

#define outcome 
outcome <- as.factor(metadata.for.RF$death)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data_complete, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)

# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich

#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% dplyr::filter(Gini != 0)
#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
round(0.01*1671)
Genes.1.per <- Gini %>% 
  dplyr::slice(1:17)

#top 5%
round(0.05*1671)
Genes.5.per <- Gini %>% 
  dplyr::slice(1:84)

#top 10%
round(0.1*1671)
Genes.10.per <- Gini %>% 
  dplyr::slice(1:167)

#top 20%
round(0.2*1671)
Genes.20.per <- Gini %>% 
  dplyr::slice(1:334)

#top 50%
round(0.5*1671)
Genes.50.per <- Gini %>% 
  dplyr::slice(1:836)

#top 75%
round(0.75*1671)
Genes.75.per <- Gini %>% 
  dplyr::slice(1:1253)

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [18:1671] <- NA
Ginidf.to.save$five_per [85:1671] <- NA
Ginidf.to.save$ten_per [168:1671] <- NA
Ginidf.to.save$twent_per [335:1671] <- NA
Ginidf.to.save$fifty_per [837:1671] <- NA
Ginidf.to.save$sevent_fiv_per [1254:1671] <- NA
Ginidf.to.save <- Ginidf.to.save %>% dplyr::slice(1:1671)

write.csv(Ginidf.to.save, file = "RF/RF_results_NYU_advanced_stage_samples.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF/Figures/roc.plot.NYU_advanced_stage_samples_100_per.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_advanced_stage_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_advanced_stage_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_advanced_stage_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

predictions <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_advanced_stage_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

predictions <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/FIgures/roc.plot.NYU_advanced_stage_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
so <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_advanced_stage_samples_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


#################################################################################
#######################.  risk score example from RF for NYU advanced stage using best AUC genes (10%)#####

#get genes liist 
Genes.10.per

#get genes expression data 
selected_genes <- Genes.10.per %>% dplyr::select(Gini)

mycounts <- mycounts_advanced

subset_counts <- mycounts[rownames(selected_genes),]
subset_counts$Gene.symbol <- rownames(subset_counts)
#we want gene expression on old only associated with mortality, so read edgeR results 
res <- read.csv(file = "Results/RNA/edgeR.results_NYU_advanced_stage_old_age_extremes__two_y_mort.csv")
res1 <- res %>% dplyr::filter(logFC>0) %>% dplyr::filter(FDR <=0.2) %>% dplyr::select(Gene.symbol)

#get these genes 
subset_counts <- inner_join(subset_counts, res1, by="Gene.symbol")
rownames(subset_counts) <- subset_counts$Gene.symbol
gene_expression <- subset_counts
gene_expression <- gene_expression %>% dplyr::select(-Gene.symbol)
#normalize genes counts by adding 1 and log2 
x <- log2(gene_expression+1)

#build individual risk score for every patient and every gene
risk_scores <- x * selected_genes$Gini

#transpose so every subject is a row 
risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
NYU_adv_metadata_filtered$final_risk_score <- risk_scores_t$final_risk_score
NYU_adv_metadata_filtered$risk_group <- risk_scores_t$risk_group
#use patients data 
NYU_adv_metadata_filtered

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- NYU_adv_metadata_filtered

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  

###plot for death 
#Column to be used as time (in days) - OS_days 
# column to be used as status is death
survival.data <- metadata[, c("OS_days","death", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)





################ Approach 2: NYU advanced stage  using genes shared with public data ###


#get genes list of old paients associated with aging in public datasets 
genes_list_1 <- read.csv(file = "saul.cells.gene.list.csv")
genes_list_2 <- read.csv(file = "genes_associated_with_age_peters_et_al.csv")
#combine both lists and keep distinct only 
genes_list <- bind_rows(genes_list_1, genes_list_2)
genes_list <- genes_list %>% distinct(., .keep_all = TRUE) ##### results in 2532 unique genes associated with old age 
genes_list$Gene
#get genes expression data (best AUC is in 1% of gens)
selected_genes <- Genes.10.per
selected_genes$Gene <- rownames(selected_genes)

#find overlap with public genes (30 genes)
selected_genes<- inner_join(selected_genes, genes_list, by="Gene")
rownames(selected_genes) <- selected_genes$Gene

mycounts <-mycounts_advanced

subset_counts <- mycounts[rownames(selected_genes),]

gene_expression <- subset_counts
#save genes list 
write.csv(gene_expression, file = "risk_score_genes_from_NYU_adv_stage_overlapped_with_public_genes.csv")
#normalize genes counts by adding 1 and log2 
x <- log2(gene_expression+1)

#build individual risk score for every patient and every gene
risk_scores <- x * selected_genes$Gini

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
NYU_adv_metadata_filtered$final_risk_score <- risk_scores_t$final_risk_score
NYU_adv_metadata_filtered$risk_group <- risk_scores_t$risk_group


#use patients data 
NYU_adv_metadata_filtered

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- NYU_adv_metadata_filtered

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  

###plot for death 
#Column to be used as time (in days) - OS_days 
# column to be used as status is death
survival.data <- metadata[, c("OS_days","death", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

###########validation 
#in young patients 


#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- NYU_adv_metadata_filtered %>% dplyr::filter(age_3_grps=="young")

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  

###plot for death 
#Column to be used as time (in days) - OS_days 
# column to be used as status is death
survival.data <- metadata[, c("OS_days","death", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

#validate in middle age 

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- NYU_adv_metadata_filtered %>% dplyr::filter(age_3_grps=="middle")

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  

###plot for death 
#Column to be used as time (in days) - OS_days 
# column to be used as status is death
survival.data <- metadata[, c("OS_days","death", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)
#in old only 

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- NYU_adv_metadata_filtered %>% dplyr::filter(age_3_grps=="old")

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  

###plot for death 
#Column to be used as time (in days) - OS_days 
# column to be used as status is death
survival.data <- metadata[, c("OS_days","death", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)



####### validation in TCGA advanced stage 
#get clinical metadata of advanced stage (overall n=125)
#try to select randomly equal number of aptietns 

tcga_metadata_advanced_stage 

#get the cont table accordingly 
tcga_counts_advanced_stage 

ncol(tcga_counts_advanced_stage) == nrow(tcga_metadata_advanced_stage)

# get risk score genes (used form genes shared with peters et al) should be 18 genes 
risk_score_genes <- rownames(gene_expression)

#subset those genes from TCGA cohort 
tcga_subset_genes_advanced_stage <- tcga_counts_advanced_stage[risk_score_genes,]

#normalize genes counts by adding 1 and log2 
x <- log2(tcga_subset_genes_advanced_stage+1)

#build individual risk score for every patient and every gene 
risk_scores <- x * selected_genes$Gini

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
tcga_metadata_advanced_stage$final_risk_score <- risk_scores_t$final_risk_score
tcga_metadata_advanced_stage$risk_group <- risk_scores_t$risk_group

#see if ther eis a difference in mortality in low vs high risk groups 
#use patients data 
tcga_metadata_advanced_stage

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_advanced_stage

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

#### TCGA validation young 
#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="young")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)



#TCGA validation middle age 
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="middle")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


### TCGA validaiton old 
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="old")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#repat for TCGA validation tumor 


#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(sample_type=="Primary Tumor")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

#### TCGA validation young 
#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="young") %>% dplyr::filter(sample_type=="Primary Tumor")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)



#TCGA validation middle age 
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="middle") %>% dplyr::filter(sample_type=="Primary Tumor")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


### TCGA validaiton old 
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="old") %>% dplyr::filter(sample_type=="Primary Tumor")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)







#repeat for TCGA validation lung 



#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(sample_type=="Solid Tissue Normal")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

#### TCGA validation young 
#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="young") %>% dplyr::filter(sample_type=="Solid Tissue Normal")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)



#TCGA validation middle age 
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="middle") %>% dplyr::filter(sample_type=="Solid Tissue Normal")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


### TCGA validaiton old 
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="old") %>% dplyr::filter(sample_type=="Solid Tissue Normal")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


################################################################################
################################################################################
################################################################################

############### Risk score in advanced stagew based on genes upregulated and significant in old patients (using extreme ages) with high mortality only ########## 

#get differntialy enriched genes (read results)
res <- read.csv(file = "Results/RNA/edgeR.results_NYU_advanced_stage_old_age_extremes__two_y_mort.csv")
#sort results by FDR and filter for FDR < 0.2 and logFC > 0 (assocaited with mortality)
sig_res <- res %>% dplyr::filter(logFC >0) %>%
  dplyr::filter(FDR < 0.2)
#get genes list 
old_mort_genes_NYU_adv_stage <- sig_res %>% dplyr::select(Gene.symbol, logFC)

#now get only those genes from the counts table 
genes_counts <- mycounts_advanced[old_mort_genes_NYU_adv_stage$Gene.symbol,]

#tables to be used (all patietns, not just age exteremes)
NYU_adv_metadata_filtered


#load metadata 
RNA.data <- NYU_adv_metadata_filtered

#load genes dataset 
mycounts <- genes_counts

mycounts <- mycounts [, order(colnames(mycounts))]

#confirm columns names of data and rownamnes of metadata are similar 
table(colnames(mycounts)==rownames(RNA.data))


#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
d1 = data.frame(lapply(mycounts, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(mycounts))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)

#Convert Model Variable into Factor
RNA.data$two_y_mort <- as.factor(RNA.data$two_y_mort)

dds <- DESeqDataSetFromMatrix(countData = d1, colData = RNA.data, design = ~ death)

#Normalization Step 
dds <- estimateSizeFactors(dds)
#filter genes where there are less than 3 samples with normalized counts greater than or equal to 500. if the number of genes is high (> 15K)
#idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
#dds <- dds[idx,]
genes <- mycounts

#transpose
genes.transposed <- as.data.frame(t(genes))
#get metadata 
metadata.for.RF <- RNA.data

#be sure to include the samples needed 
genes.transposed<- genes.transposed %>% 
  dplyr::filter(rownames(genes.transposed) %in% rownames(metadata.for.RF))

#define outcome 
outcome <- as.factor(metadata.for.RF$death)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data_complete, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)

# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich

#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% dplyr::filter(Gini != 0)
#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
z <- round(0.01*nrow(Gini))
Genes.1.per <- Gini %>% dplyr::slice(1:z)

#top 5%
z <- round(0.05*nrow(Gini))
Genes.5.per <- Gini %>% dplyr::slice(1:z)

#top 10%
z <- round(0.1*nrow(Gini))
Genes.10.per <- Gini %>% dplyr::slice(1:z)

#top 20%
z<- round(0.2*nrow(Gini))
Genes.20.per <- Gini %>% dplyr::slice(1:z)

#top 50%
z<- round(0.5*nrow(Gini))
Genes.50.per <- Gini %>% dplyr::slice(1:z)

#top 75%
z<- round(0.75*nrow(Gini))
Genes.75.per <- Gini %>% dplyr::slice(1:z)

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [(nrow(Genes.1.per)+1):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [(nrow(Genes.5.per)+1):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [(nrow(Genes.10.per)+1):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [(nrow(Genes.20.per)+1):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [(nrow(Genes.50.per)+1):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [(nrow(Genes.75.per)+1):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save <- Ginidf.to.save %>% dplyr::slice(1:nrow(Ginidf.to.save))

write.csv(Ginidf.to.save, file = "RF/RF_results_NYU_advanced_stage_all_samples_using_genes_upregulated_in_old_mort.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF/Figures/roc.plot.NYU_advanced_stage_samples_100_per_all_samples_using_genes_upregulated_in_old_mort.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_advanced_stage_samples_all_samples_using_genes_upregulated_in_old_mort", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_advanced_stage_samples_all_samples_using_genes_upregulated_in_old_mort", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_advanced_stage_samples_all_samples_using_genes_upregulated_in_old_mort_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

predictions <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_advanced_stage_samples_all_samples_using_genes_upregulated_in_old_mort_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

predictions <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/FIgures/roc.plot.NYU_advanced_stage_samples_all_samples_using_genes_upregulated_in_old_mort", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
so <- predict(fit, type = "prob")
colnames(predictions) <- c("alive", "dead")
pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "1" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="1", "alive", "dead"), as.numeric(pred.df$dead))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_advanced_stage_samples_all_samples_using_genes_upregulated_in_old_mort", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


#################################################################################
#######################.  risk score example from RF for NYU advanced stage using best AUC genes (5%)#####


#get genes liist 
Genes.5.per

#get genes expression data 
selected_genes <- Genes.5.per %>% dplyr::select(Gini)

mycounts <- mycounts_advanced

subset_counts <- mycounts[rownames(selected_genes),]

gene_expression <- subset_counts
#save genes list 
write.csv(gene_expression, file = "risk_score__based_on_genes_upregulated_in_old_with_mortality_advanced_stage_as_pred.csv")
#normalize genes counts by adding 1 and log2 
x <- log2(gene_expression+1)

#build individual risk score for every patient and every gene
risk_scores <- x * selected_genes$Gini

#transpose so every subject is a row 
risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
NYU_adv_metadata_filtered$final_risk_score <- risk_scores_t$final_risk_score
NYU_adv_metadata_filtered$risk_group <- risk_scores_t$risk_group


#see if ther eis a difference in mortality in low vs high risk groups 
#use patients data 
NYU_adv_metadata_filtered

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- NYU_adv_metadata_filtered

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  

###plot for death 
#Column to be used as time (in days) - OS_days 
# column to be used as status is death
survival.data <- metadata[, c("OS_days","death", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

###########################Vlidation in young patients only 


#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- NYU_adv_metadata_filtered %>% dplyr::filter(age_3_grps=="young")

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  

###plot for death 
#Column to be used as time (in days) - OS_days 
# column to be used as status is death
survival.data <- metadata[, c("OS_days","death", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

###########################Vlidation in middle age patients only 


#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- NYU_adv_metadata_filtered %>% dplyr::filter(age_3_grps=="middle")

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  

###plot for death 
#Column to be used as time (in days) - OS_days 
# column to be used as status is death
survival.data <- metadata[, c("OS_days","death", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#validate in old 

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- NYU_adv_metadata_filtered %>% dplyr::filter(age_3_grps=="old")

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  

###plot for death 
#Column to be used as time (in days) - OS_days 
# column to be used as status is death
survival.data <- metadata[, c("OS_days","death", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)




####### validation in TCGA advanced stage 
#get clinical metadata of advanced stage (overall n=125)
#try to select randomly equal number of aptietns 

tcga_metadata_advanced_stage 

#get the cont table accordingly 
tcga_counts_advanced_stage 

ncol(tcga_counts_advanced_stage) == nrow(tcga_metadata_advanced_stage)

# get risk score genes (used form genes shared with peters et al) should be 18 genes 
risk_score_genes <- rownames(gene_expression)

#subset those genes from TCGA cohort 
tcga_subset_genes_advanced_stage <- tcga_counts_advanced_stage[risk_score_genes,]

#normalize genes counts by adding 1 and log2 
x <- log2(tcga_subset_genes_advanced_stage+1)

#build individual risk score for every patient and every gene 
risk_scores <- x * selected_genes$Gini

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
tcga_metadata_advanced_stage$final_risk_score <- risk_scores_t$final_risk_score
tcga_metadata_advanced_stage$risk_group <- risk_scores_t$risk_group

#see if ther eis a difference in mortality in low vs high risk groups 
#use patients data 
tcga_metadata_advanced_stage

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_advanced_stage

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

#### TCGA validation young 
#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="young")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)



#TCGA validation middle age 
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="middle")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


### TCGA validaiton old 
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="old")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#repat for TCGA validation tumor 


#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(sample_type=="Primary Tumor")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

#### TCGA validation young 
#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="young") %>% dplyr::filter(sample_type=="Primary Tumor")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)



#TCGA validation middle age 
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="middle") %>% dplyr::filter(sample_type=="Primary Tumor")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


### TCGA validaiton old 
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="old") %>% dplyr::filter(sample_type=="Primary Tumor")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)







#repeat for TCGA validation lung 



#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(sample_type=="Solid Tissue Normal")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

#### TCGA validation young 
#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="young") %>% dplyr::filter(sample_type=="Solid Tissue Normal")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)



#TCGA validation middle age 
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="middle") %>% dplyr::filter(sample_type=="Solid Tissue Normal")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


### TCGA validaiton old 
metadata <- tcga_metadata_advanced_stage %>% dplyr::filter(age_3_grps=="old") %>% dplyr::filter(sample_type=="Solid Tissue Normal")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)













################################################################################
################################################################################
################################################################################
########################### Risk score in NYU early stage, tumor tissue only#######
###########################

#read RF results 
RF_res <- read.csv(file = "RF/RF_results_NYU_early_stage_Tumor_samples.csv")

### will try differnt approached to develop the score: 
################ 1) using genes with best AUC from RF results that used tumor samples for analysis and getting only genes enriched in old patients with recu
################ 2) using genes with best AUC from RF results that overlap with genes published in public (2 to use: Peters et al and Cells 2021)
################# 3) run a new classifier using genes upregulated in old only and assocaited with recurrence 


############################ Approach 1, using tumor samples with best AUC ###########

#get genes list of old paients associated with recu
res <- read.csv(file = "Results/RNA/edgeR.results_old_tumor_rec_vs_no_rec.csv")

#get genes expression data (best AUC is in 1% of gens)
selected_genes <- RF_res %>% dplyr::select(X,one_per) %>% dplyr::filter(one_per!= "NA") %>% dplyr::rename(Gene.symbol=X)

#find overlap with genes upregulated in old 
res1 <- res %>%dplyr::filter(logFC>0) %>% dplyr::filter(FDR<= 0.2) %>% dplyr::select(Gene.symbol)

selected_genes<- inner_join(selected_genes, res1, by="Gene.symbol")
rownames(selected_genes) <- selected_genes$Gene.symbol

mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

subset_counts <- mycounts[rownames(selected_genes),]

gene_expression <- subset_counts
#get genes only from tumor samples 
gene_expression <- gene_expression %>% dplyr::select(starts_with("NYU"))
#save genes list 
write.csv(gene_expression, file = "risk_score_genes_from_NYU_early_stage_tumor_upregulated_in_old_Wtih_rec.csv")
#normalize genes counts by adding 1 and log2 
x <- log2(gene_expression+1)

#build individual risk score for every patient and every gene
risk_scores <- x * selected_genes$one_per

#transpose so every subject is a row 
risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
RNA_data_tumor
RNA_data_tumor$final_risk_score <- risk_scores_t$final_risk_score
RNA_data_tumor$risk_group <- risk_scores_t$risk_group
#use patients data 
RNA_data_tumor

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- RNA_data_tumor

#search for columns to keep 
metadata$Progression
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

##### check if the score give differnt results in lung samples 
#add this to your metadata 
z <- RNA_data_lung %>% dplyr::filter(Subject_ID2 !="634") %>% dplyr::filter(Subject_ID2 !="830")
z$final_risk_score <- risk_scores_t$final_risk_score
z$risk_group <- risk_scores_t$risk_group
#use patients data 
z

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- z

#search for columns to keep 
metadata$Progression
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)








############################ Approach 2, using tumor samples with best AUC and overlap with public genes assocaited with older age ###########
#read RF results 
RF_res <- read.csv(file = "RF/RF_results_NYU_early_stage_Tumor_samples.csv")

#get genes list of old paients associated with aging in public datasets 
genes_list_1 <- read.csv(file = "saul.cells.gene.list.csv")
genes_list_2 <- read.csv(file = "genes_associated_with_age_peters_et_al.csv")
#combine both lists and keep distinct only 
genes_list <- bind_rows(genes_list_1, genes_list_2)
genes_list <- genes_list %>% distinct(., .keep_all = TRUE) ##### results in 2532 unique genes associated with old age 

#get genes expression data (best AUC is in 1% of gens)
selected_genes <- RF_res %>% dplyr::select(X,one_per) %>% dplyr::filter(one_per!= "NA") %>% dplyr::rename(Gene=X)

#find overlap with public genes (which keep only 4 gens )
selected_genes<- inner_join(selected_genes, genes_list, by="Gene")
rownames(selected_genes) <- selected_genes$Gene

mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

subset_counts <- mycounts[rownames(selected_genes),]

gene_expression <- subset_counts
#get genes only from tumor samples 
gene_expression <- gene_expression %>% dplyr::select(starts_with("NYU"))
#save genes list 
write.csv(gene_expression, file = "risk_score_genes_from_NYU_early_stage_tumor_overlapped_with_public_genes.csv")
#normalize genes counts by adding 1 and log2 
x <- log2(gene_expression+1)

#build individual risk score for every patient and every gene
risk_scores <- x * selected_genes$one_per

#transpose so every subject is a row 
risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
RNA_data_tumor
RNA_data_tumor$final_risk_score <- risk_scores_t$final_risk_score
RNA_data_tumor$risk_group <- risk_scores_t$risk_group
#use patients data 
RNA_data_tumor

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- RNA_data_tumor

#search for columns to keep 
metadata$Progression
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)





############################ Approach 3, run a new classifer using genes upregulated in old , tumor, recu ###########
#read edgeR results 
#get genes list of old paients associated with recu
res <- read.csv(file = "Results/RNA/edgeR.results_old_tumor_rec_vs_no_rec.csv")


#get genes list of old assocaited with recureence only  
res <- res %>% dplyr::filter(logFC>0) %>% dplyr::filter(FDR<=0.2)
res <- res$Gene.symbol

#run new classifier 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

#load genes dataset 
mycounts

#Order Count Data by SampleID and replace the X before each name 
colnames(mycounts) <- gsub("X", "", colnames(mycounts))
mycounts <- mycounts [, order(colnames(mycounts))]
mycounts <- mycounts %>% dplyr::select(starts_with("NYU"))

#Confirm Sample IDs match for Count and Meta Data
table(colnames(mycounts)==as.character(RNA_data_tumor$RNA_ID))
#keep only genes of intersts 
mycounts <- mycounts[res,]
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
d1 = data.frame(lapply(mycounts, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(mycounts))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)

#Convert Model Variable into Factor
RNA_data_tumor$Sample_Type_Involved <- as.factor(RNA_data_tumor$Sample_Type_Involved)
RNA_data_tumor$Progression_Lab_Inv <- as.factor(RNA_data_tumor$Progression_Lab_Inv)

dds <- DESeqDataSetFromMatrix(countData = d1, colData = RNA_data_tumor, design = ~ Progression_Lab_Inv)

#Normalization Step 
dds <- estimateSizeFactors(dds)
genes <- mycounts 

#transpose
genes.transposed <- as.data.frame(t(genes))


#get metadata 
metadata.for.RF <- RNA_data_tumor

#be sure to include the samples needed 
genes.transposed<- genes.transposed %>% 
  dplyr::filter(rownames(genes.transposed) %in% rownames(metadata.for.RF))

#define outcome 
outcome <- as.factor(metadata.for.RF$Progression_Lab)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data_complete, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)

# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

group_enrich

Gini$enrich_group <- group_enrich

#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini 

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
round(0.01*146)
Genes.1.per <- Gini %>% 
  dplyr::slice(1:1)

#top 5%
round(0.05*146)
Genes.5.per <- Gini %>% 
  dplyr::slice(1:7)

#top 10%
round(0.1*146)
Genes.10.per <- Gini %>% 
  dplyr::slice(1:15)

#top 20%
round(0.2*146)
Genes.20.per <- Gini %>% 
  dplyr::slice(1:29)

#top 50%
round(0.5*146)
Genes.50.per <- Gini %>% 
  dplyr::slice(1:73)

#top 75%
round(0.75*146)
Genes.75.per <- Gini %>% 
  dplyr::slice(1:110)

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [2:146] <- NA
Ginidf.to.save$five_per [8:146] <- NA
Ginidf.to.save$ten_per [16:146] <- NA
Ginidf.to.save$twent_per [30:146] <- NA
Ginidf.to.save$fifty_per [74:146] <- NA
Ginidf.to.save$sevent_fiv_per [111:146] <- NA

write.csv(Ginidf.to.save, file = "RF/RF_results_NYU_early_stage_Tumor_samples_using_genes_upreg_in_old_rec.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF/Figures/roc.plot.NYU_early_stage_Tumor_samples_100_per_using_genes_upreg_in_old_rec.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_Stage_Tumor_samples_using_genes_upreg_in_old_rec_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_Stage_Tumor_samples_using_genes_upreg_in_old_rec_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_stage_Tumor_samples_using_genes_upreg_in_old_rec_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_stage_Tumor_samples_using_genes_upreg_in_old_rec_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/FIgures/roc.plot.NYU_early_stage_Tumor_samples_using_genes_upreg_in_old_rec_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_stage_Tumor_samples_using_genes_upreg_in_old_rec_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


############ Best AUC in 20% of genes 

#### build risk score 

#get genes expression data (best AUC is in 1% of gens)
selected_genes <- Genes.20.per %>% dplyr::select(Gini)

mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

subset_counts <- mycounts[rownames(selected_genes),]

gene_expression <- subset_counts
#get genes only from tumor samples 
gene_expression <- gene_expression %>% dplyr::select(starts_with("NYU"))
#save genes list 
write.csv(gene_expression, file = "risk_score_genes_from_NYU_early_stage_tumor_using_genes_upreg_in_old_Recu_as_predictors.csv")
#normalize genes counts by adding 1 and log2 
x <- log2(gene_expression+1)

#build individual risk score for every patient and every gene
risk_scores <- x * selected_genes$Gini

#transpose so every subject is a row 
risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
RNA_data_tumor
RNA_data_tumor$final_risk_score <- risk_scores_t$final_risk_score
RNA_data_tumor$risk_group <- risk_scores_t$risk_group
#use patients data 
RNA_data_tumor

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- RNA_data_tumor

#search for columns to keep 
metadata$Progression
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

pdf(file = "Figures/RNA/KM_early_stage_NYU_tumor_using_genes_upreg_in_old_Rec_as_predictors.pdf", width = 14, height = 16)
survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)
dev.off()





















########################### Risk score in NYU early stage, lung tissue only#######
###########################

#read RF results 
RF_res <- read.csv(file = "RF/RF_results_NYU_early_stage_lung_samples.csv")

### will try differnt approached to develop the score: 
################ 1) using genes with best AUC from RF results that used lung samples for analysis and getting only genes enriched in old patients with recu
################ 2) using genes with best AUC from RF results that overlap with genes published in public (2 to use: Peters et al and Cells 2021)
################# 3) run a new classifier using genes upregulated in old only and assocaited with recurrence 


############################ Approach 1, using lung samples with best AUC ###########

#get genes list of old paients associated with recu
res <- read.csv(file = "Results/RNA/edgeR.results_old_lung_rec_vs_no_rec.csv")

#get genes expression data (best AUC is in 1% of gens)
selected_genes <- RF_res %>% dplyr::select(X,one_per) %>% dplyr::filter(one_per!= "NA") %>% dplyr::rename(Gene.symbol=X)

#find overlap with genes upregulated in old 
res1 <- res %>%dplyr::filter(logFC>0) %>% dplyr::filter(FDR<= 0.2) %>% dplyr::select(Gene.symbol)

selected_genes<- inner_join(selected_genes, res1, by="Gene.symbol")
rownames(selected_genes) <- selected_genes$Gene.symbol

mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

subset_counts <- mycounts[rownames(selected_genes),]

gene_expression <- subset_counts
#get genes only from lung samples 
gene_expression <- gene_expression %>% dplyr::select(-starts_with("NYU"))
#save genes list 
write.csv(gene_expression, file = "risk_score_genes_from_NYU_early_stage_lung_upregulated_in_old_Wtih_rec.csv")
#normalize genes counts by adding 1 and log2 
x <- log2(gene_expression+1)

#build individual risk score for every patient and every gene
risk_scores <- x * selected_genes$one_per

#transpose so every subject is a row 
risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
RNA_data_lung
RNA_data_lung$final_risk_score <- risk_scores_t$final_risk_score
RNA_data_lung$risk_group <- risk_scores_t$risk_group
#use patients data 
RNA_data_lung

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- RNA_data_lung

#search for columns to keep 
metadata$Progression
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

##### check if the score give differnt results in tumor samples 
#add this to your metadata 
z <- RNA_data_tumor
risk_scores_t_filt <- risk_scores_t %>% dplyr::mutate(Subject_ID2=rownames(.)) %>%  dplyr::filter(Subject_ID2 !="X634") %>% dplyr::filter(Subject_ID2 !="X830")
z$final_risk_score <- risk_scores_t_filt$final_risk_score
z$risk_group <- risk_scores_t_filt$risk_group
#use patients data 
z
#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- z

#search for columns to keep 
metadata$Progression
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#validate in TCGA stage I 
#get clinical metadata of tcga stage I (n= 325 )
tcga_metadata_stage_I

#get the cont table accordingly 
tcga_counts_stage_I 

ncol(tcga_counts_stage_I) == nrow(tcga_metadata_stage_I)

# get risk score genes (used form genes shared with peters et al) should be 18 genes 
risk_score_genes <- rownames(gene_expression)

#subset those genes from TCGA cohort 
tcga_subset_genes <- tcga_counts_stage_I[risk_score_genes,]

#normalize genes counts by adding 1 and log2 
x <- log2(tcga_subset_genes+1)

#build individual risk score for every patient and every gene 
risk_scores <- x * selected_genes$one_per

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
tcga_metadata_stage_I$final_risk_score <- risk_scores_t$final_risk_score
tcga_metadata_stage_I$risk_group <- risk_scores_t$risk_group

#see if ther eis a difference in recurrence in low vs high risk groups 
#use patients data 
tcga_metadata_stage_I

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)





















############################ Approach 2, using lung samples with best AUC and overlap with public genes assocaited with older age ###########
#read RF results 
RF_res <- read.csv(file = "RF/RF_results_NYU_early_stage_lung_samples.csv")

#get genes list of old paients associated with aging in public datasets 
genes_list_1 <- read.csv(file = "saul.cells.gene.list.csv")
genes_list_2 <- read.csv(file = "genes_associated_with_age_peters_et_al.csv")
#combine both lists and keep distinct only 
genes_list <- bind_rows(genes_list_1, genes_list_2)
genes_list <- genes_list %>% distinct(., .keep_all = TRUE) ##### results in 2532 unique genes associated with old age 

#get genes expression data (best AUC is in 1% of gens)
selected_genes <- RF_res %>% dplyr::select(X,one_per) %>% dplyr::filter(one_per!= "NA") %>% dplyr::rename(Gene=X)

#find overlap with public genes (which keep only 4 gens )
selected_genes<- inner_join(selected_genes, genes_list, by="Gene")
rownames(selected_genes) <- selected_genes$Gene

mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

subset_counts <- mycounts[rownames(selected_genes),]

gene_expression <- subset_counts
#get genes only from lung samples 
gene_expression <- gene_expression %>% dplyr::select(-starts_with("NYU"))
#save genes list 
write.csv(gene_expression, file = "risk_score_genes_from_NYU_early_stage_lung_overlapped_with_public_genes.csv")
#normalize genes counts by adding 1 and log2 
x <- log2(gene_expression+1)

#build individual risk score for every patient and every gene
risk_scores <- x * selected_genes$one_per

#transpose so every subject is a row 
risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
RNA_data_lung
RNA_data_lung$final_risk_score <- risk_scores_t$final_risk_score
RNA_data_lung$risk_group <- risk_scores_t$risk_group
#use patients data 
RNA_data_lung

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- RNA_data_lung

#search for columns to keep 
metadata$Progression
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


######### Validation in tumor samples 
#add this to your metadata 
z <- RNA_data_tumor
risk_scores_t_filt <- risk_scores_t %>% dplyr::mutate(Subject_ID2=rownames(.)) %>%  dplyr::filter(Subject_ID2 !="X634") %>% dplyr::filter(Subject_ID2 !="X830")
z$final_risk_score <- risk_scores_t_filt$final_risk_score
z$risk_group <- risk_scores_t_filt$risk_group
#use patients data 
z
#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- z

#search for columns to keep 
metadata$Progression
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#validate in TCGA stage I 
#get clinical metadata of tcga stage I (n= 325 )
tcga_metadata_stage_I

#get the cont table accordingly 
tcga_counts_stage_I 

ncol(tcga_counts_stage_I) == nrow(tcga_metadata_stage_I)

# get risk score genes (used form genes shared with peters et al) should be 18 genes 
risk_score_genes <- rownames(gene_expression)

#subset those genes from TCGA cohort 
tcga_subset_genes <- tcga_counts_stage_I[risk_score_genes,]

#normalize genes counts by adding 1 and log2 
x <- log2(tcga_subset_genes+1)

#build individual risk score for every patient and every gene 
risk_scores <- x * selected_genes$one_per

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
tcga_metadata_stage_I$final_risk_score <- risk_scores_t$final_risk_score
tcga_metadata_stage_I$risk_group <- risk_scores_t$risk_group

#see if ther eis a difference in recurrence in low vs high risk groups 
#use patients data 
tcga_metadata_stage_I

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)





############################ Approach 3, run a new classifer using genes upregulated in old , lung, recu ###########
#read edgeR results 
#get genes list of old paients associated with recu
res <- read.csv(file = "Results/RNA/edgeR.results_old_lung_rec_vs_no_rec.csv")


#get genes list of old assocaited with recureence only  
res <- res %>% dplyr::filter(logFC>0) %>% dplyr::filter(FDR<=0.2)
res <- res$Gene.symbol

#run new classifier 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

#load genes dataset 
mycounts

#Order Count Data by SampleID and replace the X before each name 
colnames(mycounts) <- gsub("X", "", colnames(mycounts))
mycounts <- mycounts [, order(colnames(mycounts))]
mycounts <- mycounts %>% dplyr::select(-starts_with("NYU"))

#Confirm Sample IDs match for Count and Meta Data
table(colnames(mycounts)==as.character(RNA_data_lung$RNA_ID))
#keep only genes of intersts 
mycounts <- mycounts[res,]
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
d1 = data.frame(lapply(mycounts, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(mycounts))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)

#Convert Model Variable into Factor
RNA_data_lung$Sample_Type_Involved <- as.factor(RNA_data_lung$Sample_Type_Involved)
RNA_data_lung$Progression_Lab_Inv <- as.factor(RNA_data_lung$Progression_Lab_Inv)

dds <- DESeqDataSetFromMatrix(countData = d1, colData = RNA_data_lung, design = ~ Progression_Lab_Inv)

#Normalization Step 
dds <- estimateSizeFactors(dds)
genes <- mycounts 

#transpose
genes.transposed <- as.data.frame(t(genes))


#get metadata 
metadata.for.RF <- RNA_data_lung

#be sure to include the samples needed 
genes.transposed<- genes.transposed %>% 
  dplyr::filter(rownames(genes.transposed) %in% rownames(metadata.for.RF))

#define outcome 
outcome <- as.factor(metadata.for.RF$Progression_Lab)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data_complete, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)

# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

group_enrich

Gini$enrich_group <- group_enrich

#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini 

#from here subset genes of increasing percentage so you will use later to fit the model 
nrow(Gini.100.per)
#top 1%
z <- round(0.01*nrow(Gini.100.per))
Genes.1.per <- Gini %>% dplyr::slice(1:z)

#top 5%
z <-round(0.05*nrow(Gini.100.per))
Genes.5.per <- Gini %>% dplyr::slice(1:z)

#top 10%
z <-round(0.1*nrow(Gini.100.per))
Genes.10.per <- Gini %>% dplyr::slice(1:z)

#top 20%
z <-round(0.2*nrow(Gini.100.per))
Genes.20.per <- Gini %>% dplyr::slice(1:z)

#top 50%
z <-round(0.5*nrow(Gini.100.per))
Genes.50.per <- Gini %>% dplyr::slice(1:z)

#top 75%
z <-round(0.75*nrow(Gini.100.per))
Genes.75.per <- Gini %>% dplyr::slice(1:z)

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [(nrow(Genes.1.per)+1):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [(nrow(Genes.5.per)+1):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [(nrow(Genes.10.per)+1):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [(nrow(Genes.20.per)+1):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [(nrow(Genes.50.per)+1):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [(nrow(Genes.75.per)+1):nrow(Ginidf.to.save)] <- NA

write.csv(Ginidf.to.save, file = "RF/RF_results_NYU_early_stage_lung_samples_using_genes_upreg_in_old_rec.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF/Figures/roc.plot.NYU_early_stage_lung_samples_100_per_using_genes_upreg_in_old_rec.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_Stage_lung_samples_using_genes_upreg_in_old_rec_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_Stage_lung_samples_using_genes_upreg_in_old_rec_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_stage_lung_samples_using_genes_upreg_in_old_rec_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_stage_lung_samples_using_genes_upreg_in_old_rec_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/FIgures/roc.plot.NYU_early_stage_lung_samples_using_genes_upreg_in_old_rec_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per))

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = rf.data, trControl=Control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, type = "prob")

pred1 <- data.frame(predictions)

# to get pred vs observations for every row 
pred <- fit$predicted
obs <- fit$y

#now build a data frame for ROC curve
pred.df <- pred1 
pred.df$pred <- pred
pred.df$obs <- obs
pred.df <- data.frame(pred.df)
colnames(pred.df)

#to get a glimpse on sens and spec of the model:
cm <- confusionMatrix(data = pred.df$pred, reference = pred.df$obs,  mode="everything",  positive = "Recurrence" )

#now calculate sensitivity and spec. 
roc <- roc(ifelse(pred.df$obs=="Recurrence", "Recurrence", "non-Recurrence"), as.numeric(pred.df$Recurrence))

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF/Figures/roc.plot.NYU_early_stage_lung_samples_using_genes_upreg_in_old_rec_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


############ Best AUC in 20% of genes 

#### build risk score 

#get genes expression data (best AUC is in 1% of gens)
selected_genes <- Genes.20.per %>% dplyr::select(Gini)

mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

subset_counts <- mycounts[rownames(selected_genes),]

gene_expression <- subset_counts
#get genes only from lung samples 
gene_expression <- gene_expression %>% dplyr::select(-starts_with("NYU"))
#save genes list 
write.csv(gene_expression, file = "risk_score_genes_from_NYU_early_stage_lung_using_genes_upreg_in_old_Recu_as_predictors.csv")
#normalize genes counts by adding 1 and log2 
x <- log2(gene_expression+1)

#build individual risk score for every patient and every gene
risk_scores <- x * selected_genes$Gini

#transpose so every subject is a row 
risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
RNA_data_lung
RNA_data_lung$final_risk_score <- risk_scores_t$final_risk_score
RNA_data_lung$risk_group <- risk_scores_t$risk_group
#use patients data 
RNA_data_lung

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- RNA_data_lung

#search for columns to keep 
metadata$Progression
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

########### Vlidate in all NYU cohort 


#get genes expression data (best AUC is in 1% of gens)
selected_genes <- Genes.20.per %>% dplyr::select(Gini)

mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

subset_counts <- mycounts[rownames(selected_genes),]

gene_expression <- subset_counts

#save genes list 
write.csv(gene_expression, file = "risk_score_genes_from_NYU_early_stage_all_samples_using_lung_genes_upreg_in_old_Recu_as_predictors.csv")
#normalize genes counts by adding 1 and log2 
x <- log2(gene_expression+1)

#build individual risk score for every patient and every gene
risk_scores <- x * selected_genes$Gini

#transpose so every subject is a row 
risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
RNA.data <- bind_rows(RNA_data_tumor, RNA_data_lung)
RNA.data$final_risk_score <- risk_scores_t$final_risk_score
RNA.data$risk_group <- risk_scores_t$risk_group
#use patients data 
RNA.data

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- RNA.data

#search for columns to keep 
metadata$Progression
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

####### validate in tumor samples only 

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- RNA.data %>% dplyr::filter(Sample_Type_Involved=="Lung.Tissue.In")

#search for columns to keep 
metadata$Progression
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)





########## Validation in all stage I TCGA  

#get clinical metadata of tcga stage I (n= 325 )
tcga_metadata_stage_I

#get the cont table accordingly 
tcga_counts_stage_I 

ncol(tcga_counts_stage_I) == nrow(tcga_metadata_stage_I)

# get risk score genes (used form genes shared with peters et al) should be 18 genes 
risk_score_genes <- rownames(gene_expression)

#subset those genes from TCGA cohort 
tcga_subset_genes <- tcga_counts_stage_I[risk_score_genes,]

#normalize genes counts by adding 1 and log2 
x <- log2(tcga_subset_genes+1)

#build individual risk score for every patient and every gene 
risk_scores <- x * selected_genes$Gini

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
tcga_metadata_stage_I$final_risk_score <- risk_scores_t$final_risk_score
tcga_metadata_stage_I$risk_group <- risk_scores_t$risk_group

#see if ther eis a difference in recurrence in low vs high risk groups 
#use patients data 
tcga_metadata_stage_I

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#vlidate in TCGA stage I young 
#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I %>% dplyr::filter(age_3_grps=="young")

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

#validation., TCGAstage I middle age 

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I %>% dplyr::filter(age_3_grps=="middle")

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#validate in old only 

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I %>% dplyr::filter(age_3_grps=="old")

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

####### Vlidate in TCGA tumor only 

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I %>% dplyr::filter(sample_type=="Primary Tumor")

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

########### repeat for tumro according to age groups 



#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I %>% dplyr::filter(sample_type=="Primary Tumor") %>% dplyr::filter(age_3_grps=="young")

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I %>% dplyr::filter(sample_type=="Primary Tumor")%>% dplyr::filter(age_3_grps=="middle")

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I %>% dplyr::filter(sample_type=="Primary Tumor")%>% dplyr::filter(age_3_grps=="old")

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

##### repeat in lung samples 


#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I %>% dplyr::filter(sample_type=="Solid Tissue Normal")

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

########### repeat for lung according to age groups 



#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I %>% dplyr::filter(sample_type=="Solid Tissue Normal") %>% dplyr::filter(age_3_grps=="young")

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I %>% dplyr::filter(sample_type=="Solid Tissue Normal")%>% dplyr::filter(age_3_grps=="middle")

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- tcga_metadata_stage_I %>% dplyr::filter(sample_type=="Solid Tissue Normal")%>% dplyr::filter(age_3_grps=="old")

#search for columns to keep 
#death give mortality status 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)



##################################################################################
##################################################################################
##################################################################################
##################################################################################






################ Elastic net model for NYU advanced stage using genes upreg in old mortality  #####################
# Load the necessary library
library(glmnet)

# Set the seed for reproducibility
set.seed(1234)

# Prepare your data
# read genes count 
mycounts_advanced

# Extract the expression values for the selected genes (in this case genes assocaitede with mortality in old people )
res <- read.csv(file = "Results/RNA/edgeR.results_NYU_advanced_stage_old_age_extremes__two_y_mort.csv")

#sort results by FDR and filter for FDR < 0.2 and logFC > 0 (assocaited with mortality)
sig_res <- res %>% dplyr::filter(logFC >0) %>%dplyr::filter(FDR <= 0.2)

#get genes list 
selected_genes <- sig_res %>% dplyr::select(Gene.symbol, logFC)

gene_expression_subset <- mycounts_advanced[selected_genes$Gene.symbol, ]

# Prepare your outcome variable (e.g., clinical outcome)
clinical_outcome <- NYU_adv_metadata_filtered$death

# Split the data into training and testing sets
train_index <- sample(1:length(clinical_outcome), round(0.7 * length(clinical_outcome)))
train_data <- gene_expression_subset[, train_index]
train_outcome <- clinical_outcome[train_index]
test_data <- gene_expression_subset[, -train_index]
test_outcome <- clinical_outcome[-train_index]

# Perform Elastic Net using cross-validation to select the optimal lambda value
cv_model <- cv.glmnet(x = t(train_data), y = train_outcome, family = "binomial", alpha = 0.5)

# Select the lambda value with the minimum mean cross-validated error
opt_lambda <- cv_model$lambda.min

# Fit the final Elastic Net model with the selected lambda
final_model <- glmnet(x = t(train_data), y = train_outcome, family = "binomial", alpha = 0.5, lambda = opt_lambda)

# Get the coefficients of the selected genes
selected_genes_coef <- coef(final_model)

# Remove the intercept term
selected_genes_coef <- selected_genes_coef[-1, ]

# Sort the coefficients by magnitude
sorted_genes_coef <- sort(abs(selected_genes_coef), decreasing = TRUE)

#write resutls 
write.csv(sorted_genes_coef, file = "elastic_net/results/NYU_adv_stage_EN_res_using_genes_upreg_in_old_mort.csv")

#develop the risk score 
#normalize genes counts by adding 1 and log2 
x <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- x * selected_genes_coef

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
NYU_adv_metadata_filtered$final_risk_score <- risk_scores_t$final_risk_score
NYU_adv_metadata_filtered$risk_group <- risk_scores_t$risk_group

#check outcome 
ggplot(NYU_adv_metadata_filtered, aes(x=death, y=final_risk_score))+
  geom_boxplot()

ggplot(NYU_adv_metadata_filtered, aes(x=two_y_mort, y=final_risk_score))+
  geom_boxplot()

#check survival 
metadata <- NYU_adv_metadata_filtered

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$OS_days 

###plot for death 
survival.data <- metadata[, c("OS_days","death", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#validation in differnt age groups: 
#young 
#check survival 
metadata <- NYU_adv_metadata_filtered %>% dplyr::filter(age_3_grps=="young")

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$OS_days 

###plot for death 
survival.data <- metadata[, c("OS_days","death", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#middle 
metadata <- NYU_adv_metadata_filtered %>% dplyr::filter(age_3_grps=="middle")

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$OS_days 

###plot for death 
survival.data <- metadata[, c("OS_days","death", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#old 
metadata <- NYU_adv_metadata_filtered %>% dplyr::filter(age_3_grps=="old")

#search for columns to keep 
#death give mortality status 
metadata$death
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$OS_days 

###plot for death 
survival.data <- metadata[, c("OS_days","death", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot
#validation in TCGA adv stage 

#develop risk score 
#get counts 
tcga_subset_counts <- tcga_counts_advanced_stage[rownames(gene_expression_subset),]

#normalize genes counts by adding 1 and log2 
x <- log2(tcga_subset_counts+1)

#build individual risk score for every patient and every gene 
risk_scores <- x * selected_genes_coef

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
tcga_metadata_advanced_stage$final_risk_score <- risk_scores_t$final_risk_score
tcga_metadata_advanced_stage$risk_group <- risk_scores_t$risk_group

#all 
metadata <- tcga_metadata_advanced_stage 

#search for columns to keep 
#death give mortality status 
metadata$vital_status
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#young 
metadata <- tcga_metadata_advanced_stage %>% filter(age_3_grps=="young")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#middle 
metadata <- tcga_metadata_advanced_stage %>% filter(age_3_grps=="middle")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#old 
metadata <- tcga_metadata_advanced_stage %>% filter(age_3_grps=="old")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

########################TCGA adv stage tumor 
#all 
metadata <- tcga_metadata_advanced_stage %>% filter(sample_type=="Primary Tumor")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#young 
metadata <- tcga_metadata_advanced_stage %>% filter(age_3_grps=="young") %>% filter(sample_type=="Primary Tumor")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#middle 
metadata <- tcga_metadata_advanced_stage %>% filter(age_3_grps=="middle") %>% filter(sample_type=="Primary Tumor")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#old 
metadata <- tcga_metadata_advanced_stage %>% filter(age_3_grps=="old") %>% filter(sample_type=="Primary Tumor")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot




###############3#TCGA adv stage lung 
#all 
metadata <- tcga_metadata_advanced_stage %>% filter(sample_type=="Solid Tissue Normal")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#young 
metadata <- tcga_metadata_advanced_stage %>% filter(age_3_grps=="young") %>% filter(sample_type=="Solid Tissue Normal")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#middle 
metadata <- tcga_metadata_advanced_stage %>% filter(age_3_grps=="middle") %>% filter(sample_type=="Solid Tissue Normal")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#old 
metadata <- tcga_metadata_advanced_stage %>% filter(age_3_grps=="old") %>% filter(sample_type=="Solid Tissue Normal")

#search for columns to keep 
#death give mortality status 
metadata$vital_status
metadata$time <- metadata$days_to_death
metadata$time <- ifelse(is.na(metadata$time),  metadata$days_to_last_follow_up, metadata$time)

###plot for death 
survival.data <- metadata[, c("time","vital_status", "risk_group" )]
survival.data$vital_status <- ifelse(survival.data$vital_status=="Alive", 0, 1)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot












################################################################################
################################################################################
#################################################################################
################### Elastic Net nyu EARLY STAGE tumor samples ####################

# Load the necessary library
library(glmnet)

# Set the seed for reproducibility
set.seed(1234)

# Prepare your data
# read genes count 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

# Extract the expression values for the selected genes (in this case genes assocaitede with mortality in old people )
res <- read.csv(file = "Results/RNA/edgeR.results_old_tumor_rec_vs_no_rec.csv")

#sort results by FDR and filter for FDR < 0.2 and logFC > 0 (assocaited with mortality)
sig_res <- res %>% dplyr::filter(logFC >0) %>%dplyr::filter(FDR <= 0.2)

#get genes list 
selected_genes <- sig_res %>% dplyr::select(Gene.symbol, logFC)

gene_expression_subset <- mycounts[selected_genes$Gene.symbol, ]
gene_expression_subset <- gene_expression_subset %>% select(starts_with("NYU"))

# Prepare your outcome variable (e.g., clinical outcome)
clinical_outcome <- RNA_data_tumor$Progression

# Split the data into training and testing sets
train_index <- sample(1:length(clinical_outcome), round(0.7 * length(clinical_outcome)))
train_data <- gene_expression_subset[, train_index]
train_outcome <- clinical_outcome[train_index]
test_data <- gene_expression_subset[, -train_index]
test_outcome <- clinical_outcome[-train_index]

# Perform Elastic Net using cross-validation to select the optimal lambda value
cv_model <- cv.glmnet(x = t(train_data), y = train_outcome, family = "binomial", alpha = 0.5)

# Select the lambda value with the minimum mean cross-validated error
opt_lambda <- cv_model$lambda.min

# Fit the final Elastic Net model with the selected lambda
final_model <- glmnet(x = t(train_data), y = train_outcome, family = "binomial", alpha = 0.5, lambda = opt_lambda)

# Get the coefficients of the selected genes
selected_genes_coef <- coef(final_model)

# Remove the intercept term
selected_genes_coef <- selected_genes_coef[-1, ]

# Sort the coefficients by magnitude
sorted_genes_coef <- sort(abs(selected_genes_coef), decreasing = TRUE)

#write resutls 
write.csv(sorted_genes_coef, file = "elastic_net/results/NYU_early_stage_tumor_EN_res_using_genes_upreg_in_old_recu.csv")

#develop the risk score 
#normalize genes counts by adding 1 and log2 
x <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- x * selected_genes_coef

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
RNA_data_tumor$final_risk_score <- risk_scores_t$final_risk_score
RNA_data_tumor$risk_group <- risk_scores_t$risk_group

#check outcome 
ggplot(RNA_data_tumor, aes(x=Progression_Lab_Inv, y=final_risk_score))+
  geom_boxplot()

#check survival 
metadata <- RNA_data_tumor

#search for columns to keep 
#death give mortality status 
metadata$Progression
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$New_TTP 

###plot for death 
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#validation in differnt age groups: 
#young 
#check survival 
metadata <- RNA_data_tumor %>% dplyr::filter(age_group=="young")

#search for columns to keep 
#death give mortality status 
metadata$Progression
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$New_TTP 

###plot for death 
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot


#### old
#check survival 
metadata <- RNA_data_tumor %>% dplyr::filter(age_grp=="old")

#search for columns to keep 
#death give mortality status 
metadata$Progression
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$New_TTP 

###plot for death 
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)
survival.plot

#validation in TCGA stage I

#develop risk score 
#get counts 
tcga_subset_counts <- tcga_counts_stage_I[rownames(gene_expression_subset),]

#normalize genes counts by adding 1 and log2 
x <- log2(tcga_subset_counts+1)

#build individual risk score for every patient and every gene 
risk_scores <- x * selected_genes_coef

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
tcga_metadata_stage_I$final_risk_score <- risk_scores_t$final_risk_score
tcga_metadata_stage_I$risk_group <- risk_scores_t$risk_group

#all 
metadata <- tcga_metadata_stage_I 

#search for columns to keep 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#young 
metadata <- tcga_metadata_stage_I %>% filter(age_3_grps=="young")


#search for columns to keep 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#middle 
metadata <- tcga_metadata_stage_I %>% filter(age_3_grps=="middle")


#search for columns to keep 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot



#old 
metadata <- tcga_metadata_stage_I %>% filter(age_3_grps=="old")


#search for columns to keep 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

################### Very few are lung samples, therefore will not split into tumor and lung 




################################################################################
################################################################################
#################################################################################
################### Elastic Net nyu EARLY STAGE lung samples ####################

# Load the necessary library
library(glmnet)

# Set the seed for reproducibility
set.seed(1234)

# Prepare your data
# read genes count 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

# Extract the expression values for the selected genes (in this case genes assocaitede with mortality in old people )
res <- read.csv(file = "Results/RNA/edgeR.results_old_lung_rec_vs_no_rec.csv")

#sort results by FDR and filter for FDR < 0.2 and logFC > 0 (assocaited with mortality)
sig_res <- res %>% dplyr::filter(logFC >0) %>%dplyr::filter(FDR <= 0.2)

#get genes list 
selected_genes <- sig_res %>% dplyr::select(Gene.symbol, logFC)

gene_expression_subset <- mycounts[selected_genes$Gene.symbol, ]
gene_expression_subset <- gene_expression_subset %>% select(-starts_with("NYU"))

# Prepare your outcome variable (e.g., clinical outcome)
clinical_outcome <- RNA_data_lung$Progression

# Split the data into training and testing sets
train_index <- sample(1:length(clinical_outcome), round(0.7 * length(clinical_outcome)))
train_data <- gene_expression_subset[, train_index]
train_outcome <- clinical_outcome[train_index]
test_data <- gene_expression_subset[, -train_index]
test_outcome <- clinical_outcome[-train_index]

# Perform Elastic Net using cross-validation to select the optimal lambda value
cv_model <- cv.glmnet(x = t(train_data), y = train_outcome, family = "binomial", alpha = 0.5)

# Select the lambda value with the minimum mean cross-validated error
opt_lambda <- cv_model$lambda.min
plot(cv_model)

# Fit the final Elastic Net model with the selected lambda
final_model <- glmnet(x = t(train_data), y = train_outcome, family = "binomial", alpha = 0.5, lambda = opt_lambda)

# Get the coefficients of the selected genes
selected_genes_coef <- coef(final_model)

# Remove the intercept term
selected_genes_coef <- selected_genes_coef[-1, ]

# Sort the coefficients by magnitude
sorted_genes_coef <- sort(abs(selected_genes_coef), decreasing = TRUE)

#write resutls 
write.csv(sorted_genes_coef, file = "elastic_net/results/NYU_early_stage_lung_EN_res_using_genes_upreg_in_old_recu.csv")

#develop the risk score 
#normalize genes counts by adding 1 and log2 
x <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- x * selected_genes_coef

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
RNA_data_lung$final_risk_score <- risk_scores_t$final_risk_score
RNA_data_lung$risk_group <- risk_scores_t$risk_group

#check outcome 
ggplot(RNA_data_lung, aes(x=Progression_Lab_Inv, y=final_risk_score))+
  geom_boxplot()+stat_compare_means()

#check survival 
metadata <- RNA_data_lung

#search for columns to keep 
#death give mortality status 
metadata$Progression
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$New_TTP 

###plot for death 
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#validation in differnt age groups: 
#young 
#check survival 
metadata <- RNA_data_lung %>% dplyr::filter(age_group=="young")

#search for columns to keep 
#death give mortality status 
metadata$Progression
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$New_TTP 

###plot for death 
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot


#### old
#check survival 
metadata <- RNA_data_tumor %>% dplyr::filter(age_grp=="old")

#search for columns to keep 
#death give mortality status 
metadata$Progression
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$New_TTP 

###plot for death 
survival.data <- metadata[, c("New_TTP","Progression", "risk_group" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to risk score",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)
survival.plot

#validation in TCGA stage I

#develop risk score 
#get counts 
tcga_subset_counts <- tcga_counts_stage_I[rownames(gene_expression_subset),]

#normalize genes counts by adding 1 and log2 
x <- log2(tcga_subset_counts+1)

#build individual risk score for every patient and every gene 
risk_scores <- x * selected_genes_coef

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

#put into df 
risk_scores_t <- as.data.frame(risk_scores_t)

risk_scores_t$final_risk_score <- final_risk_score


#calculate median risk score 
median(risk_scores_t$final_risk_score)

#categorize paitents according to median risk score 
risk_scores_t$risk_group <- ifelse(risk_scores_t$final_risk_score < median(risk_scores_t$final_risk_score), "low", "high")

#add this to your metadata 
tcga_metadata_stage_I$final_risk_score <- risk_scores_t$final_risk_score
tcga_metadata_stage_I$risk_group <- risk_scores_t$risk_group

#all 
metadata <- tcga_metadata_stage_I 

#search for columns to keep 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#young 
metadata <- tcga_metadata_stage_I %>% filter(age_3_grps=="young")


#search for columns to keep 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot

#middle 
metadata <- tcga_metadata_stage_I %>% filter(age_3_grps=="middle")


#search for columns to keep 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot



#old 
metadata <- tcga_metadata_stage_I %>% filter(age_3_grps=="old")


#search for columns to keep 
metadata$DFS_STATUS
#OS_days give time to death or last follow up in days, should remove days for this analysis  
metadata$time <- as.numeric(metadata$DFS_MONTHS)*30.4167

###plot for death 
survival.data <- metadata[, c("time","DFS_STATUS", "risk_group" )]
survival.data$DFS_STATUS <- ifelse(survival.data$DFS_STATUS=="Recurrence", 1, 0)
#rename the new df 
colnames(survival.data) <- c("time", "status", "risk_group")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$risk_group <- as.factor(survival.data$risk_group)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(risk_group) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object
library(survival)
library(survminer)
library(survMisc)

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~risk_group, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("high", "low"), legend.title="Risk Score",  
                            palette=c("dodgerblue3", "goldenrod2"), size=1,
                            title="Kaplan-Meier Curve for Mortality According to risk score",
                            ylab="Overall Survival Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of death)",
                            cumcensor.title = "Cumulative number of censored subjects"
)

survival.plot























################################################################################
################################################################################
################################################################################
################## IPA heatmap NYU early stage and TCGA stage I age extremes ####################

IPA_res <- read.csv("IPA/IPA_comparison_early_stage_NYU_vs_stage_I_TCGA_age_extremes.csv")

#get max and min values 
max(IPA_res$TCGA_tumor_old, na.rm = TRUE)
min(IPA_res$TCGA_tumor_old, na.rm = TRUE)
max(IPA_res$TCGA_tumor_young, na.rm = TRUE)
min(IPA_res$TCGA_tumor_young, na.rm = TRUE)
max(IPA_res$TCGA_lung_old, na.rm = TRUE)
min(IPA_res$TCGA_lung_old, na.rm = TRUE)
max(IPA_res$TCGA_lung_young, na.rm = TRUE)
min(IPA_res$TCGA_lung_young, na.rm = TRUE)
max(IPA_res$NYU_tumor_old, na.rm = TRUE)
min(IPA_res$NYU_tumor_old, na.rm = TRUE)
max(IPA_res$NYU_tumor_young, na.rm = TRUE)
min(IPA_res$NYU_tumor_young, na.rm = TRUE)
max(IPA_res$NYU_lung_old, na.rm = TRUE)
min(IPA_res$NYU_lung_old, na.rm = TRUE)
max(IPA_res$NYU_lung_young, na.rm = TRUE)
min(IPA_res$NYU_lung_young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-3.71, 0, 3.873), c("blue", "white", "orange"))
col_fun(seq(-3.71, 0, 3.873))

#order by nyu old lung 
IPA_res <- IPA_res %>% arrange(desc(NYU_lung_old))
#select top 30 pathways 
IPA_res<- IPA_res %>% dplyr::slice(1:30)

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

# set order 
IPA_res_mat <- IPA_res_mat %>% dplyr::select(NYU_tumor_old, NYU_tumor_young, NYU_lung_old,
                                              NYU_lung_young, TCGA_tumor_old, TCGA_tumor_young, 
                                              TCGA_lung_old, TCGA_lung_young)
#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/IPA_comparison_early_stage_NYU_vs_stage_I_TCGA_age_extremes.pdf", height = 24, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(4, "cm"), height = unit(25, "cm"))
dev.off()

#check similarities between datasets of NYU early stage and tcga stage I . if p value < 0.05, then datasets are different. if p-value > 0.05 --> datasets are similar 
#tcga vs NYU tumor old
t.test(IPA_res$TCGA_tumor_old, IPA_res$NYU_tumor_old, alternative = "two.sided", na.action = na.omit) #p-value = 6.891e-05
t.test(IPA_res$TCGA_lung_old, IPA_res$NYU_tumor_old, alternative = "two.sided", na.action = na.omit) #p-value = 0.4445
t.test(IPA_res$TCGA_tumor_young, IPA_res$NYU_tumor_old, alternative = "two.sided", na.action = na.omit) #p-value =  0.1031
t.test(IPA_res$TCGA_lung_young, IPA_res$NYU_tumor_old, alternative = "two.sided", na.action = na.omit) #p-value = 0.5533

#tcga vs NYU lung old
t.test(IPA_res$TCGA_tumor_old, IPA_res$NYU_lung_old, alternative = "two.sided", na.action = na.omit) #p-value = 9.932e-14
t.test(IPA_res$TCGA_lung_old, IPA_res$NYU_lung_old, alternative = "two.sided", na.action = na.omit) #p-value= 0.1559
t.test(IPA_res$TCGA_tumor_young, IPA_res$NYU_lung_old, alternative = "two.sided", na.action = na.omit) #p-value = 2.534e-06
t.test(IPA_res$TCGA_lung_young, IPA_res$NYU_lung_old, alternative = "two.sided", na.action = na.omit) #p-value = 0.3314

#tcga vs NYU tumor young
t.test(IPA_res$TCGA_tumor_old, IPA_res$NYU_tumor_young, alternative = "two.sided", na.action = na.omit) #p-value = 1.819e-05
t.test(IPA_res$TCGA_lung_old, IPA_res$NYU_tumor_young, alternative = "two.sided", na.action = na.omit) #p-value = 0.8824
t.test(IPA_res$TCGA_tumor_young, IPA_res$NYU_tumor_young, alternative = "two.sided", na.action = na.omit) #p-value = 0.01676
t.test(IPA_res$TCGA_lung_young, IPA_res$NYU_tumor_young, alternative = "two.sided", na.action = na.omit) #p-value = 0.925

#tcga vs NYU lung young 
t.test(IPA_res$TCGA_tumor_old, IPA_res$NYU_lung_young, alternative = "two.sided", na.action = na.omit) #p-value = 0.7426
t.test(IPA_res$TCGA_lung_old, IPA_res$NYU_lung_young, alternative = "two.sided", na.action = na.omit) #p-value = 2.433e-05
t.test(IPA_res$TCGA_tumor_young, IPA_res$NYU_lung_young, alternative = "two.sided", na.action = na.omit) #p-value = 0.01212
t.test(IPA_res$TCGA_lung_young, IPA_res$NYU_lung_young, alternative = "two.sided", na.action = na.omit) #p-value = 0.002916




################## IPA heatmap NYU early stage and TCGA stage I median age ####################

IPA_res <- read.csv("IPA/IPA_comparison_early_stage_NYU_vs_stage_I_TCGA_median_age.csv")

#get max and min values 
max(IPA_res$TCGA_tumor_old, na.rm = TRUE)
min(IPA_res$TCGA_tumor_old, na.rm = TRUE)
max(IPA_res$TCGA_tumor_young, na.rm = TRUE)
min(IPA_res$TCGA_tumor_young, na.rm = TRUE)
max(IPA_res$TCGA_lung_old, na.rm = TRUE)
min(IPA_res$TCGA_lung_old, na.rm = TRUE)
max(IPA_res$TCGA_lung_young, na.rm = TRUE)
min(IPA_res$TCGA_lung_young, na.rm = TRUE)
max(IPA_res$NYU_tumor_old, na.rm = TRUE)
min(IPA_res$NYU_tumor_old, na.rm = TRUE)
max(IPA_res$NYU_tumor_young, na.rm = TRUE)
min(IPA_res$NYU_tumor_young, na.rm = TRUE)
max(IPA_res$NYU_lung_old, na.rm = TRUE)
min(IPA_res$NYU_lung_old, na.rm = TRUE)
max(IPA_res$NYU_lung_young, na.rm = TRUE)
min(IPA_res$NYU_lung_young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-.61, 0, 4.95), c("blue", "white", "orange"))
col_fun(seq(-.61, 0, 4.95))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/IPA_comparison_early_stage_NYU_vs_stage_I_TCGA_median_age.pdf", height = 24, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(4, "cm"), height = unit(50, "cm"))
dev.off()



################## IPA heatmap NYU early stage and TCGA adv stage ####################

IPA_res <- read.csv("IPA/IPA_comparison_advanced_stage_NYU_vs_TCGA_age_extremes.csv")

#get max and min values 
max(IPA_res$TCGA_tumor_old, na.rm = TRUE)
min(IPA_res$TCGA_tumor_old, na.rm = TRUE)
max(IPA_res$TCGA_tumor_young, na.rm = TRUE)
min(IPA_res$TCGA_tumor_young, na.rm = TRUE)
max(IPA_res$TCGA_lung_old, na.rm = TRUE)
min(IPA_res$TCGA_lung_old, na.rm = TRUE)
max(IPA_res$TCGA_lung_young, na.rm = TRUE)
min(IPA_res$TCGA_lung_young, na.rm = TRUE)
max(IPA_res$NYU_old, na.rm = TRUE)
min(IPA_res$NYU_old, na.rm = TRUE)
max(IPA_res$NYU_young, na.rm = TRUE)
min(IPA_res$NYU_young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-3.71, 0, 2.84), c("blue", "white", "orange"))
col_fun(seq(-3.71, 0, 2.84))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]
colnames(IPA_res_mat)
# set order 
IPA_res_mat <- IPA_res_mat %>% dplyr::select(NYU_old, NYU_young, TCGA_tumor_old,
                                             TCGA_tumor_young, TCGA_lung_old, TCGA_lung_young)

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/IPA_comparison_advanced_stage_NYU_vs_TCGA_age_extremes.pdf", height = 24, width = 20)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(4, "cm"), height = unit(50, "cm"))
dev.off()


#check similarities between datasets of NYU advanced stage and tcga ADVANCED STAGE if p value < 0.05, then datasets are different. if p-value > 0.05 --> datasets are similar 
#tcga vs NYU  old
t.test(IPA_res$TCGA_tumor_old, IPA_res$NYU_old, alternative = "two.sided", na.action = na.omit) #p-value = 0.0008991
t.test(IPA_res$TCGA_lung_old, IPA_res$NYU_old, alternative = "two.sided", na.action = na.omit) #p-value = 3.898e-06
t.test(IPA_res$TCGA_tumor_young, IPA_res$NYU_old, alternative = "two.sided", na.action = na.omit) #p-value = 0.02297
t.test(IPA_res$TCGA_lung_young, IPA_res$NYU_old, alternative = "two.sided", na.action = na.omit) #p-value = 0.0008757

#tcga vs NYU young 
t.test(IPA_res$TCGA_tumor_old, IPA_res$NYU_young, alternative = "two.sided", na.action = na.omit) #p-value = 0.008398
t.test(IPA_res$TCGA_lung_old, IPA_res$NYU_young, alternative = "two.sided", na.action = na.omit) # p-value = 0.3082
t.test(IPA_res$TCGA_tumor_young, IPA_res$NYU_young, alternative = "two.sided", na.action = na.omit) # p-value = 0.000101
t.test(IPA_res$TCGA_lung_young, IPA_res$NYU_young, alternative = "two.sided", na.action = na.omit) # p-value = 0.06885

#get venndiagram of overlap 
install.packages("ggVennDiagram")
library(ggVennDiagram)


###############################################################################
###############################################################################
###############################################################################
###############################################################################
#####################IPA heatmap of old vs young ########################

# NYU early stage 

IPA_res <- read.csv("IPA/IPA_comparison_early_stage_NYU_tumor_lung_old_vs_young_age_extremes.csv")

#get max and min values 
max(IPA_res$Tumor, na.rm = TRUE)
min(IPA_res$Tumor, na.rm = TRUE)
max(IPA_res$Lung, na.rm = TRUE)
min(IPA_res$Lung, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.449, 0, 4.218), c("blue", "white", "orange"))
col_fun(seq(-2.449, 0, 4.218))
IPA_res<- IPA_res %>% arrange(desc(Lung))
#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/IPA_comparison_early_stage_NYU_tumor_lung_old_vs_young_age_extremes.pdf", height = 16, width = 20)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(1, "cm"), height = unit(18, "cm"))
dev.off()


####### TCGA early stage 

IPA_res <- read.csv("IPA/TCGA/IPA_comparison_tumor_lung_stage_I_old_vs_young_age_extremes.csv")

#get max and min values 
max(IPA_res$Tumor, na.rm = TRUE)
min(IPA_res$Tumor, na.rm = TRUE)
max(IPA_res$Lung, na.rm = TRUE)
min(IPA_res$Lung, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-1.794, 0, 3.606), c("blue", "white", "orange"))
col_fun(seq(-1.794, 0, 3.606))
IPA_res<- IPA_res %>% arrange(desc(Lung))
#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_comparison_tumor_lung_stage_I_old_vs_young_age_extremes.pdf", height = 16, width = 20)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(1, "cm"), height = unit(12, "cm"))
dev.off()


##### NYU advanced stage 

IPA_res <- read.csv("IPA/IPA_NYU_advanced_stage_old_vs_young_pathways.csv")

#sort by p value 
IPA_res<- IPA_res %>% arrange(desc(p_value))
#prepear to plot bar plot where x is - log p value and y is pathway and color is z score 

#create a color variable 
# Set NA values to grey
IPA_res$color <- ifelse(is.na(IPA_res$z_score), "grey", "")

library(ggplot2)
library(RColorBrewer)

# Assuming your data frame is called IPA_res and the numerical variable is z_score

# Set NA values to grey
IPA_res$color <- ifelse(is.na(IPA_res$z_score), "grey",
                        ifelse(IPA_res$z_score > 0, "positive", "negative"))
IPA_res$color <-factor(IPA_res$color, levels = c("negative", "grey", "positive"))

#create alpha scale function according to z score and noramlize it to prevent 0 values 
alpha_values <- abs(IPA_res$z_score)
max_alpha <- max(alpha_values, na.rm = TRUE)
min_alpha <- min(alpha_values, na.rm = TRUE)
alpha_scale <- (alpha_values - min_alpha + 1) / (max_alpha - min_alpha + 1)

# Plot the data with alpha-filled bars according to z score 
pdf(file = "IPA/IPA_NYU_advanced_stage_old_vs_young_pathways.pdf", height = 20, width = 22)
ggplot(IPA_res, aes(x = p_value, y = fct_reorder(Pathways, p_value, .fun = max), fill = color)) +
  geom_col(alpha = alpha_scale) +
  scale_fill_manual(values = c("blue", "grey", "orange"), 
                    labels=c("Negative Z-score", "Z-score = 0", "Positive Z-score")) +
  xlab("-log(p-value)")+
  labs(fill = "Z-score")+
  ylab("")+
  theme_bw()+
  theme(axis.text.x = element_text(face = "bold", size = 20), 
        axis.title.x = element_text(face = "bold", size = 24), 
        axis.text.y = element_text(face = "bold", size = 20), 
        legend.position = "top", 
        legend.text = element_text(size = 14))
dev.off()




#TCGA advanced stage 

IPA_res <- read.csv("IPA/TCGA/IPA_TCGA_advanced_stage_old_vs_young_pathways_tumor_and_lung_age_Extremes.csv")

#get max and min values 
max(IPA_res$Tumor, na.rm = TRUE)
min(IPA_res$Tumor, na.rm = TRUE)
max(IPA_res$Lung, na.rm = TRUE)
min(IPA_res$Lung, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-4.808, 0, 2.236), c("blue", "white", "orange"))
col_fun(seq(-4.808, 0, 2.236))
IPA_res<- IPA_res %>% arrange(desc(Tumor))
#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/TCGA/IPA_TCGA_advanced_stage_old_vs_young_pathways_tumor_and_lung_age_Extremes.pdf", height = 16, width = 20)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(1, "cm"), height = unit(8, "cm"))
dev.off()












#######################GSEA for genes overlap between different datasets #################

######################NYU adv stage: old vs all#########

#######################NYU adv stage old vs TCGA adv stage tumor old 
# create .rnk file from LogFoldChange .csv files # Dataset1
x <- read.table("Results/RNA/edgeR.results_NYU_advanced_stage_old_age_extremes__two_y_mort.csv",sep=",",header=T)
x <- x %>% select(-Gene.symbol)
colnames(x) <- c("Name","logFC","logCPM","pvalue","padj")
x <- x[!is.na(x$padj),]
x <- x[x$padj <= 0.1,] # set pdj threshold
x$fcSign <- sign(x$logFC)
x$logP   <- -log10(x$padj)
x$metric <- x$logP/x$fcSign
y <- x[,c("Name", "metric")]
write.table(y,file="Results/RNA/GSEA/edgeR.results_NYU_advanced_stage_old_age_extremes__two_y_mort.rnk",quote=F,sep="\t",row.names=F) # write .rnk file
# 
# create gmt list from LogFoldChange .csv files # Dataset2
a<-read.table("Results/RNA/edgeR.results_tumor_advanced_stage_TCGA_two_y_surv_old_age_extremes.csv",sep=",",header=T)
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- "Results/RNA/GSEA/edgeR.results_NYU_advanced_stage_old_age_extremes__two_y_mort.rnk"
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes
#store results into p.vlaues vector 
p_value_vector <- c()
p.vlaues <- fgseaRes$padj[[1]]
p_value_vector <- c(p_value_vector, p.vlaues)

#######################NYU adv stage old vs NYU adv stage young 
#rank file already created, skip this step 
#
# create gmt list from LogFoldChange .csv files # Dataset2
a<-read.table("Results/RNA/edgeR.results_NYU_advanced_stage_young_age_extremes__two_y_mort.csv",sep=",",header=T)
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- "Results/RNA/GSEA/edgeR.results_NYU_advanced_stage_old_age_extremes__two_y_mort.rnk"
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes
#store results into p.vlaues vector 
p.vlaues <- fgseaRes$padj[[1]]
p_value_vector <- c(p_value_vector, p.vlaues)

#######################NYU adv stage old vs TCGA adv stage tumor young 
#rank file already created, skip this step 
#
# create gmt list from LogFoldChange .csv files # Dataset2
a<-read.table("Results/RNA/edgeR.results_tumor_advanced_stage_TCGA_two_y_surv_young_age_extremes.csv",sep=",",header=T)
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- "Results/RNA/GSEA/edgeR.results_NYU_advanced_stage_old_age_extremes__two_y_mort.rnk"
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes
#store results into p.vlaues vector 
p.vlaues <- fgseaRes$padj[[1]]
p_value_vector <- c(p_value_vector, p.vlaues)

######################NYU adv stage old vs TCGA adv stage lung old 
#rank file already created, skip this step 
#
# create gmt list from LogFoldChange .csv files # Dataset2
a<-read.table("Results/RNA/edgeR.results_lung_advanced_stage_TCGA_two_y_surv_old_age_extremes.csv",sep=",",header=T)
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- "Results/RNA/GSEA/edgeR.results_NYU_advanced_stage_old_age_extremes__two_y_mort.rnk"
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes
#store results into p.vlaues vector 
p.vlaues <- fgseaRes$padj[[1]]
p_value_vector <- c(p_value_vector, p.vlaues)

#######################NYU adv stage old vs TCGA adv stage lung young 
#rank file already created, skip this step 
#
# create gmt list from LogFoldChange .csv files # Dataset2
a<-read.table("Results/RNA/edgeR.results_lung_advanced_stage_TCGA_two_y_surv_young_age_extremes.csv",sep=",",header=T)
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- "Results/RNA/GSEA/edgeR.results_NYU_advanced_stage_old_age_extremes__two_y_mort.rnk"
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes
#store results into p.vlaues vector 
p.vlaues <- fgseaRes$padj[[1]]
p_value_vector <- c(p_value_vector, p.vlaues)

#generat figure of abrs showing shred genes 
######Bar figure of overlap betwen genes 
#find unique and overlapped genes between datasets 
NYU_adv_old <- read.table("Results/RNA/edgeR.results_NYU_advanced_stage_old_age_extremes__two_y_mort.csv",sep=",",header=T)
NYU_adv_young <- read.table("Results/RNA/edgeR.results_NYU_advanced_stage_young_age_extremes__two_y_mort.csv",sep=",",header=T)
TCGA_adv_tumor_old <- read.table("Results/RNA/edgeR.results_tumor_advanced_stage_TCGA_two_y_surv_old_age_extremes.csv",sep=",",header=T)
TCGA_adv_tumor_young <- read.table("Results/RNA/edgeR.results_tumor_advanced_stage_TCGA_two_y_surv_young_age_extremes.csv",sep=",",header=T)
TCGA_adv_lung_old <- read.table("Results/RNA/edgeR.results_lung_advanced_stage_TCGA_two_y_surv_old_age_extremes.csv",sep=",",header=T)
TCGA_adv_lung_young <- read.table("Results/RNA/edgeR.results_lung_advanced_stage_TCGA_two_y_surv_young_age_extremes.csv",sep=",",header=T)

#choose only signficatn genes 
# FDR threshold
fdr_threshold <- 0.2
NYU_adv_old <- NYU_adv_old %>% filter(FDR<=fdr_threshold)
NYU_adv_young <- NYU_adv_young %>% filter(FDR<=fdr_threshold)
TCGA_adv_tumor_old <- TCGA_adv_tumor_old %>% filter(FDR<=fdr_threshold)
TCGA_adv_tumor_young <- TCGA_adv_tumor_young %>% filter(FDR<=fdr_threshold)
TCGA_adv_lung_old <- TCGA_adv_lung_old %>% filter(FDR<=fdr_threshold)
TCGA_adv_lung_young <- TCGA_adv_lung_young %>% filter(FDR<=fdr_threshold)

#now find number of common genes between each comparison 
# Combine all gene datasets into a list
gene_datasets <- list(NYU_adv_old$Gene.symbol, NYU_adv_young$Gene.symbol, TCGA_adv_tumor_old$Gene.symbol,
                      TCGA_adv_tumor_young$Gene.symbol, TCGA_adv_lung_old$Gene.symbol, TCGA_adv_lung_young$Gene.symbol)
#set names 
dataset_names <- c("NYU Adv Old", "NYU Adv Young", "TCGA Adv Tumor Old", "TCGA Adv Tumor young", "TCGA Adv Lung Old", "TCGA Adv Lung young" )
# Define the reference gene dataset
reference_dataset <- NYU_adv_old

# Create a list to store the overlap results
overlap_results <- list()

# Calculate the overlap between reference dataset and each dataset
for (i in 2:length(gene_datasets)) {
  dataset_name <- dataset_names[i]
  dataset <- data.frame(Gene = gene_datasets[[i]])
  
  shared_genes <- intersect(reference_dataset$Gene, dataset$Gene)
  unique_genes <- setdiff(dataset$Gene, reference_dataset$Gene)
  
  overlap_results[[dataset_name]] <- c(Shared_Genes = length(shared_genes), Unique_Genes = length(unique_genes))
}

# Combine the overlap results into a single data frame
combined_results <- data.frame(Dataset = character(), Shared_Genes = numeric(), Unique_Genes = numeric(), stringsAsFactors = FALSE)

for (i in 2:length(gene_datasets)) {
  dataset_name <- dataset_names[i]
  overlap <- overlap_results[[dataset_name]]
  combined_results <- rbind(combined_results, c(dataset_name, overlap))
}

colnames(combined_results) <- c("Dataset", "Shared_Genes", "Unique_Genes")

# Reshape the data for plotting
library(tidyr)
combined_results <- pivot_longer(combined_results, cols = -Dataset, names_to = "GeneType", values_to = "Count")
combined_results$Count <- as.numeric(combined_results$Count)

#### addding reference dataset 
reference_count <- nrow(NYU_adv_old)

# Create a data frame for the reference dataset
reference_data <- data.frame(Dataset = "NYU Adv Old", GeneType = "Reference", Count = reference_count)

# Combine the reference data with the other datasets
combined_results <- rbind(combined_results, reference_data)

#set order of the bars 
combined_results$Dataset <- factor(combined_results$Dataset, levels = c("TCGA Adv Tumor Old", "TCGA Adv Tumor young", "TCGA Adv Lung Old", "TCGA Adv Lung young", "NYU Adv Young", "NYU Adv Old"))
combined_results$GeneType <- factor(combined_results$GeneType, levels = c("Reference", "Unique_Genes", "Shared_Genes"))

# Create the bar plot, add p values manually 
pdf(file = "Figures/RNA/GSEA_barplot_NYU_adv_old_vs_all.pdf", height = 5, width = 12)
ggplot(combined_results, aes(x = Dataset, y = Count, fill = GeneType)) +
  geom_bar(stat = "identity", position = "stack", width = 0.7) +
  coord_flip()+
  scale_fill_manual(values = c("Shared_Genes" = "red", "Reference" = "red", "Unique_Genes" = "grey"),guide = guide_legend(reverse = TRUE))+
  labs(x="", y = "Signature Genes", fill = NULL) +
  scale_y_log10()+
  ggtitle("GSEA") +
  guides(fill="none")+
  theme_classic()+
  theme(axis.text.x = element_text(size = 24), 
        axis.text.y = element_text(size = 24), 
        axis.title.x = element_text(size = 24),
        plot.title = element_text(face = "bold", size = 24, hjust = 0.5))
dev.off()



###################################################################NYU_adv_young_vs_all################
global_analysis_name <- "NYU_adv_young_vs_all"

NYU_adv_old <- read.table("Results/RNA/edgeR.results_NYU_advanced_stage_old_age_extremes__two_y_mort.csv",sep=",",header=T)
NYU_adv_young <- read.table("Results/RNA/edgeR.results_NYU_advanced_stage_young_age_extremes__two_y_mort.csv",sep=",",header=T)
TCGA_adv_tumor_old <- read.table("Results/RNA/edgeR.results_tumor_advanced_stage_TCGA_two_y_surv_old_age_extremes.csv",sep=",",header=T)
TCGA_adv_tumor_young <- read.table("Results/RNA/edgeR.results_tumor_advanced_stage_TCGA_two_y_surv_young_age_extremes.csv",sep=",",header=T)
TCGA_adv_lung_old <- read.table("Results/RNA/edgeR.results_lung_advanced_stage_TCGA_two_y_surv_old_age_extremes.csv",sep=",",header=T)
TCGA_adv_lung_young <- read.table("Results/RNA/edgeR.results_lung_advanced_stage_TCGA_two_y_surv_young_age_extremes.csv",sep=",",header=T)

#######################NYU adv stage young vs TCGA adv stage tumor old 

#define analysis name 
analysis_name <- paste0("NYU_adv_young", paste0("_vs_", paste0("TCGA_adv_tumor_old")))
#define dataset 1
NYU_adv_young
#define rnk name 
rnk_name <- "Results/RNA/GSEA/edgeR.results_NYU_advanced_stage_young_age_extremes__two_y_mort.rnk"
#define file to be used as gmt 
gmt_name <- TCGA_adv_tumor_old

# create .rnk file from LogFoldChange .csv files # Dataset1
x <- NYU_adv_young
x <- x %>% select(-Gene.symbol)
colnames(x) <- c("Name","logFC","logCPM","pvalue","padj")
x <- x[!is.na(x$padj),]
x <- x[x$padj <= 0.1,] # set pdj threshold
x$fcSign <- sign(x$logFC)
x$logP   <- -log10(x$padj)
x$metric <- x$logP/x$fcSign
y <- x[,c("Name", "metric")]
write.table(y,file=rnk_name,quote=F,sep="\t",row.names=F) # write .rnk file
# 
# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
p_value_df <- data.frame(Analysis=character(), P_value=numeric())
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

#######################NYU adv stage young vs NYU adv stage old 
#define analysis name 
analysis_name <- paste0("NYU_adv_young", paste0("_vs_", paste0("NYU adv stage old")))
#define file to be used as gmt. no change in rnk file or dataset_1
gmt_name <- NYU_adv_old

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

#######################NYU adv stage young vs TCGA adv stage tumor young 
#define analysis name 
analysis_name <- paste0("NYU_adv_young", paste0("_vs_", paste0("TCGA adv stage tumor young")))
#define file to be used as gmt. no change in rnk file or dataset_1
gmt_name <- TCGA_adv_tumor_young

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

######################NYU adv stage young vs TCGA adv stage lung old 
#define analysis name 
analysis_name <- paste0("NYU_adv_young", paste0("_vs_", paste0("TCGA adv stage lung old")))
#define file to be used as gmt. no change in rnk file or dataset_1
gmt_name <- TCGA_adv_lung_old

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)
#######################NYU adv stage young vs TCGA adv stage lung young 
#define analysis name 
analysis_name <- paste0("NYU_adv_young", paste0("_vs_", paste0("TCGA adv stage lung young")))
#define file to be used as gmt. no change in rnk file or dataset_1
gmt_name <- TCGA_adv_lung_young

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

############### export p_value_df 
write.csv(p_value_df, file = paste0("Results/RNA/", paste0("GSEA_",paste0(global_analysis_name, paste0(".csv")))))

#generat figure of abrs showing shred genes 
######Bar figure of overlap betwen genes 
#find unique and overlapped genes between datasets 

#choose only signficatn genes 
# FDR threshold
fdr_threshold <- 0.2
NYU_adv_old <- NYU_adv_old %>% filter(FDR<=fdr_threshold)
NYU_adv_young <- NYU_adv_young %>% filter(FDR<=fdr_threshold)
TCGA_adv_tumor_old <- TCGA_adv_tumor_old %>% filter(FDR<=fdr_threshold)
TCGA_adv_tumor_young <- TCGA_adv_tumor_young %>% filter(FDR<=fdr_threshold)
TCGA_adv_lung_old <- TCGA_adv_lung_old %>% filter(FDR<=fdr_threshold)
TCGA_adv_lung_young <- TCGA_adv_lung_young %>% filter(FDR<=fdr_threshold)

#now find number of common genes between each comparison 
# Define the reference gene dataset
reference_dataset <- NYU_adv_young

# Combine all gene datasets into a list
gene_datasets <- list(reference_dataset$Gene.symbol, NYU_adv_old$Gene.symbol, TCGA_adv_tumor_old$Gene.symbol,
                      TCGA_adv_tumor_young$Gene.symbol, TCGA_adv_lung_old$Gene.symbol, TCGA_adv_lung_young$Gene.symbol)
#set names 
dataset_names <- c("NYU Adv Young","NYU Adv Old", "TCGA Adv Tumor Old", "TCGA Adv Tumor young", "TCGA Adv Lung Old", "TCGA Adv Lung young" )

# Create a list to store the overlap results
overlap_results <- list()

# Calculate the overlap between reference dataset and each dataset
for (i in 2:length(gene_datasets)) {
  dataset_name <- dataset_names[i]
  dataset <- data.frame(Gene = gene_datasets[[i]])
  
  shared_genes <- intersect(reference_dataset$Gene, dataset$Gene)
  unique_genes <- setdiff(dataset$Gene, reference_dataset$Gene)
  
  overlap_results[[dataset_name]] <- c(Shared_Genes = length(shared_genes), Unique_Genes = length(unique_genes))
}

# Combine the overlap results into a single data frame
combined_results <- data.frame(Dataset = character(), Shared_Genes = numeric(), Unique_Genes = numeric(), stringsAsFactors = FALSE)

for (i in 2:length(gene_datasets)) {
  dataset_name <- dataset_names[i]
  overlap <- overlap_results[[dataset_name]]
  combined_results <- rbind(combined_results, c(dataset_name, overlap))
}

colnames(combined_results) <- c("Dataset", "Shared_Genes", "Unique_Genes")

# Reshape the data for plotting
combined_results <- pivot_longer(combined_results, cols = -Dataset, names_to = "GeneType", values_to = "Count")
combined_results$Count <- as.numeric(combined_results$Count)

#### addding reference dataset 
reference_count <- nrow(reference_dataset)

# Create a data frame for the reference dataset
reference_data <- data.frame(Dataset = "NYU Adv Young", GeneType = "Reference", Count = reference_count)

# Combine the reference data with the other datasets
combined_results <- rbind(combined_results, reference_data)

#set order of the bars 
combined_results$Dataset <- factor(combined_results$Dataset, levels = c("TCGA Adv Tumor Old", "TCGA Adv Tumor young", "TCGA Adv Lung Old", "TCGA Adv Lung young", "NYU Adv Old", "NYU Adv Young"))
combined_results$GeneType <- factor(combined_results$GeneType, levels = c("Reference", "Unique_Genes", "Shared_Genes"))

# Create the bar plot, add p values manually 
pdf(file = "Figures/RNA/GSEA_barplot_NYU_adv_young_vs_all.pdf", height = 5, width = 12)
ggplot(combined_results, aes(x = Dataset, y = Count, fill = GeneType)) +
  geom_bar(stat = "identity", position = "stack", width = 0.7) +
  coord_flip()+
  scale_fill_manual(values = c("Shared_Genes" = "red", "Reference" = "red", "Unique_Genes" = "grey"),guide = guide_legend(reverse = TRUE))+
  labs(x="", y = "Signature Genes", fill = NULL) +
  scale_y_log10()+
  ggtitle("GSEA") +
  guides(fill="none")+
  theme_classic()+
  theme(axis.text.x = element_text(size = 24), 
        axis.text.y = element_text(size = 24), 
        axis.title.x = element_text(size = 24),
        plot.title = element_text(face = "bold", size = 24, hjust = 0.5))
dev.off()










#################### GSEA early stage###############

#NYU_early_tumor_vs_all

###################################################################NYU_early_tumor_old_vs_all################
global_analysis_name <- "NYU_early_tumor_old_vs_all"

#read all files of early stage NYU and stage I TCGA
NYU_early_tumor_old <- read.table("Results/RNA/edgeR.results_old_tumor_rec_vs_no_rec.csv",sep=",",header=T)
NYU_early_tumor_young <- read.table("Results/RNA/edgeR.results_young_tumor_rec_vs_no_rec.csv",sep=",",header=T)
NYU_early_lung_old <- read.table("Results/RNA/edgeR.results_old_lung_rec_vs_no_rec.csv",sep=",",header=T)
NYU_early_lung_young <- read.table("Results/RNA/edgeR.results_young_lung_rec_vs_no_rec.csv",sep=",",header=T)
TCGA_stageI_tumor_old <- read.table("Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_old_age_3_grps.csv",sep=",",header=T)
TCGA_stageI_tumor_young <- read.table("Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_young_age_3_grps.csv",sep=",",header=T)
TCGA_stageI_lung_old <- read.table("Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_old_age_3_grps.csv",sep=",",header=T)
TCGA_stageI_lung_young <- read.table("Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_young_age_3_grps.csv",sep=",",header=T)

#######################NYU early tumor old vs TCGA stage I tumor old 

#define analysis name 
analysis_name <- paste0("NYU_early_tumor_old", paste0("_vs_", paste0("TCGA stage I tumor old")))
#define dataset 1
NYU_early_tumor_old
#define rnk name 
rnk_name <- "Results/RNA/GSEA/edgeR.results_old_tumor_rec_vs_no_rec.rnk"
#define file to be used as gmt 
gmt_name <- TCGA_stageI_tumor_old

# create .rnk file from LogFoldChange .csv files # Dataset1
x <- NYU_early_tumor_old
x <- x %>% select(-Gene.symbol)
colnames(x) <- c("Name","logFC","logCPM","pvalue","padj")
x <- x[!is.na(x$padj),]
x <- x[x$padj <= 0.1,] # set pdj threshold
x$fcSign <- sign(x$logFC)
x$logP   <- -log10(x$padj)
x$metric <- x$logP/x$fcSign
y <- x[,c("Name", "metric")]
write.table(y,file=rnk_name,quote=F,sep="\t",row.names=F) # write .rnk file
# 
# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
p_value_df <- data.frame(Analysis=character(), P_value=numeric())
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

####################################NYU early tumor old vs NYU early tumor young 
#define analysis name 
analysis_name <- paste0("NYU_early_tumor_old", paste0("_vs_", paste0("NYU early tumor young")))
#define file to be used as gmt 
gmt_name <- NYU_early_tumor_young

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)


####################################NYU early tumor old vs TCGA stage I tumor young 

#define analysis name 
analysis_name <- paste0("NYU_early_tumor_old", paste0("_vs_", paste0("TCGA stage I tumor young")))
#define file to be used as gmt 
gmt_name <- TCGA_stageI_tumor_young

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)


####################################NYU early tumor old vs TCGA stage I lung old 

#define analysis name 
analysis_name <- paste0("NYU_early_tumor_old", paste0("_vs_", paste0("TCGA stage I lung old")))
#define file to be used as gmt 
gmt_name <- TCGA_stageI_lung_old

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

####################################NYU early tumor old vs TCGA stage I lung young 

#define analysis name 
analysis_name <- paste0("NYU_early_tumor_old", paste0("_vs_", paste0("TCGA stage I lung young")))
#define file to be used as gmt 
gmt_name <- TCGA_stageI_lung_young

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

############### export p_value_df 
write.csv(p_value_df, file = paste0("Results/RNA/", paste0("GSEA_",paste0(global_analysis_name, paste0(".csv")))))

#generat figure of abrs showing shred genes 
######Bar figure of overlap betwen genes 
#find unique and overlapped genes between datasets 

#choose only signficatn genes 
# FDR threshold
fdr_threshold <- 0.2
NYU_early_tumor_old <- NYU_early_tumor_old %>% filter(FDR<=fdr_threshold)
NYU_early_tumor_young <- NYU_early_tumor_young %>% filter(FDR<=fdr_threshold)
TCGA_stageI_tumor_old <- TCGA_stageI_tumor_old %>% filter(FDR<=fdr_threshold)
TCGA_stageI_tumor_young <- TCGA_stageI_tumor_young %>% filter(FDR<=fdr_threshold)
TCGA_stageI_lung_old <- TCGA_stageI_lung_old %>% filter(FDR<=fdr_threshold)
TCGA_stageI_lung_young <- TCGA_stageI_lung_young %>% filter(FDR<=fdr_threshold)

#now find number of common genes between each comparison 
# Define the reference gene dataset
reference_dataset <- NYU_early_tumor_old

# Combine all gene datasets into a list
gene_datasets <- list(reference_dataset$Gene.symbol, NYU_early_tumor_young$Gene.symbol, TCGA_stageI_tumor_old$Gene.symbol,
                      TCGA_stageI_tumor_young$Gene.symbol, TCGA_stageI_lung_old$Gene.symbol, TCGA_stageI_lung_young$Gene.symbol)
#set names 
dataset_names <- c("NYU Early Tumor Old","NYU Early Tumor Young", "TCGA Stage I Tumor Old", "TCGA Stage I Tumor Young", "TCGA Stage I Lung Old", "TCGA Stage I Lung Young" )

# Create a list to store the overlap results
overlap_results <- list()

# Calculate the overlap between reference dataset and each dataset
for (i in 2:length(gene_datasets)) {
  dataset_name <- dataset_names[i]
  dataset <- data.frame(Gene = gene_datasets[[i]])
  
  shared_genes <- intersect(reference_dataset$Gene, dataset$Gene)
  unique_genes <- setdiff(dataset$Gene, reference_dataset$Gene)
  
  overlap_results[[dataset_name]] <- c(Shared_Genes = length(shared_genes), Unique_Genes = length(unique_genes))
}

# Combine the overlap results into a single data frame
combined_results <- data.frame(Dataset = character(), Shared_Genes = numeric(), Unique_Genes = numeric(), stringsAsFactors = FALSE)

for (i in 2:length(gene_datasets)) {
  dataset_name <- dataset_names[i]
  overlap <- overlap_results[[dataset_name]]
  combined_results <- rbind(combined_results, c(dataset_name, overlap))
}

colnames(combined_results) <- c("Dataset", "Shared_Genes", "Unique_Genes")

# Reshape the data for plotting
combined_results <- pivot_longer(combined_results, cols = -Dataset, names_to = "GeneType", values_to = "Count")
combined_results$Count <- as.numeric(combined_results$Count)

#### addding reference dataset 
reference_count <- nrow(reference_dataset)

# Create a data frame for the reference dataset
reference_data <- data.frame(Dataset = "NYU Early Tumor Old", GeneType = "Reference", Count = reference_count)

# Combine the reference data with the other datasets
combined_results <- rbind(combined_results, reference_data)

#set order of the bars 
combined_results$Dataset <- factor(combined_results$Dataset, levels = c("TCGA Stage I Tumor Old", "TCGA Stage I Tumor Young", "TCGA Stage I Lung Old", "TCGA Stage I Lung Young", "NYU Early Tumor Young", "NYU Early Tumor Old"))
combined_results$GeneType <- factor(combined_results$GeneType, levels = c("Reference", "Unique_Genes", "Shared_Genes"))

# Create the bar plot, add p values manually 
pdf(file = "Figures/RNA/GSEA_barplot_NYU_early_tumor_old_vs_all.pdf", height = 5, width = 12)
ggplot(combined_results, aes(x = Dataset, y = Count, fill = GeneType)) +
  geom_bar(stat = "identity", position = "stack", width = 0.7) +
  coord_flip()+
  scale_fill_manual(values = c("Shared_Genes" = "red", "Reference" = "red", "Unique_Genes" = "grey"),guide = guide_legend(reverse = TRUE))+
  labs(x="", y = "Signature Genes", fill = NULL) +
  scale_y_log10()+
  ggtitle("GSEA") +
  guides(fill="none")+
  theme_classic()+
  theme(axis.text.x = element_text(size = 24), 
        axis.text.y = element_text(size = 24), 
        axis.title.x = element_text(size = 24),
        plot.title = element_text(face = "bold", size = 24, hjust = 0.5))
dev.off()








############################## NYU early tumor YOung vs all ##############################

###################################################################NYU_early_tumor_young_vs_all################
global_analysis_name <- "NYU_early_tumor_young_vs_all"

#read all files of early stage NYU and stage I TCGA
NYU_early_tumor_old <- read.table("Results/RNA/edgeR.results_old_tumor_rec_vs_no_rec.csv",sep=",",header=T)
NYU_early_tumor_young <- read.table("Results/RNA/edgeR.results_young_tumor_rec_vs_no_rec.csv",sep=",",header=T)
NYU_early_lung_old <- read.table("Results/RNA/edgeR.results_old_lung_rec_vs_no_rec.csv",sep=",",header=T)
NYU_early_lung_young <- read.table("Results/RNA/edgeR.results_young_lung_rec_vs_no_rec.csv",sep=",",header=T)
TCGA_stageI_tumor_old <- read.table("Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_old_age_3_grps.csv",sep=",",header=T)
TCGA_stageI_tumor_young <- read.table("Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_young_age_3_grps.csv",sep=",",header=T)
TCGA_stageI_lung_old <- read.table("Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_old_age_3_grps.csv",sep=",",header=T)
TCGA_stageI_lung_young <- read.table("Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_young_age_3_grps.csv",sep=",",header=T)

#######################NYU early tumor young vs TCGA stage I tumor old 

#define analysis name 
analysis_name <- paste0("NYU_early_tumor_young", paste0("_vs_", paste0("TCGA stage I tumor old")))
#define dataset 1
NYU_early_tumor_young
#define rnk name 
rnk_name <- "Results/RNA/GSEA/edgeR.results_young_tumor_rec_vs_no_rec.rnk"
#define file to be used as gmt 
gmt_name <- TCGA_stageI_tumor_old

# create .rnk file from LogFoldChange .csv files # Dataset1
x <- NYU_early_tumor_old
x <- x %>% select(-Gene.symbol)
colnames(x) <- c("Name","logFC","logCPM","pvalue","padj")
x <- x[!is.na(x$padj),]
x <- x[x$padj <= 0.1,] # set pdj threshold
x$fcSign <- sign(x$logFC)
x$logP   <- -log10(x$padj)
x$metric <- x$logP/x$fcSign
y <- x[,c("Name", "metric")]
write.table(y,file=rnk_name,quote=F,sep="\t",row.names=F) # write .rnk file
# 
# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
p_value_df <- data.frame(Analysis=character(), P_value=numeric())
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

####################################NYU_early_tumor_young vs NYU early tumor young 
#define analysis name 
analysis_name <- paste0("NYU_early_tumor_young", paste0("_vs_", paste0("NYU early tumor old")))
#define file to be used as gmt 
gmt_name <- NYU_early_tumor_old

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)


####################################NYU_early_tumor_young vs TCGA stage I tumor young 

#define analysis name 
analysis_name <- paste0("NYU_early_tumor_young", paste0("_vs_", paste0("TCGA stage I tumor young")))
#define file to be used as gmt 
gmt_name <- TCGA_stageI_tumor_young

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)


####################################NYU_early_tumor_young vs TCGA stage I lung old 

#define analysis name 
analysis_name <- paste0("NYU_early_tumor_young", paste0("_vs_", paste0("TCGA stage I lung old")))
#define file to be used as gmt 
gmt_name <- TCGA_stageI_lung_old

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

####################################NYU_early_tumor_young vs TCGA stage I lung young 

#define analysis name 
analysis_name <- paste0("NYU_early_tumor_young", paste0("_vs_", paste0("TCGA stage I lung young")))
#define file to be used as gmt 
gmt_name <- TCGA_stageI_lung_young

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

############### export p_value_df 
write.csv(p_value_df, file = paste0("Results/RNA/", paste0("GSEA_",paste0(global_analysis_name, paste0(".csv")))))

#generat figure of abrs showing shred genes 
######Bar figure of overlap betwen genes 
#find unique and overlapped genes between datasets 

#choose only signficatn genes 
# FDR threshold
fdr_threshold <- 0.2
NYU_early_tumor_old <- NYU_early_tumor_old %>% filter(FDR<=fdr_threshold)
NYU_early_tumor_young <- NYU_early_tumor_young %>% filter(FDR<=fdr_threshold)
TCGA_stageI_tumor_old <- TCGA_stageI_tumor_old %>% filter(FDR<=fdr_threshold)
TCGA_stageI_tumor_young <- TCGA_stageI_tumor_young %>% filter(FDR<=fdr_threshold)
TCGA_stageI_lung_old <- TCGA_stageI_lung_old %>% filter(FDR<=fdr_threshold)
TCGA_stageI_lung_young <- TCGA_stageI_lung_young %>% filter(FDR<=fdr_threshold)

#now find number of common genes between each comparison 
# Define the reference gene dataset
reference_dataset <- NYU_early_tumor_young

# Combine all gene datasets into a list
gene_datasets <- list(reference_dataset$Gene.symbol, NYU_early_tumor_old$Gene.symbol, TCGA_stageI_tumor_old$Gene.symbol,
                      TCGA_stageI_tumor_young$Gene.symbol, TCGA_stageI_lung_old$Gene.symbol, TCGA_stageI_lung_young$Gene.symbol)
#set names 
dataset_names <- c("NYU Early Tumor Young","NYU Early Tumor Old", "TCGA Stage I Tumor Old", "TCGA Stage I Tumor Young", "TCGA Stage I Lung Old", "TCGA Stage I Lung Young" )

# Create a list to store the overlap results
overlap_results <- list()

# Calculate the overlap between reference dataset and each dataset
for (i in 2:length(gene_datasets)) {
  dataset_name <- dataset_names[i]
  dataset <- data.frame(Gene = gene_datasets[[i]])
  
  shared_genes <- intersect(reference_dataset$Gene, dataset$Gene)
  unique_genes <- setdiff(dataset$Gene, reference_dataset$Gene)
  
  overlap_results[[dataset_name]] <- c(Shared_Genes = length(shared_genes), Unique_Genes = length(unique_genes))
}

# Combine the overlap results into a single data frame
combined_results <- data.frame(Dataset = character(), Shared_Genes = numeric(), Unique_Genes = numeric(), stringsAsFactors = FALSE)

for (i in 2:length(gene_datasets)) {
  dataset_name <- dataset_names[i]
  overlap <- overlap_results[[dataset_name]]
  combined_results <- rbind(combined_results, c(dataset_name, overlap))
}

colnames(combined_results) <- c("Dataset", "Shared_Genes", "Unique_Genes")

# Reshape the data for plotting
combined_results <- pivot_longer(combined_results, cols = -Dataset, names_to = "GeneType", values_to = "Count")
combined_results$Count <- as.numeric(combined_results$Count)

#### addding reference dataset 
reference_count <- nrow(reference_dataset)

# Create a data frame for the reference dataset
reference_data <- data.frame(Dataset = "NYU Early Tumor Young", GeneType = "Reference", Count = reference_count)

# Combine the reference data with the other datasets
combined_results <- rbind(combined_results, reference_data)

#set order of the bars 
combined_results$Dataset <- factor(combined_results$Dataset, levels = c("TCGA Stage I Tumor Old", "TCGA Stage I Tumor Young", "TCGA Stage I Lung Old", "TCGA Stage I Lung Young", "NYU Early Tumor Old", "NYU Early Tumor Young"))
combined_results$GeneType <- factor(combined_results$GeneType, levels = c("Reference", "Unique_Genes", "Shared_Genes"))

# Create the bar plot, add p values manually 
pdf(file = "Figures/RNA/GSEA_barplot_NYU_early_tumor_Young_vs_all.pdf", height = 5, width = 12)
ggplot(combined_results, aes(x = Dataset, y = Count, fill = GeneType)) +
  geom_bar(stat = "identity", position = "stack", width = 0.7) +
  coord_flip()+
  scale_fill_manual(values = c("Shared_Genes" = "red", "Reference" = "red", "Unique_Genes" = "grey"),guide = guide_legend(reverse = TRUE))+
  labs(x="", y = "Signature Genes", fill = NULL) +
  scale_y_log10()+
  ggtitle("GSEA") +
  guides(fill="none")+
  theme_classic()+
  theme(axis.text.x = element_text(size = 24), 
        axis.text.y = element_text(size = 24), 
        axis.title.x = element_text(size = 24),
        plot.title = element_text(face = "bold", size = 24, hjust = 0.5))
dev.off()












######################## NYU early Lung vs all ##############


#NYU_early_lung_vs_all

###################################################################NYU_early_lung_old_vs_all################
global_analysis_name <- "NYU_early_lung_old_vs_all"

#read all files of early stage NYU and stage I TCGA
NYU_early_tumor_old <- read.table("Results/RNA/edgeR.results_old_tumor_rec_vs_no_rec.csv",sep=",",header=T)
NYU_early_tumor_young <- read.table("Results/RNA/edgeR.results_young_tumor_rec_vs_no_rec.csv",sep=",",header=T)
NYU_early_lung_old <- read.table("Results/RNA/edgeR.results_old_lung_rec_vs_no_rec.csv",sep=",",header=T)
NYU_early_lung_young <- read.table("Results/RNA/edgeR.results_young_lung_rec_vs_no_rec.csv",sep=",",header=T)
TCGA_stageI_tumor_old <- read.table("Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_old_age_3_grps.csv",sep=",",header=T)
TCGA_stageI_tumor_young <- read.table("Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_young_age_3_grps.csv",sep=",",header=T)
TCGA_stageI_lung_old <- read.table("Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_old_age_3_grps.csv",sep=",",header=T)
TCGA_stageI_lung_young <- read.table("Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_young_age_3_grps.csv",sep=",",header=T)

#######################NYU early lung old vs TCGA stage I tumor old 

#define analysis name 
analysis_name <- paste0("NYU_early_lung_old", paste0("_vs_", paste0("TCGA stage I tumor old")))
#define dataset 1
NYU_early_lung_old
#define rnk name 
rnk_name <- "Results/RNA/GSEA/edgeR.results_old_lung_rec_vs_no_rec.rnk"
#define file to be used as gmt 
gmt_name <- TCGA_stageI_tumor_old

# create .rnk file from LogFoldChange .csv files # Dataset1
x <- NYU_early_lung_old
x <- x %>% select(-Gene.symbol)
colnames(x) <- c("Name","logFC","logCPM","pvalue","padj")
x <- x[!is.na(x$padj),]
x <- x[x$padj <= 0.1,] # set pdj threshold
x$fcSign <- sign(x$logFC)
x$logP   <- -log10(x$padj)
x$metric <- x$logP/x$fcSign
y <- x[,c("Name", "metric")]
write.table(y,file=rnk_name,quote=F,sep="\t",row.names=F) # write .rnk file
# 
# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
p_value_df <- data.frame(Analysis=character(), P_value=numeric())
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

####################################NYU early lung old vs NYU early lung young 
#define analysis name 
analysis_name <- paste0("NYU_early_lung_old", paste0("_vs_", paste0("NYU early lung young")))
#define file to be used as gmt 
gmt_name <- NYU_early_lung_young

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)


####################################NYU early lung old vs TCGA stage I tumor young 

#define analysis name 
analysis_name <- paste0("NYU_early_lung_old", paste0("_vs_", paste0("TCGA stage I tumor young")))
#define file to be used as gmt 
gmt_name <- TCGA_stageI_tumor_young

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)


####################################NYU early lung old vs TCGA stage I lung old 

#define analysis name 
analysis_name <- paste0("NYU_early_lung_old", paste0("_vs_", paste0("TCGA stage I lung old")))
#define file to be used as gmt 
gmt_name <- TCGA_stageI_lung_old

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

####################################NYU early lung old vs TCGA stage I lung young 

#define analysis name 
analysis_name <- paste0("NYU_early_lung_old", paste0("_vs_", paste0("TCGA stage I lung young")))
#define file to be used as gmt 
gmt_name <- TCGA_stageI_lung_young

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

############### export p_value_df 
write.csv(p_value_df, file = paste0("Results/RNA/", paste0("GSEA_",paste0(global_analysis_name, paste0(".csv")))))

#generat figure of abrs showing shred genes 
######Bar figure of overlap betwen genes 
#find unique and overlapped genes between datasets 

#choose only signficatn genes 
# FDR threshold
fdr_threshold <- 0.2
NYU_early_lung_old <- NYU_early_lung_old %>% filter(FDR<=fdr_threshold)
NYU_early_lung_young <- NYU_early_lung_young %>% filter(FDR<=fdr_threshold)
TCGA_stageI_tumor_old <- TCGA_stageI_tumor_old %>% filter(FDR<=fdr_threshold)
TCGA_stageI_tumor_young <- TCGA_stageI_tumor_young %>% filter(FDR<=fdr_threshold)
TCGA_stageI_lung_old <- TCGA_stageI_lung_old %>% filter(FDR<=fdr_threshold)
TCGA_stageI_lung_young <- TCGA_stageI_lung_young %>% filter(FDR<=fdr_threshold)

#now find number of common genes between each comparison 
# Define the reference gene dataset
reference_dataset <- NYU_early_lung_old

# Combine all gene datasets into a list
gene_datasets <- list(reference_dataset$Gene.symbol, NYU_early_lung_young$Gene.symbol, TCGA_stageI_tumor_old$Gene.symbol,
                      TCGA_stageI_tumor_young$Gene.symbol, TCGA_stageI_lung_old$Gene.symbol, TCGA_stageI_lung_young$Gene.symbol)
#set names 
dataset_names <- c("NYU Early lung Old","NYU Early lung Young", "TCGA Stage I Tumor Old", "TCGA Stage I Tumor Young", "TCGA Stage I Lung Old", "TCGA Stage I Lung Young" )

# Create a list to store the overlap results
overlap_results <- list()

# Calculate the overlap between reference dataset and each dataset
for (i in 2:length(gene_datasets)) {
  dataset_name <- dataset_names[i]
  dataset <- data.frame(Gene = gene_datasets[[i]])
  
  shared_genes <- intersect(reference_dataset$Gene, dataset$Gene)
  unique_genes <- setdiff(dataset$Gene, reference_dataset$Gene)
  
  overlap_results[[dataset_name]] <- c(Shared_Genes = length(shared_genes), Unique_Genes = length(unique_genes))
}

# Combine the overlap results into a single data frame
combined_results <- data.frame(Dataset = character(), Shared_Genes = numeric(), Unique_Genes = numeric(), stringsAsFactors = FALSE)

for (i in 2:length(gene_datasets)) {
  dataset_name <- dataset_names[i]
  overlap <- overlap_results[[dataset_name]]
  combined_results <- rbind(combined_results, c(dataset_name, overlap))
}

colnames(combined_results) <- c("Dataset", "Shared_Genes", "Unique_Genes")

# Reshape the data for plotting
combined_results <- pivot_longer(combined_results, cols = -Dataset, names_to = "GeneType", values_to = "Count")
combined_results$Count <- as.numeric(combined_results$Count)

#### addding reference dataset 
reference_count <- nrow(reference_dataset)

# Create a data frame for the reference dataset
reference_data <- data.frame(Dataset = "NYU Early lung Old", GeneType = "Reference", Count = reference_count)

# Combine the reference data with the other datasets
combined_results <- rbind(combined_results, reference_data)

#set order of the bars 
combined_results$Dataset <- factor(combined_results$Dataset, levels = c("TCGA Stage I Tumor Old", "TCGA Stage I Tumor Young", "TCGA Stage I Lung Old", "TCGA Stage I Lung Young", "NYU Early lung Young", "NYU Early lung Old"))
combined_results$GeneType <- factor(combined_results$GeneType, levels = c("Reference", "Unique_Genes", "Shared_Genes"))

# Create the bar plot, add p values manually 
pdf(file = "Figures/RNA/GSEA_barplot_NYU_early_lung_old_vs_all.pdf", height = 5, width = 12)
ggplot(combined_results, aes(x = Dataset, y = Count, fill = GeneType)) +
  geom_bar(stat = "identity", position = "stack", width = 0.7) +
  coord_flip()+
  scale_fill_manual(values = c("Shared_Genes" = "red", "Reference" = "red", "Unique_Genes" = "grey"),guide = guide_legend(reverse = TRUE))+
  labs(x="", y = "Signature Genes", fill = NULL) +
  scale_y_log10()+
  ggtitle("GSEA") +
  guides(fill="none")+
  theme_classic()+
  theme(axis.text.x = element_text(size = 24), 
        axis.text.y = element_text(size = 24), 
        axis.title.x = element_text(size = 24),
        plot.title = element_text(face = "bold", size = 24, hjust = 0.5))
dev.off()




############################## NYU early lung YOung vs all ##############################

###################################################################NYU_early_lung_young_vs_all################
global_analysis_name <- "NYU_early_lung_young_vs_all"

#read all files of early stage NYU and stage I TCGA
NYU_early_tumor_old <- read.table("Results/RNA/edgeR.results_old_tumor_rec_vs_no_rec.csv",sep=",",header=T)
NYU_early_tumor_young <- read.table("Results/RNA/edgeR.results_young_tumor_rec_vs_no_rec.csv",sep=",",header=T)
NYU_early_lung_old <- read.table("Results/RNA/edgeR.results_old_lung_rec_vs_no_rec.csv",sep=",",header=T)
NYU_early_lung_young <- read.table("Results/RNA/edgeR.results_young_lung_rec_vs_no_rec.csv",sep=",",header=T)
TCGA_stageI_tumor_old <- read.table("Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_old_age_3_grps.csv",sep=",",header=T)
TCGA_stageI_tumor_young <- read.table("Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_young_age_3_grps.csv",sep=",",header=T)
TCGA_stageI_lung_old <- read.table("Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_old_age_3_grps.csv",sep=",",header=T)
TCGA_stageI_lung_young <- read.table("Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_young_age_3_grps.csv",sep=",",header=T)

#######################NYU early lung young vs TCGA stage I tumor old 

#define analysis name 
analysis_name <- paste0("NYU_early_lung_young", paste0("_vs_", paste0("TCGA stage I tumor old")))
#define dataset 1
NYU_early_lung_young
#define rnk name 
rnk_name <- "Results/RNA/GSEA/edgeR.results_young_lung_rec_vs_no_rec.rnk"
#define file to be used as gmt 
gmt_name <- TCGA_stageI_tumor_old

# create .rnk file from LogFoldChange .csv files # Dataset1
x <- NYU_early_lung_old
x <- x %>% select(-Gene.symbol)
colnames(x) <- c("Name","logFC","logCPM","pvalue","padj")
x <- x[!is.na(x$padj),]
x <- x[x$padj <= 0.1,] # set pdj threshold
x$fcSign <- sign(x$logFC)
x$logP   <- -log10(x$padj)
x$metric <- x$logP/x$fcSign
y <- x[,c("Name", "metric")]
write.table(y,file=rnk_name,quote=F,sep="\t",row.names=F) # write .rnk file
# 
# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
p_value_df <- data.frame(Analysis=character(), P_value=numeric())
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

####################################NYU_early_lung_young vs NYU early lung young 
#define analysis name 
analysis_name <- paste0("NYU_early_lung_young", paste0("_vs_", paste0("NYU early lung old")))
#define file to be used as gmt 
gmt_name <- NYU_early_lung_old

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)


####################################NYU_early_lung_young vs TCGA stage I tumor young 

#define analysis name 
analysis_name <- paste0("NYU_early_lung_young", paste0("_vs_", paste0("TCGA stage I tumor young")))
#define file to be used as gmt 
gmt_name <- TCGA_stageI_tumor_young

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)


####################################NYU_early_lung_young vs TCGA stage I lung old 

#define analysis name 
analysis_name <- paste0("NYU_early_lung_young", paste0("_vs_", paste0("TCGA stage I lung old")))
#define file to be used as gmt 
gmt_name <- TCGA_stageI_lung_old

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

####################################NYU_early_lung_young vs TCGA stage I lung young 

#define analysis name 
analysis_name <- paste0("NYU_early_lung_young", paste0("_vs_", paste0("TCGA stage I lung young")))
#define file to be used as gmt 
gmt_name <- TCGA_stageI_lung_young

# create gmt list from LogFoldChange .csv files # Dataset2
a<-gmt_name
a <- a %>% select(-Gene.symbol)
colnames(a) <- c("Name","logFC","logCPM","pvalue","padj")
a <- a[!is.na(a$padj),]
a <- a[a$padj <= 0.1,] # set pdj threshold
a$fcSign <- sign(a$logFC)
gmt.file<-c()
gmt.file$GenesetUp<-a[a$fcSign==1,]$Name
gmt.file$GenesetDown<-a[a$fcSign==-1,]$Name
# 
## Compare .rnk file to GMT list 
rnk.file <- rnk_name
ranks    <- read.table(rnk.file,header=TRUE, colClasses = c("character", "numeric"))
ranks    <- setNames(ranks$metric,ranks$Name)
ranks    <- ranks[!is.infinite(ranks)] 
#run fgsea 
fgseaRes <- fgsea(gmt.file, ranks, nperm=1000)
fgseaRes

#store results into dataframe
new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
if (nrow(fgseaRes) == 0) {
  # If results dataframe is empty, store NULL in p_value_df
  new_row <- data.frame(Analysis = analysis_name, P_Value = NA)
} else {
  # If results dataframe is not empty, extract the p.adj from fgseaRes
  p_value <- fgseaRes$padj[[1]]
  
  # Create a new row for the dataframe
  new_row <- data.frame(Analysis = analysis_name, P_Value = p_value)
}
# Add the new row to the dataframe
p_value_df <- rbind(p_value_df, new_row)

############### export p_value_df 
write.csv(p_value_df, file = paste0("Results/RNA/", paste0("GSEA_",paste0(global_analysis_name, paste0(".csv")))))

#generat figure of abrs showing shred genes 
######Bar figure of overlap betwen genes 
#find unique and overlapped genes between datasets 

#choose only signficatn genes 
# FDR threshold
fdr_threshold <- 0.2
NYU_early_lung_old <- NYU_early_lung_old %>% filter(FDR<=fdr_threshold)
NYU_early_lung_young <- NYU_early_lung_young %>% filter(FDR<=fdr_threshold)
TCGA_stageI_tumor_old <- TCGA_stageI_tumor_old %>% filter(FDR<=fdr_threshold)
TCGA_stageI_tumor_young <- TCGA_stageI_tumor_young %>% filter(FDR<=fdr_threshold)
TCGA_stageI_lung_old <- TCGA_stageI_lung_old %>% filter(FDR<=fdr_threshold)
TCGA_stageI_lung_young <- TCGA_stageI_lung_young %>% filter(FDR<=fdr_threshold)

#now find number of common genes between each comparison 
# Define the reference gene dataset
reference_dataset <- NYU_early_lung_young

# Combine all gene datasets into a list
gene_datasets <- list(reference_dataset$Gene.symbol, NYU_early_lung_old$Gene.symbol, TCGA_stageI_tumor_old$Gene.symbol,
                      TCGA_stageI_tumor_young$Gene.symbol, TCGA_stageI_lung_old$Gene.symbol, TCGA_stageI_lung_young$Gene.symbol)
#set names 
dataset_names <- c("NYU Early lung Young","NYU Early lung Old", "TCGA Stage I Tumor Old", "TCGA Stage I Tumor Young", "TCGA Stage I Lung Old", "TCGA Stage I Lung Young" )

# Create a list to store the overlap results
overlap_results <- list()

# Calculate the overlap between reference dataset and each dataset
for (i in 2:length(gene_datasets)) {
  dataset_name <- dataset_names[i]
  dataset <- data.frame(Gene = gene_datasets[[i]])
  
  shared_genes <- intersect(reference_dataset$Gene, dataset$Gene)
  unique_genes <- setdiff(dataset$Gene, reference_dataset$Gene)
  
  overlap_results[[dataset_name]] <- c(Shared_Genes = length(shared_genes), Unique_Genes = length(unique_genes))
}

# Combine the overlap results into a single data frame
combined_results <- data.frame(Dataset = character(), Shared_Genes = numeric(), Unique_Genes = numeric(), stringsAsFactors = FALSE)

for (i in 2:length(gene_datasets)) {
  dataset_name <- dataset_names[i]
  overlap <- overlap_results[[dataset_name]]
  combined_results <- rbind(combined_results, c(dataset_name, overlap))
}

colnames(combined_results) <- c("Dataset", "Shared_Genes", "Unique_Genes")

# Reshape the data for plotting
combined_results <- pivot_longer(combined_results, cols = -Dataset, names_to = "GeneType", values_to = "Count")
combined_results$Count <- as.numeric(combined_results$Count)

#### addding reference dataset 
reference_count <- nrow(reference_dataset)

# Create a data frame for the reference dataset
reference_data <- data.frame(Dataset = "NYU Early lung Young", GeneType = "Reference", Count = reference_count)

# Combine the reference data with the other datasets
combined_results <- rbind(combined_results, reference_data)

#set order of the bars 
combined_results$Dataset <- factor(combined_results$Dataset, levels = c("TCGA Stage I Tumor Old", "TCGA Stage I Tumor Young", "TCGA Stage I Lung Old", "TCGA Stage I Lung Young", "NYU Early lung Old", "NYU Early lung Young"))
combined_results$GeneType <- factor(combined_results$GeneType, levels = c("Reference", "Unique_Genes", "Shared_Genes"))

# Create the bar plot, add p values manually 
pdf(file = "Figures/RNA/GSEA_barplot_NYU_early_lung_Young_vs_all.pdf", height = 5, width = 12)
ggplot(combined_results, aes(x = Dataset, y = Count, fill = GeneType)) +
  geom_bar(stat = "identity", position = "stack", width = 0.7) +
  coord_flip()+
  scale_fill_manual(values = c("Shared_Genes" = "red", "Reference" = "red", "Unique_Genes" = "grey"),guide = guide_legend(reverse = TRUE))+
  labs(x="", y = "Signature Genes", fill = NULL) +
  scale_y_log10()+
  ggtitle("GSEA") +
  guides(fill="none")+
  theme_classic()+
  theme(axis.text.x = element_text(size = 24), 
        axis.text.y = element_text(size = 24), 
        axis.title.x = element_text(size = 24),
        plot.title = element_text(face = "bold", size = 24, hjust = 0.5))
dev.off()







##################################
#################################### Using genes from Zhang et al paper and checking them in our data############
Zhang_genes <- c("ZNF101", "PLEKHB1",
"P2RX1", "EIF2AK3", "LPAR6", "ATF7IP2", "MS4A1", "CCR2", "ZNF10", "AKTIP",
"GNG7", "DAAM2", "PTTG1", "IL1R2", "KYNU", "TCN1", "ITGA6", "AHSA1", "DSC1",
"LINGO2", "C1QTNF6")
















































################################################################################
################################################################################
################################################################################
####################Single Sample GSEA analysis of early stage #################


##### analysis done in GenePattern 
#read results 

ssGSEA_res <- read.delim(file = "Data/ssGSEA_results_new.txt", header = TRUE, row.names = 1, sep = "\t")

#remove description column 
ssGSEA_res <- ssGSEA_res %>% dplyr::select(-Description)

#transpose to put samples as rows
ssGSEA_res_t <- as.data.frame(t(ssGSEA_res))

#ADD CLINICAL DATA - age, sample type, progression 
#load meadata 
ssGSEA_metadata = read.delim(file= "Data/Surgical.Cohort.Map.txt", header = T, sep = "\t", row.names = 1)

#Keep Only MetaData of RNASeq Samples
#Keep only samples with RNA ID that matches the RNA count data 
RNA.data = ssGSEA_metadata[ssGSEA_metadata$RNA_Seq_done_Final==1,]
RNA.data <- RNA.data[RNA.data$RNA_ID!= "n.a",]

#Pick up the column that have RNA ID in metadata 
#We want to match ID names in each element 
RNA.data$RNA_ID

#Order Meta Data by SampleId
RNA.data <- RNA.data[order(RNA.data$RNA_ID),]

#Order ssGSEA_res_t by SampleID and 
rownames(ssGSEA_res_t) <- gsub("X", "", rownames(ssGSEA_res_t))
ssGSEA_res_t <- ssGSEA_res_t [order(rownames(ssGSEA_res_t)),]

setdiff(rownames(ssGSEA_res_t), rownames(RNA.data))
#Confirm rownames of both dataframes are the same 
table(rownames(ssGSEA_res_t)==rownames(RNA.data))


######################Creating age groups ####################

#define age as numeric 
RNA.data$Age <- as.numeric(RNA.data$Age)

# find out the age cutoffs of three groups 
cut(RNA.data$Age, breaks = quantile(RNA.data$Age, probs = c(0, 1/3, 2/3, 1)))

#should get: Levels: (46,66] (66,74] (74,89]

#now build another column in the metadata that fit these three groups 
RNA.data$age_3_grps <- ifelse(RNA.data$Age >74, "old",
                              ifelse(RNA.data$Age < 66, "young", 
                                     "middle"))

#add clinical chrasterstics 
ssGSEA_res_t$Age <- RNA.data$Age
ssGSEA_res_t$age_3_grps <- RNA.data$age_3_grps
ssGSEA_res_t$Sample_Type_Involved <- RNA.data$Sample_Type_Involved
ssGSEA_res_t$Progression_Lab_Inv <- RNA.data$Progression_Lab_Inv
ssGSEA_res_t$Progression_Lab <- RNA.data$Progression_Lab

ssGSEA_res_t_age_extrem <- ssGSEA_res_t %>% 
  filter(age_3_grps!= "middle") %>% 
  mutate(age_3_grps=factor(age_3_grps, levels= c("young", "old"))) %>% 
  mutate(Sample_Type_Involved=factor(Sample_Type_Involved, levels= c("Lung.Tissue.In", "Lung.Tissue.UnIn"))) %>% 
  arrange(age_3_grps)

#heatmap of pathways of age extremes only
#set colors 
library(circlize)

#get matrix for heatmap  
heatmap_mat <- ssGSEA_res_t_age_extrem %>% select(-c(Age, age_3_grps, Progression_Lab_Inv, Progression_Lab, Sample_Type_Involved))

#get maximal calues 
# Get the maximal enrichment score for each column (pathway)
max_scores <- apply(heatmap_mat, 2, max)

# Get the minimal enrichment score for each column (pathway)
min_scores <- apply(heatmap_mat, 2, min)

# Print the maximal and minimal scores for each pathway
max_min_scores <- data.frame(Pathway = colnames(heatmap_mat), Max_Score = max_scores, Min_Score = min_scores)
print(max_min_scores)


#get maximal and minimal scores 
max(max_min_scores$Max_Score)
min(max_min_scores$Max_Score)
max(max_min_scores$Min_Score)
min(max_min_scores$Min_Score)

col_fun = colorRamp2(c(-4520.843, 0, 10648.84), c("blue", "white", "red"))
col_fun(seq(-4520.843, 0, 10648.84))

#transplse so you get pathways as rows 
heatmap_mat_t <- as.data.frame(t(heatmap_mat))

#convert to matrix 
heatmap_mat_t <- as.matrix(heatmap_mat_t)

#plot heatmap using complex heatmaps 

set.seed(1234)

# Define colors for each levels of qualitative variables

col = list(age_3_grps = c("old" = "darkblue", "young" = "darkgreen"), 
           sample_type= c("Lung.Tissue.In" ="red","Lung.Tissue.UnIn"= "blue"), 
           Progression_Lab=c("Recurrence" = "darkred", "No.Recurrence" = "skyblue"))

# Create the heatmap annotation
library(ComplexHeatmap)

ha <- HeatmapAnnotation(
  age_3_grps = ssGSEA_res_t_age_extrem$age_3_grps,
  Sample_Type_Involved = ssGSEA_res_t_age_extrem$Sample_Type_Involved,
  Progression_Lab = ssGSEA_res_t_age_extrem$Progression_Lab,
  col = col)

#plot
pdf(file = "Figures/heatmap_ssGSEA_res_age_extremes_clustered.pdf", height = 48, width = 80)
ComplexHeatmap::Heatmap(heatmap_mat_t, 
                        rect_gp = gpar(col = "black", lwd = 2),
                        col = col_fun, 
                        row_title_side = "left", 
                        column_title_side = "bottom",
                        cluster_rows = TRUE, 
                        cluster_columns = TRUE,
                        row_names_gp = gpar(fontsface="bold", fontsize= 18),
                        row_names_side = "left", 
                        column_title = "", row_title = "", 
                        row_labels =rownames(ssGSEA_res),
                        top_annotation = ha, 
                        height = unit(40, "inch"), width = unit(68, "inch"))
dev.off()










###### repeat heatmap for tumor samples only 
heatmap_tumor <- ssGSEA_res_t_age_extrem %>% 
  filter(Sample_Type_Involved=="Lung.Tissue.In")


#get matrix for heatmap  
heatmap_mat <- heatmap_tumor %>% select(-c(Age, age_3_grps, Progression_Lab_Inv, Progression_Lab, Sample_Type_Involved))

#get maximal calues 
# Get the maximal enrichment score for each column (pathway)
max_scores <- apply(heatmap_mat, 2, max)

# Get the minimal enrichment score for each column (pathway)
min_scores <- apply(heatmap_mat, 2, min)

# Print the maximal and minimal scores for each pathway
max_min_scores <- data.frame(Pathway = colnames(heatmap_mat), Max_Score = max_scores, Min_Score = min_scores)
print(max_min_scores)


#get maximal and minimal scores 
max(max_min_scores$Max_Score)
min(max_min_scores$Max_Score)
max(max_min_scores$Min_Score)
min(max_min_scores$Min_Score)

col_fun = colorRamp2(c(-4427.991, 0, 10648.84), c("blue", "white", "red"))
col_fun(seq(-4427.991, 0, 10648.84))

#transplse so you get pathways as rows 
heatmap_mat_t <- as.data.frame(t(heatmap_mat))

#convert to matrix 
heatmap_mat_t <- as.matrix(heatmap_mat_t)

#plot heatmap using complex heatmaps 

set.seed(1234)

# Define colors for each levels of qualitative variables

col = list(age_3_grps = c("old" = "darkblue", "young" = "darkgreen"), 
           Progression_Lab=c("Recurrence" = "darkred", "No.Recurrence" = "skyblue"))

# Create the heatmap annotation
library(ComplexHeatmap)

ha <- HeatmapAnnotation(
  age_3_grps = heatmap_tumor$age_3_grps,
  Progression_Lab = heatmap_tumor$Progression_Lab,
  col = col)

#plot
pdf(file = "Figures/heatmap_ssGSEA_res_age_extremes_tumor.pdf", height = 48, width = 80)
ComplexHeatmap::Heatmap(heatmap_mat_t, 
                        rect_gp = gpar(col = "black", lwd = 2),
                        col = col_fun, 
                        row_title_side = "left", 
                        column_title_side = "bottom",
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE,
                        row_names_gp = gpar(fontsface="bold", fontsize= 18),
                        row_names_side = "left", 
                        column_title = "", row_title = "", 
                        row_labels =rownames(ssGSEA_res),
                        top_annotation = ha, 
                        height = unit(40, "inch"), width = unit(68, "inch"))
dev.off()


#clustered 
pdf(file = "Figures/heatmap_ssGSEA_res_age_extremes_tumor_clustered.pdf", height = 48, width = 80)
ComplexHeatmap::Heatmap(heatmap_mat_t, 
                        rect_gp = gpar(col = "black", lwd = 2),
                        col = col_fun, 
                        row_title_side = "left", 
                        column_title_side = "bottom",
                        cluster_rows = TRUE, 
                        cluster_columns = TRUE,
                        row_names_gp = gpar(fontsface="bold", fontsize= 18),
                        row_names_side = "left", 
                        column_title = "", row_title = "", 
                        row_labels =rownames(ssGSEA_res),
                        top_annotation = ha, 
                        height = unit(40, "inch"), width = unit(68, "inch"))
dev.off()











###### repeat heatmap for lung samples only 
heatmap_lung <- ssGSEA_res_t_age_extrem %>% 
  filter(Sample_Type_Involved=="Lung.Tissue.UnIn")


#get matrix for heatmap  
heatmap_mat <- heatmap_lung %>% select(-c(Age, age_3_grps, Progression_Lab_Inv, Progression_Lab, Sample_Type_Involved))

#get maximal calues 
# Get the maximal enrichment score for each column (pathway)
max_scores <- apply(heatmap_mat, 2, max)

# Get the minimal enrichment score for each column (pathway)
min_scores <- apply(heatmap_mat, 2, min)

# Print the maximal and minimal scores for each pathway
max_min_scores <- data.frame(Pathway = colnames(heatmap_mat), Max_Score = max_scores, Min_Score = min_scores)
print(max_min_scores)


#get maximal and minimal scores 
max(max_min_scores$Max_Score)
min(max_min_scores$Max_Score)
max(max_min_scores$Min_Score)
min(max_min_scores$Min_Score)

col_fun = colorRamp2(c(-4520.843, 0, 10202.34), c("blue", "white", "red"))
col_fun(seq(-4520.843, 0, 10202.34))

#transplse so you get pathways as rows 
heatmap_mat_t <- as.data.frame(t(heatmap_mat))

#convert to matrix 
heatmap_mat_t <- as.matrix(heatmap_mat_t)

#plot heatmap using complex heatmaps 

set.seed(1234)

# Define colors for each levels of qualitative variables

col = list(age_3_grps = c("old" = "darkblue", "young" = "darkgreen"), 
           Progression_Lab=c("Recurrence" = "darkred", "No.Recurrence" = "skyblue"))

# Create the heatmap annotation
library(ComplexHeatmap)

ha <- HeatmapAnnotation(
  age_3_grps = heatmap_lung$age_3_grps,
  Progression_Lab = heatmap_lung$Progression_Lab,
  col = col)

#plot
pdf(file = "Figures/heatmap_ssGSEA_res_age_extremes_lung.pdf", height = 48, width = 80)
ComplexHeatmap::Heatmap(heatmap_mat_t, 
                        rect_gp = gpar(col = "black", lwd = 2),
                        col = col_fun, 
                        row_title_side = "left", 
                        column_title_side = "bottom",
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE,
                        row_names_gp = gpar(fontsface="bold", fontsize= 18),
                        row_names_side = "left", 
                        column_title = "", row_title = "", 
                        row_labels =rownames(ssGSEA_res),
                        top_annotation = ha, 
                        height = unit(40, "inch"), width = unit(68, "inch"))
dev.off()


#####clustering the heatmap 
pdf(file = "Figures/heatmap_ssGSEA_res_age_extremes_lung_clustered.pdf", height = 48, width = 80)
ComplexHeatmap::Heatmap(heatmap_mat_t, 
                        rect_gp = gpar(col = "black", lwd = 2),
                        col = col_fun, 
                        row_title_side = "left", 
                        column_title_side = "bottom",
                        cluster_rows = TRUE, 
                        cluster_columns = TRUE,
                        row_names_gp = gpar(fontsface="bold", fontsize= 18),
                        row_names_side = "left", 
                        column_title = "", row_title = "", 
                        row_labels =rownames(ssGSEA_res),
                        top_annotation = ha, 
                        height = unit(40, "inch"), width = unit(68, "inch"))
dev.off()


#heatmap with middle group 
ssGSEA_res_t <- ssGSEA_res_t %>% 
  mutate(age_3_grps=factor(age_3_grps, levels= c("young", "middle", "old"))) %>% 
  mutate(Sample_Type_Involved=factor(Sample_Type_Involved, levels= c("Lung.Tissue.In", "Lung.Tissue.UnIn"))) %>% 
  arrange(age_3_grps)

#heatmap of pathways of age extremes only
#set colors 
library(circlize)

#get matrix for heatmap  
heatmap_mat <- ssGSEA_res_t %>% select(-c(Age, age_3_grps, Progression_Lab_Inv, Progression_Lab, Sample_Type_Involved))

#get maximal calues 
# Get the maximal enrichment score for each column (pathway)
max_scores <- apply(heatmap_mat, 2, max)

# Get the minimal enrichment score for each column (pathway)
min_scores <- apply(heatmap_mat, 2, min)

# Print the maximal and minimal scores for each pathway
max_min_scores <- data.frame(Pathway = colnames(heatmap_mat), Max_Score = max_scores, Min_Score = min_scores)
print(max_min_scores)


#get maximal and minimal scores 
max(max_min_scores$Max_Score)
min(max_min_scores$Max_Score)
max(max_min_scores$Min_Score)
min(max_min_scores$Min_Score)

col_fun = colorRamp2(c(-4582.801, 0, 10648.84), c("blue", "white", "red"))
col_fun(seq(-4582.801, 0, 10648.84))

#transplse so you get pathways as rows 
heatmap_mat_t <- as.data.frame(t(heatmap_mat))

#convert to matrix 
heatmap_mat_t <- as.matrix(heatmap_mat_t)

#plot heatmap using complex heatmaps 

set.seed(1234)

# Define colors for each levels of qualitative variables

col = list(age_3_grps = c("old" = "darkblue", "middle" = "orange", "young" = "darkgreen"), 
           sample_type= c("Lung.Tissue.In" ="red","Lung.Tissue.UnIn"= "blue"), 
           Progression_Lab=c("Recurrence" = "darkred", "No.Recurrence" = "skyblue"))

# Create the heatmap annotation
library(ComplexHeatmap)

ha <- HeatmapAnnotation(
  age_3_grps = ssGSEA_res_t$age_3_grps,
  Sample_Type_Involved = ssGSEA_res_t$Sample_Type_Involved,
  Progression_Lab = ssGSEA_res_t$Progression_Lab,
  col = col)

#plot
pdf(file = "Figures/heatmap_ssGSEA_res_all_age_groups.pdf", height = 48, width = 80)
ComplexHeatmap::Heatmap(heatmap_mat_t, 
                        rect_gp = gpar(col = "black", lwd = 2),
                        col = col_fun, 
                        row_title_side = "left", 
                        column_title_side = "bottom",
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE,
                        row_names_gp = gpar(fontsface="bold", fontsize= 18),
                        row_names_side = "left", 
                        column_title = "", row_title = "", 
                        row_labels =rownames(ssGSEA_res),
                        top_annotation = ha, 
                        height = unit(40, "inch"), width = unit(68, "inch"))
dev.off()



################################################################################
################################################################################
################################################################################
################################################################################
############# UMAP for ssGSEA ######
# Install and load the necessary packages
install.packages("umap")
library(umap)

# Extract the relevant columns (enrichment scores)
data_matrix <- ssGSEA_res_t_age_extrem%>% select(-c(age_3_grps, Age, Sample_Type_Involved, Progression_Lab, Progression_Lab_Inv)) %>% as.matrix(.)

# Perform UMAP dimensionality reduction
umap_result <- umap(data_matrix, n_neighbors = 15, n_components = 2)

# Create a data frame with the UMAP coordinates
umap_df <- data.frame(
  UMAP_1 = umap_result$layout[, 1],
  UMAP_2 = umap_result$layout[, 2]
)

# Plot the UMAP visualization using ggplot2
pdf(file = "Figures/UMAP_ssagsea_age_extremes_all_samples.pdf", height = 8, width = 8)
ggplot(umap_df, aes(x = UMAP_1, y = UMAP_2, color=ssGSEA_res_t_age_extrem$age_3_grps)) +
  geom_point(size = 3, alpha = 0.7) +
  labs(
    title = "UMAP Visualization of Enrichment Scores",
    x = "UMAP 1",
    y = "UMAP 2"
  )+
  scale_color_manual(values = c("old"="darkblue", "young"="darkgreen"))+
  theme_bw()
dev.off()


#repeat for tumor only 
ssGSEA_res_t_age_extrem_tum <- ssGSEA_res_t_age_extrem%>%filter(Sample_Type_Involved=="Lung.Tissue.In")
# Extract the relevant columns (enrichment scores)
data_matrix <- ssGSEA_res_t_age_extrem_tum %>% 
  select(-c(age_3_grps, Age, Sample_Type_Involved, Progression_Lab, Progression_Lab_Inv)) %>% as.matrix(.)

# Perform UMAP dimensionality reduction
umap_result <- umap(data_matrix, n_neighbors = 15, n_components = 2)

# Create a data frame with the UMAP coordinates
umap_df <- data.frame(
  UMAP_1 = umap_result$layout[, 1],
  UMAP_2 = umap_result$layout[, 2]
)

# Plot the UMAP visualization using ggplot2
pdf(file = "Figures/UMAP_ssagsea_age_extremes_tumor_samples.pdf", height = 8, width = 8)
ggplot(umap_df, aes(x = UMAP_1, y = UMAP_2, color=ssGSEA_res_t_age_extrem_tum$age_3_grps)) +
  geom_point(size = 3, alpha = 0.7) +
  labs(
    title = "UMAP Visualization of Enrichment Scores",
    x = "UMAP 1",
    y = "UMAP 2"
  )+
  scale_color_manual(values = c("old"="darkblue", "young"="darkgreen"))+
  theme_bw()
dev.off()


#repeat for lung only 
ssGSEA_res_t_age_extrem_lung <- ssGSEA_res_t_age_extrem%>%filter(Sample_Type_Involved=="Lung.Tissue.UnIn")
# Extract the relevant columns (enrichment scores)
data_matrix <- ssGSEA_res_t_age_extrem_lung %>% 
  select(-c(age_3_grps, Age, Sample_Type_Involved, Progression_Lab, Progression_Lab_Inv)) %>% as.matrix(.)

# Perform UMAP dimensionality reduction
umap_result <- umap(data_matrix, n_neighbors = 15, n_components = 2)

# Create a data frame with the UMAP coordinates
umap_df <- data.frame(
  UMAP_1 = umap_result$layout[, 1],
  UMAP_2 = umap_result$layout[, 2]
)

# Plot the UMAP visualization using ggplot2
pdf(file = "Figures/UMAP_ssagsea_age_extremes_lung_samples.pdf", height = 8, width = 8)
ggplot(umap_df, aes(x = UMAP_1, y = UMAP_2, color=ssGSEA_res_t_age_extrem_lung$age_3_grps)) +
  geom_point(size = 3, alpha = 0.7) +
  labs(
    title = "UMAP Visualization of Enrichment Scores",
    x = "UMAP 1",
    y = "UMAP 2"
  )+
  scale_color_manual(values = c("old"="darkblue", "young"="darkgreen"))+
  theme_bw()
dev.off()





#########linear regression model ###
# Reshape the data to a long format
data_long <- ssGSEA_res_t_age_extrem %>%
  pivot_longer(cols = starts_with("HALLMARK_"), 
               names_to = "Pathway", 
               values_to = "Enrichment_Score")

# Fit a linear regression model
model <- lm(Enrichment_Score ~ age_3_grps + Sample_Type_Involved+Progression_Lab, data = data_long)

# Summarize the model
summary(model)
#save


# Create a scatterplot
pdf(file = "Figures/linear_regression_model_all_samples.pdf", height = 8, width = 8)
ggplot(data_long, aes(x = age_3_grps, y = Enrichment_Score)) +
  geom_boxplot() +
  labs(
    title = "Enrichment Scores vs. Age",
    x = "Age Group",
    y = "Enrichment Score"
  ) +
  theme_minimal()
dev.off()


#tumor only 


#lung only 


#against age as a number 
pdf(file = "Figures/linear_regression_model_all_samples_against_Age.pdf", height = 8, width = 8)
ggplot(data_long, aes(x = Age, y = Enrichment_Score)) +
  geom_point() +
  labs(
    title = "Enrichment Scores vs. Age",
    x = "Age Group",
    y = "Enrichment Score"
  ) +
  theme_minimal()
dev.off()






#compare all pathways between age groups
#first show differences betwwen ages
#loop over colnames 
col_names <- colnames(ssGSEA_res_t[1:nrow(ssGSEA_res)])
ssGSEA_res_t$age_3_grps <- factor(ssGSEA_res_t$age_3_grps, levels = c("young", "middle", "old"))


ggplot(ssGSEA_res_t, aes(x= age_3_grps, y=HALLMARK_TNFA_SIGNALING_VIA_NFKB))+
  geom_boxplot(aes(fill=age_3_grps))+
  stat_compare_means( comparisons = list(c("young", "middle"), 
                                        c("middle", "old"), 
                                        c("young", "old")))+
  scale_fill_manual(values = c("darkgreen", "orange", "darkblue"))+
  scale_x_discrete(labels= c("Young", "Middle", "Old"))+
  
  xlab("")+
  ylab("")+
  ggtitle("HALLMARK_TNFA_SIGNALING_VIA_NFKB")+
  scale_y_log10()+
  theme_classic()+
  theme(plot.title = element_text(face="bold"), 
        axis.text.x = element_markdown(face = "bold", size=14), 
        axis.text.y = element_text(face = "bold", size = 14), 
        legend.position = "none")


#loop over all columns 
for (i in col_names){
  p <- ggplot(ssGSEA_res_t, aes_string(x= ssGSEA_res_t$age_3_grps, y=i))+
    geom_boxplot(aes(fill=age_3_grps))+
    stat_compare_means( comparisons = list(c("young", "middle"), 
                                           c("middle", "old"), 
                                           c("young", "old")))+
    scale_fill_manual(values = c("darkgreen", "orange", "darkblue"))+
    scale_x_discrete(labels= c("Young", "Middle", "Old"))+
    
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Figures/", paste0("ssGSEA_", paste0(i, paste0(".boxplot",paste0(".pdf")))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}

#differences between tumor and lung according to age 
# tumor old, tumor young, lung old, lung young 

ssGSEA_res_t <- ssGSEA_res_t %>% 
  mutate(age_rec = case_when(
    age_3_grps=="young" & Progression_Lab_Inv =="In.No.Recurrence" ~ "young_tum_no_rec", 
    age_3_grps=="young" & Progression_Lab_Inv =="In.Recurrence" ~ "young_tum_rec", 
    age_3_grps=="old" & Progression_Lab_Inv =="In.No.Recurrence" ~ "old_tum_no_rec", 
    age_3_grps=="old" & Progression_Lab_Inv =="In.Recurrence" ~ "old_tum_rec", 
    age_3_grps=="young" & Progression_Lab_Inv =="UnIn.No.Recurrence" ~ "young_lung_no_rec", 
    age_3_grps=="young" & Progression_Lab_Inv =="UnIn.Recurrence" ~ "young_lung_rec", 
    age_3_grps=="old" & Progression_Lab_Inv =="UnIn.No.Recurrence" ~ "old_lung_no_rec", 
    age_3_grps=="old" & Progression_Lab_Inv =="UnIn.Recurrence" ~ "old_lung_rec", 
    age_3_grps=="middle" & Progression_Lab_Inv =="In.No.Recurrence" ~ "middle_tum_no_rec", 
    age_3_grps=="middle" & Progression_Lab_Inv =="In.Recurrence" ~ "middle_tum_rec", 
    age_3_grps=="middle" & Progression_Lab_Inv =="UnIn.No.Recurrence" ~ "middle_lung_no_rec", 
    age_3_grps=="middle" & Progression_Lab_Inv =="UnIn.Recurrence" ~ "middle_lung_rec", 
  )) %>% 
  mutate(age_rec = factor(age_rec))

#now for analysis remove middle age group 
analysis_df <- ssGSEA_res_t %>% filter(age_3_grps!= "middle") %>% 
  mutate(age_rec = factor(age_rec, levels = c("young_tum_no_rec", "young_tum_rec", "old_tum_no_rec", "old_tum_rec", 
                                                 "young_lung_no_rec", "young_lung_rec", "old_lung_no_rec", "old_lung_rec")))


#analyze each type of  samples alone 
analysis_df_tum <- analysis_df %>% filter(Sample_Type_Involved=="Lung.Tissue.In")
analysis_df_lung <- analysis_df %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")

#loop over all columns in tumor
for (i in col_names){
  p <- ggplot(analysis_df_tum, aes_string(x= analysis_df_tum$age_rec, y=i))+
    geom_boxplot(aes(fill=age_rec))+
    stat_compare_means( comparisons = list(c("young_tum_no_rec", "young_tum_rec"), 
                                           c("old_tum_no_rec", "old_tum_rec"), 
                                           c("young_tum_no_rec", "old_tum_no_rec"), 
                                           c("young_tum_rec", "old_tum_rec")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Figures/", paste0("ssGSEA_", paste0(i, paste0("_Tumor_age_rec_boxplot",paste0(".pdf")))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}

#repeat for lung 

for (i in col_names){
  p <- ggplot(analysis_df_lung, aes_string(x= analysis_df_lung$age_rec, y=i))+
    geom_boxplot(aes(fill=age_rec))+
    stat_compare_means( comparisons = list(c("young_lung_no_rec", "young_lung_rec"), 
                                           c("old_lung_no_rec", "old_lung_rec"), 
                                           c("young_lung_no_rec", "old_lung_no_rec"), 
                                           c("young_lung_rec", "old_lung_rec")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Figures/", paste0("ssGSEA_", paste0(i, paste0("_Lung_age_rec_boxplot",paste0(".pdf")))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


################################################################################
################# edgeR with ssGSEA pathways ##################################

#define analysis variable 
v= "age_3_grps"
#define colors 
col1 <-"darkblue"
col2 <- "darkgreen"

#table to use 
ssGSEA_res_t_age_extrem


mycounts.analysis <- ssGSEA_res_t_age_extrem %>% select(-c(Age, age_3_grps, Sample_Type_Involved, Progression_Lab, Progression_Lab_Inv)) %>% t(.)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")

#log transform and remove any NA
x=log1p(x+1)
x=na.omit(x)
# get your group variable (the condition you want to analyze according to it)
metadata_analysis <- RNA.data.extremes
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_NYU_early_stage_ssGSEA", paste0("_", paste0("_", paste0(v, paste0(".csv"))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_NYU_early_stage_ssGSEA_", paste0("_", paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



#repeat in tumor and compare old to young 

#define analysis variable 
v= "age_3_grps"
#define colors 
col1 <-"darkblue"
col2 <- "darkgreen"

#table to use 
ssGSEA_res_t_age_extrem_tum <- ssGSEA_res_t_age_extrem %>% filter(Sample_Type_Involved=="Lung.Tissue.In")


mycounts.analysis <- ssGSEA_res_t_age_extrem_tum %>% select(-c(Age, age_3_grps, Sample_Type_Involved, Progression_Lab, Progression_Lab_Inv)) %>% t(.)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")

#log transform and remove any NA
x=log1p(x+1)
x=na.omit(x)
# get your group variable (the condition you want to analyze according to it)
metadata_analysis <- RNA.data.extremes %>% filter(Sample_Type_Involved=="Lung.Tissue.In")
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_NYU_early_stage_ssGSEA", paste0("", paste0("tumor", paste0(v, paste0(".csv"))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_NYU_early_stage_ssGSEA_", paste0("_", paste0("tumor", paste0(v, paste0(alpha, paste0("_.pdf")))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



#repeat in tumor and compare old rec vs no rec 
#define analysis variable 
v= "Progression_Lab_Inv"
#define colors 
col1 <-"red"
col2 <- "orange"

#table to use 
ssGSEA_res_t_age_extrem_tum <- ssGSEA_res_t_age_extrem %>% filter(Sample_Type_Involved=="Lung.Tissue.In") %>% filter(age_3_grps=="old")


mycounts.analysis <- ssGSEA_res_t_age_extrem_tum %>% select(-c(Age, age_3_grps, Sample_Type_Involved, Progression_Lab, Progression_Lab_Inv)) %>% t(.)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
#log transform and remove any NA
x=log1p(x+1)
x=na.omit(x)
# get your group variable (the condition you want to analyze according to it)
metadata_analysis <- RNA.data.extremes %>% filter(Sample_Type_Involved=="Lung.Tissue.In") %>% filter(age_3_grps=="old")

group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_NYU_early_stage_ssGSEA", paste0("", paste0("tumor_old", paste0(v, paste0(".csv"))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_NYU_early_stage_ssGSEA_", paste0("_", paste0("tumor_old", paste0(v, paste0(alpha, paste0("_.pdf")))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



#tumor and compare young rec vs no rec 
v= "Progression_Lab_Inv"
#define colors 
col1 <-"blue"
col2 <- "skyblue"

#table to use 
ssGSEA_res_t_age_extrem_tum <- ssGSEA_res_t_age_extrem %>% filter(Sample_Type_Involved=="Lung.Tissue.In") %>% filter(age_3_grps=="young")


mycounts.analysis <- ssGSEA_res_t_age_extrem_tum %>% select(-c(Age, age_3_grps, Sample_Type_Involved, Progression_Lab, Progression_Lab_Inv)) %>% t(.)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
#log transform and remove any NA
x=log1p(x+1)
x=na.omit(x)
# get your group variable (the condition you want to analyze according to it)
metadata_analysis <- RNA.data.extremes %>% filter(Sample_Type_Involved=="Lung.Tissue.In") %>% filter(age_3_grps=="young")

group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_NYU_early_stage_ssGSEA", paste0("", paste0("tumor_young", paste0(v, paste0(".csv"))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_NYU_early_stage_ssGSEA_", paste0("_", paste0("tumor_young", paste0(v, paste0(alpha, paste0("_.pdf")))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fyoung-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()













#repeat in lung and compare old to young 

#define analysis variable 
v= "age_3_grps"
#define colors 
col1 <-"darkblue"
col2 <- "darkgreen"

#table to use 
ssGSEA_res_t_age_extrem_lung <- ssGSEA_res_t_age_extrem %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")


mycounts.analysis <- ssGSEA_res_t_age_extrem_lung %>% select(-c(Age, age_3_grps, Sample_Type_Involved, Progression_Lab, Progression_Lab_Inv)) %>% t(.)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")

#log transform and remove any NA
x=log1p(x+1)
x=na.omit(x)
# get your group variable (the condition you want to analyze according to it)
metadata_analysis <- RNA.data.extremes %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_NYU_early_stage_ssGSEA", paste0("", paste0("lung", paste0(v, paste0(".csv"))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_NYU_early_stage_ssGSEA_", paste0("_", paste0("lung", paste0(v, paste0(alpha, paste0("_.pdf")))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



#repeat in lung and compare old rec vs no rec 
#define analysis variable 
v= "Progression_Lab_Inv"
#define colors 
col1 <-"darkred"
col2 <- "orangered"

#table to use 
ssGSEA_res_t_age_extrem_lung <- ssGSEA_res_t_age_extrem %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn") %>% filter(age_3_grps=="old")


mycounts.analysis <- ssGSEA_res_t_age_extrem_lung %>% select(-c(Age, age_3_grps, Sample_Type_Involved, Progression_Lab, Progression_Lab_Inv)) %>% t(.)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
#log transform and remove any NA
x=log1p(x+1)
x=na.omit(x)
# get your group variable (the condition you want to analyze according to it)
metadata_analysis <- RNA.data.extremes %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn") %>% filter(age_3_grps=="old")

group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_NYU_early_stage_ssGSEA", paste0("", paste0("lung_old", paste0(v, paste0(".csv"))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_NYU_early_stage_ssGSEA_", paste0("_", paste0("lung_old", paste0(v, paste0(alpha, paste0("_.pdf")))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



#lung and compare young rec vs no rec 
v= "Progression_Lab_Inv"
#define colors 
col1 <-"blue3"
col2 <- "skyblue2"

#table to use 
ssGSEA_res_t_age_extrem_lung <- ssGSEA_res_t_age_extrem %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn") %>% filter(age_3_grps=="young")


mycounts.analysis <- ssGSEA_res_t_age_extrem_lung %>% select(-c(Age, age_3_grps, Sample_Type_Involved, Progression_Lab, Progression_Lab_Inv)) %>% t(.)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
#log transform and remove any NA
x=log1p(x+1)
x=na.omit(x)
# get your group variable (the condition you want to analyze according to it)
metadata_analysis <- RNA.data.extremes %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn") %>% filter(age_3_grps=="young")

group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_NYU_early_stage_ssGSEA", paste0("", paste0("lung_young", paste0(v, paste0(".csv"))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_NYU_early_stage_ssGSEA_", paste0("_", paste0("lung_young", paste0(v, paste0(alpha, paste0("_.pdf")))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fyoung-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





##################################################################################

################### module gene overlap ########################

#read results of module gene overlap 
res <- read.csv(file = "Data/module_gene_overlap.csv")

plot_data <- res %>% filter(comparison=="edgeR_NYU_early_old_vs_young")
plot_data <- plot_data %>% mutate(Module=factor(Module, levels=unique(Module)))

ggplot(plot_data, aes(x = Module, y=hypergeometric_odds_pos, size = hypergeometric_pval_pos, color=subset)) +
  geom_point() +
  scale_size_continuous(trans = "reverse") +  # Adjust size range as needed
  theme_bw()




##################################################################################
##################################################################################
########################IPA lung only stage I NYU, TCGA#############################

#lung of NYU and TCGA 


IPA_res <- read.csv("IPA/IPA_comparison_NYU_TCGA_Lung_Old_vs_Young.csv")

#get max and min values 
max(IPA_res$NYU_Lung, na.rm = TRUE)
min(IPA_res$NYU_Lung, na.rm = TRUE)
max(IPA_res$TCGA_Lung, na.rm = TRUE)
min(IPA_res$TCGA_Lung, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-1.604, 0, 4.423), c("blue", "white", "orange"))
col_fun(seq(-1.604, 0, 4.423))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/IPA_comparison_NYU_TCGA_Lung_Old_vs_Young_stage_I.pdf", height = 14, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()





#tumor of NYU and TCGA , TRACER


IPA_res <- read.csv("IPA/IPA_comparison_NYU_TCGA_TRACER_Tumor_Old_vs_Young_stage_I_FDR_0.2.csv")

#get max and min values 
max(IPA_res$NYU, na.rm = TRUE)
min(IPA_res$NYU, na.rm = TRUE)
max(IPA_res$TCGA, na.rm = TRUE)
min(IPA_res$TCGA, na.rm = TRUE)
max(IPA_res$TRACERx, na.rm = TRUE)
min(IPA_res$TRACERx, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-6.53, 0, 3.138), c("blue", "white", "orange"))
col_fun(seq(-6.53, 0, 3.138))

#convert data to matrix 
IPA_res_mat <- IPA_res

IPA_res_mat <- IPA_res_mat %>% arrange(desc(NYU))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/IPA_comparison_NYU_TCGA_TRACER_Tumor_Old_vs_Young_stage_I_FDR_0.2.pdf", height = 14, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()




################
#### IPA tumor NYU and TCGA FDR 0.2


IPA_res <- read.csv("IPA/IPA_tumor_NYU_TCGA_FDR_0.2_plot.csv")

#get max and min values 
max(IPA_res$NYU_Tumor_Old, na.rm = TRUE)
min(IPA_res$NYU_Tumor_Old, na.rm = TRUE)
max(IPA_res$NYU_Tumor_Young, na.rm = TRUE)
min(IPA_res$NYU_Tumor_Young, na.rm = TRUE)
max(IPA_res$TCGA_Tumor_Old, na.rm = TRUE)
min(IPA_res$TCGA_Tumor_Old, na.rm = TRUE)
max(IPA_res$TCGA_Tumor_Young, na.rm = TRUE)
min(IPA_res$TCGA_Tumor_Young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-3, 0, 4.025), c("blue", "white", "orange"))
col_fun(seq(-3, 0, 4.025))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/IPA_tumor_NYU_TCGA_FDR_0.2_plot.pdf", height = 20, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()


####IPA Tumor NYU TRACER FDR 0.2

IPA_res <- read.csv("IPA/IPA_tumor_NYU_TRACER_FDR_0.2_plot.csv")

#get max and min values 
max(IPA_res$NYU_Tumor_Old, na.rm = TRUE)
min(IPA_res$NYU_Tumor_Old, na.rm = TRUE)
max(IPA_res$NYU_Tumor_Young, na.rm = TRUE)
min(IPA_res$NYU_Tumor_Young, na.rm = TRUE)
max(IPA_res$TRACER_Tumor_Old, na.rm = TRUE)
min(IPA_res$TRACER_Tumor_Old, na.rm = TRUE)
max(IPA_res$TRACER_Tumor_Young, na.rm = TRUE)
min(IPA_res$TRACER_Tumor_Young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-4.382, 0, 3.558), c("blue", "white", "orange"))
col_fun(seq(-4.382, 0, 3.558))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "IPA/IPA_tumor_NYU_TRACER_FDR_0.2_plot.pdf", height = 20, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()


## IPA lung NYU and TCGA FDR 0.2




###############################################################################
#################### hua model plotting #######################################

res <- read.csv(file = "module_gene_overlap.csv")
res$Module <- factor(res$Module, levels = paste0("module_", 1:20))

#set size vector 
res$size <- 1/res$hypergeometric_pval_both
res$size <- sqrt(res$size)
cutoff <- 1 / 0.05
cutoff <- sqrt(cutoff)
res$size[res$size > cutoff] <- cutoff

# Create a scatter plot
pdf(file = "Figures/RNA/module_data_overlap.pdf", height = 12, width = 22)
ggplot(data = res, aes(x = Module, y = hypergeometric_odds_both, size=size , color = subset)) +
  geom_point() +
  scale_size_continuous(range = c(1,8))+
  facet_wrap(~ comparison) +
  labs(x = "Module", y = "Hypergeometric Odds (Positive)") +
theme_minimal() +
  theme(axis.text.x = element_text(angle = 90))
dev.off()


####################model to identify genes assocaited with recurrence and to see if they are assocaited with age######

# Load required libraries
library(glmnet)

#tumor 

# Load your data (replace 'your_data.csv' with your actual data file)
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

colnames(mycounts) <- gsub("X", "", colnames(mycounts))

# Assuming your outcome variable is in 'y' and your gene expression matrix is 'X'
y <- as.numeric(RNA_data_tumor$Progression)
X <- mycounts %>% select(rownames(RNA_data_tumor)) %>% t()  # Exclude the outcome variable from the features
lambda_seq <- 10^seq(10, -2, length = 100)  # Sequence of lambda values to test

# Fit the LASSO model on the entire dataset
lasso_model <- glmnet(X, y, alpha = 0.5, family = "binomial")

# Find the selected features using cross-validation
cv_fit <- cv.glmnet(X, y, alpha = 0.5, nfolds = 10, family = "binomial", lambda = lambda_seq)
best_lambda <- cv_fit$lambda.min  # Get the lambda with the minimum cross-validated error

# Extract the selected features using the best lambda
lasso_selected_features <- coef(lasso_model, s = best_lambda)
lasso_selected_features <- lasso_selected_features[-1,]
lasso_selected_features <- lasso_selected_features[lasso_selected_features != 0]

# 'lasso_selected_features' now contains the genes selected by LASSO






# Load necessary libraries
library(glmnet)

# Assuming 'X' is your feature matrix, 'y' is your binary response variable (0 or 1), and 'survival_time' is time-to-recurrence data

# Initialize variables to store results
best_model <- NULL
best_features <- NULL
best_lambda <- NULL
best_auc <- 0



train_index <- sample(1:length(y), round(0.7 * length(y)))
train_data <- X[, train_index]
train_outcome <- y[train_index]
test_data <- X[, -train_index]
test_outcome <- y[-train_index]

# Set the number of outer folds for cross-validation
n_outer_folds <- 10

# Step 1: Outer cross-validation loop
for (fold in 1:n_outer_folds) {
  # Split your data into training and test sets based on the fold index
  # Replace this with your own data splitting logic
  training_data <- train_data
  test_data <- test_data
  

  # Step 1b: Inner cross-validation loop to optimize model parameters
  n_inner_folds <- 10  # Number of inner folds
  lambda_seq <- 10^seq(10, -2, length = 100)  # Sequence of lambda values to test
  
  # Initialize variables to store inner cross-validation results
  best_inner_model <- NULL
  best_inner_features <- NULL
  best_inner_lambda <- NULL
  best_inner_auc <- 0
  
  # Inner cross-validation loop
  for (inner_fold in 1:n_inner_folds) {
    # Split your training data into training and validation sets based on the inner fold index
    # Replace this with your own data splitting logic
    inner_train_data <- train_data
    inner_valid_data <- test_data
    
    # Fit logistic regression model with elastic net penalty
    elastic_net_model <- cv.glmnet(x = t(train_data), y = train_outcome, family = "binomial", alpha = 0.5, lambda = lambda_seq)
    
    # Use the optimal lambda to make predictions
    best_lambda <- elastic_net_model$lambda.min
    predicted_prob <- predict(elastic_net_model, newx = test_data, s = best_lambda, type = "response")
    
    # Calculate AUC for inner fold
    prediction_obj <- prediction(predicted_prob, test_outcome)
    roc_auc <- performance(prediction_obj, measure = "auc")
    auc_value <- as.numeric(roc_auc@y.values)
    
    # Check if this model has a better AUC
    if (auc_value > best_inner_auc) {
      best_inner_auc <- auc_value
      best_inner_model <- elastic_net_model
      best_inner_features <- top_N_genes
      best_inner_lambda <- best_lambda
    }
  }
  
  # Step 1c: Use the best model to make predictions on the test data
  elastic_net_model <- best_inner_model
  best_lambda <- best_inner_lambda
  predicted_prob <- predict(elastic_net_model, newx = test_data, s = best_lambda, type = "response")
  
  # Check if this model has a better AUC
  prediction_obj <- prediction(predicted_prob, test_data$y)
  roc_auc <- performance(prediction_obj, measure = "auc")
  auc_value <- as.numeric(roc_auc@y.values)
  if (auc_value > best_auc) {
    best_auc <- auc_value
    best_model <- elastic_net_model
    best_features <- top_N_genes
  }
}

# The 'best_model' now contains the best model from the cross-validation process.
# 'best_features' contains the selected features, and 'best_auc' contains the corresponding AUC value.

# You can use 'best_model' and 'best_features' for your final model and selected features.




res <- read.csv(file = "Results/RNA/edgeR.results_age_3_grp_tumor.csv")

sig_genes <- res %>% filter(FDR<=0.2, logFC>0)

#get genes list 
selected_genes <- sig_genes %>% dplyr::select(Gene.symbol, logFC)

gene_expression_subset <- mycounts[selected_genes$Gene.symbol, ]
gene_expression_subset <- gene_expression_subset %>% select(starts_with("NYU"))

surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))


data_df <- data.frame(age = RNA_data_tumor$Age, t(gene_expression_subset), surv_obj)

# Prepare the data for modeling
X <-  data_df %>% select(-c(age, surv_obj))  # Features (excluding time and event)
y <- data_df$surv_obj  # Survival object (time and event)

# Fit a Cox regression model with LASSO penalty
lasso_model <- cv.glmnet(x =as.matrix(X), y = y, alpha = 1, family = "cox")

# Get the selected features based on the optimal lambda
best_lambda <- lasso_model$lambda.min
lasso_selected_features <- coef(lasso_model, s = best_lambda)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

data_df %>% select(rownames(selected_genes))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed)

RNA_data_tumor$risk_score <- final_risk_score
RNA_data_tumor$aging_signature <- ifelse(RNA_data_tumor$risk_score > median(RNA_data_tumor$risk_score), "Aging Signature Present", "Aging Signature Absent")
RNA_data_tumor$age_3_grps <- ifelse(RNA_data_tumor$Age >74, "old",
                              ifelse(RNA_data_tumor$Age < 66, "young", 
                                     "middle"))

#


ggplot(data = RNA_data_tumor, aes(x=age_3_grps, y=risk_score))+
  geom_boxplot()+
  stat_compare_means(comparisons = list(c("middle", "old"), 
                                        c("old", "young"), 
                                        c("middle", "young")))

table_counts <- table(RNA_data_tumor$aging_signature, RNA_data_tumor$Progression)


ggplot(RNA_data_tumor, aes(x = aging_signature, fill = Progression)) +
  geom_bar(position = "dodge")
    

# Assuming you have a dataset with the following columns: 'AgingSignature' (0 for absent, 1 for present) and 'TimeToRecurrence' (time to recurrence event)
# Replace 'your_data' with the name of your dataset

# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature, data = RNA_data_tumor)

# Plot the Kaplan-Meier curve
ggsurvplot(
  surv_fit,
  data = RNA_data_tumor,
  pval = TRUE,  # Add p-value for the comparison between groups
  conf.int = TRUE,  # Add confidence intervals
  risk.table = TRUE,  # Add a risk table
  legend.title = "Aging Signature",
  xlab = "Time (in months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Survival Curve by Aging Signature"
)











res <- read.csv(file = "Results/RNA/edgeR.results_age_3_grp_lung.csv")

sig_genes <- res %>% filter(FDR<=0.2, logFC>0)

#get genes list 
selected_genes <- sig_genes %>% dplyr::select(Gene.symbol, logFC)

gene_expression_subset <- mycounts[selected_genes$Gene.symbol, ]
gene_expression_subset <- gene_expression_subset %>% select(-starts_with("NYU"))

surv_obj <- Surv(time = as.numeric(RNA_data_lung$New_TTP), event = as.numeric(RNA_data_lung$Progression))


data_df <- data.frame(age = RNA_data_lung$Age, t(gene_expression_subset), surv_obj)

# Prepare the data for modeling
X <-  data_df %>% select(-c(age, surv_obj))  # Features (excluding time and event)
y <- data_df$surv_obj  # Survival object (time and event)

# Fit a Cox regression model with LASSO penalty
lasso_model <- cv.glmnet(x =as.matrix(X), y = y, alpha = 1, family = "cox")

# Get the selected features based on the optimal lambda
best_lambda <- lasso_model$lambda.min
lasso_selected_features <- coef(lasso_model, s = best_lambda)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)


e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed)

RNA_data_lung$risk_score <- final_risk_score
RNA_data_lung$aging_signature <- ifelse(RNA_data_lung$risk_score > median(RNA_data_lung$risk_score), "Aging Signature Present", "Aging Signature Absent")
RNA_data_lung$age_3_grps <- ifelse(RNA_data_lung$Age >74, "old",
                                    ifelse(RNA_data_lung$Age < 66, "young", 
                                           "middle"))

#


ggplot(data = RNA_data_lung, aes(x=age_3_grps, y=risk_score))+
  geom_boxplot()+
  stat_compare_means(comparisons = list(c("middle", "old"), 
                                        c("old", "young"), 
                                        c("middle", "young")))



ggplot(RNA_data_lung, aes(x = aging_signature, fill = Progression)) +
  geom_bar(position = "dodge")


# Assuming you have a dataset with the following columns: 'AgingSignature' (0 for absent, 1 for present) and 'TimeToRecurrence' (time to recurrence event)
# Replace 'your_data' with the name of your dataset

# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_lung$New_TTP), event = as.numeric(RNA_data_lung$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature, data = RNA_data_lung)

# Plot the Kaplan-Meier curve
ggsurvplot(
  surv_fit,
  data = RNA_data_lung,
  pval = TRUE,  # Add p-value for the comparison between groups
  conf.int = TRUE,  # Add confidence intervals
  risk.table = TRUE,  # Add a risk table
  legend.title = "Aging Signature",
  xlab = "Time (in months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Survival Curve by Aging Signature"
)








genes_list_1 <- read.csv(file = "saul.cells.gene.list.csv")
genes_list_2 <- read.csv(file = "genes_associated_with_age_peters_et_al.csv")
#combine both lists and keep distinct only 
genes_list <- bind_rows(genes_list_1, genes_list_2)
genes_list <- genes_list %>% distinct(., .keep_all = TRUE) ##### results in 2532 unique genes associated with old age 

mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

subset_counts <- mycounts[genes_list$Gene,]

gene_expression_subset <- subset_counts %>% select(starts_with("NYU"))

surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))


data_df <- data.frame(age = RNA_data_tumor$Age, t(gene_expression_subset), surv_obj)
data_df <- data_df %>% select(-starts_with("NA"))

# Prepare the data for modeling
X <-  data_df %>% select(-c(age, surv_obj))  # Features (excluding time and event)
y <- data_df$surv_obj  # Survival object (time and event)

# Fit a Cox regression model with LASSO penalty
lasso_model <- cv.glmnet(x =as.matrix(X), y = y, alpha = 1, family = "cox")

# Get the selected features based on the optimal lambda
best_lambda <- lasso_model$lambda.min
lasso_selected_features <- coef(lasso_model, s = best_lambda)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

data_df %>% select(rownames(selected_genes))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed)

RNA_data_tumor$risk_score <- final_risk_score
RNA_data_tumor$aging_signature <- ifelse(RNA_data_tumor$risk_score > median(RNA_data_tumor$risk_score), "Aging Signature Present", "Aging Signature Absent")
RNA_data_tumor$age_3_grps <- ifelse(RNA_data_tumor$Age >74, "old",
                                    ifelse(RNA_data_tumor$Age < 66, "young", 
                                           "middle"))

#


ggplot(data = RNA_data_tumor, aes(x=age_3_grps, y=risk_score))+
  geom_boxplot()+
  stat_compare_means(comparisons = list(c("middle", "old"), 
                                        c("old", "young"), 
                                        c("middle", "young")))

table_counts <- table(RNA_data_tumor$aging_signature, RNA_data_tumor$Progression)


ggplot(RNA_data_tumor, aes(x = aging_signature, fill = Progression)) +
  geom_bar(position = "dodge")


# Assuming you have a dataset with the following columns: 'AgingSignature' (0 for absent, 1 for present) and 'TimeToRecurrence' (time to recurrence event)
# Replace 'your_data' with the name of your dataset

# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature, data = RNA_data_tumor)

# Plot the Kaplan-Meier curve
ggsurvplot(
  surv_fit,
  data = RNA_data_tumor,
  pval = TRUE,  # Add p-value for the comparison between groups
  conf.int = TRUE,  # Add confidence intervals
  risk.table = TRUE,  # Add a risk table
  legend.title = "Aging Signature",
  xlab = "Time (in months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Survival Curve by Aging Signature"
)


################################################################################
Zhang_genes <- c("ZNF101", "PLEKHB1",
                 "P2RX1", "EIF2AK3", "LPAR6", "ATF7IP2", "MS4A1", "CCR2", "ZNF10", "AKTIP",
                 "GNG7", "DAAM2", "PTTG1", "IL1R2", "KYNU", "TCN1", "ITGA6", "AHSA1", "DSC1",
                 "LINGO2", "C1QTNF6")



genes_list <- Zhang_genes

mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

subset_counts <- mycounts[genes_list,]

gene_expression_subset <- subset_counts %>% select(starts_with("NYU"))

surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))


data_df <- data.frame(age = RNA_data_tumor$Age, t(gene_expression_subset), surv_obj)
data_df <- data_df %>% select(-starts_with("NA"))

# Prepare the data for modeling
X <-  data_df %>% select(-c(age, surv_obj))  # Features (excluding time and event)
y <- data_df$surv_obj  # Survival object (time and event)

# Fit a Cox regression model with LASSO penalty
lasso_model <- cv.glmnet(x =as.matrix(X), y = y, alpha = 1, family = "cox")

# Get the selected features based on the optimal lambda
best_lambda <- lasso_model$lambda.min
lasso_selected_features <- coef(lasso_model, s = best_lambda)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

data_df %>% select(rownames(selected_genes))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e 

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed)

RNA_data_tumor$risk_score <- final_risk_score
RNA_data_tumor$aging_signature <- ifelse(RNA_data_tumor$risk_score > median(RNA_data_tumor$risk_score), "Aging Signature Present", "Aging Signature Absent")
RNA_data_tumor$age_3_grps <- ifelse(RNA_data_tumor$Age >74, "old",
                                    ifelse(RNA_data_tumor$Age < 66, "young", 
                                           "middle"))

#


ggplot(data = RNA_data_tumor, aes(x=age_3_grps, y=risk_score))+
  geom_boxplot()+
  stat_compare_means()

table_counts <- table(RNA_data_tumor$aging_signature, RNA_data_tumor$Progression)


ggplot(RNA_data_tumor, aes(x = age_3_grps, fill = Progression)) +
  geom_bar(position = "dodge")


# Assuming you have a dataset with the following columns: 'AgingSignature' (0 for absent, 1 for present) and 'TimeToRecurrence' (time to recurrence event)
# Replace 'your_data' with the name of your dataset

# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature, data = RNA_data_tumor)

# Plot the Kaplan-Meier curve
ggsurvplot(
  surv_fit,
  data = RNA_data_tumor,
  pval = TRUE,  # Add p-value for the comparison between groups
  conf.int = TRUE,  # Add confidence intervals
  risk.table = TRUE,  # Add a risk table
  legend.title = "Aging Signature",
  xlab = "Time (in months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Survival Curve by Aging Signature"
)




genes_list <- c("CAMP", "C5AR1", "DEFB1", "MYD88", "TLR2" )



mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

subset_counts <- mycounts[genes_list,]

gene_expression_subset <- subset_counts %>% select(starts_with("NYU"))

surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))


data_df <- data.frame(age = RNA_data_tumor$Age, t(gene_expression_subset), surv_obj)
data_df <- data_df %>% select(-starts_with("NA"))

# Prepare the data for modeling
X <-  data_df %>% select(-c(age, surv_obj))  # Features (excluding time and event)
y <- data_df$surv_obj  # Survival object (time and event)

# Fit a Cox regression model with LASSO penalty
lasso_model <- cv.glmnet(x =as.matrix(X), y = y, alpha = 1, family = "cox")

# Get the selected features based on the optimal lambda
best_lambda <- lasso_model$lambda.min
lasso_selected_features <- coef(lasso_model, s = best_lambda)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

data_df %>% select(rownames(selected_genes))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e 

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed)

RNA_data_tumor$risk_score <- final_risk_score
RNA_data_tumor$aging_signature <- ifelse(RNA_data_tumor$risk_score > median(RNA_data_tumor$risk_score), "Aging Signature Present", "Aging Signature Absent")
RNA_data_tumor$age_3_grps <- ifelse(RNA_data_tumor$Age >74, "old",
                                    ifelse(RNA_data_tumor$Age < 66, "young", 
                                           "middle"))

#


ggplot(data = RNA_data_tumor, aes(x=age_3_grps, y=risk_score))+
  geom_boxplot()+
  stat_compare_means(comparisons = list(c("middle", "old"), 
                                        c("old", "young"), 
                                        c("middle", "young")))

table_counts <- table(RNA_data_tumor$aging_signature, RNA_data_tumor$Progression)


ggplot(RNA_data_tumor, aes(x = aging_signature, fill = Progression)) +
  geom_bar(position = "dodge")


# Assuming you have a dataset with the following columns: 'AgingSignature' (0 for absent, 1 for present) and 'TimeToRecurrence' (time to recurrence event)
# Replace 'your_data' with the name of your dataset

# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature, data = RNA_data_tumor)

# Plot the Kaplan-Meier curve
ggsurvplot(
  surv_fit,
  data = RNA_data_tumor,
  pval = TRUE,  # Add p-value for the comparison between groups
  conf.int = TRUE,  # Add confidence intervals
  risk.table = TRUE,  # Add a risk table
  legend.title = "Aging Signature",
  xlab = "Time (in months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Survival Curve by Aging Signature"
)




# check IL-6 levels 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)


gene_expression_subset <- mycounts %>% select(starts_with("NYU"))

res <- gene_expression_subset %>% t() %>% data.frame() %>% select(IL6, IL6R)


res$age_3_grps <- RNA_data_tumor$age_3_grps
ggplot(res ,aes(x=age_3_grps, y=IL6))+
  geom_boxplot()+
  geom_jitter()+
  stat_compare_means(comparisons = list(c("middle", "old"), 
                                        c("old", "young"), 
                                        c("middle", "young")))+
  scale_y_log10()


#IL6R
ggplot(res ,aes(x=age_3_grps, y=IL6R))+
  geom_boxplot()+
  geom_jitter()+
  stat_compare_means(comparisons = list(c("middle", "old"), 
                                        c("old", "young"), 
                                        c("middle", "young")))+
  scale_y_log10()










#### check mortality in patients with advanced stage mortiality signature genes 

genes_list <- c("CAMP", "C5AR1", "DEFB1", "MYD88", "TLR2" )





mycounts <-mycounts_advanced

subset_counts <- mycounts[genes_list,]

surv_data <- NYU_adv_metadata_filtered %>% select(OS_days, death)
surv_data$OS_days <- as.numeric(surv_data$OS_days)
surv_data$death <- as.numeric(surv_data$death)

surv_obj <- Surv(time = surv_data$OS_days, event = surv_data$death)


data_df <- data.frame(age = NYU_adv_metadata_filtered$Age, t(subset_counts), surv_obj)

# Prepare the data for modeling
X <-  data_df %>% select(-c(age, surv_obj))  # Features (excluding time and event)
y <- data_df$surv_obj  # Survival object (time and event)

# Fit a Cox regression model with LASSO penalty
lasso_model <- cv.glmnet(x =as.matrix(X), y = y, alpha = 1, family = "cox")

# Get the selected features based on the optimal lambda
best_lambda <- lasso_model$lambda.min
lasso_selected_features <- coef(lasso_model, s = best_lambda)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

data_df %>% select(rownames(selected_genes))

e <- log2(subset_counts+1)

#build individual risk score for every patient and every gene 
risk_scores <- e 

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed)

NYU_adv_metadata_filtered$risk_score <- final_risk_score
NYU_adv_metadata_filtered$aging_signature <- ifelse(NYU_adv_metadata_filtered$risk_score > median(NYU_adv_metadata_filtered$risk_score), "Aging Signature Present", "Aging Signature Absent")

#


ggplot(data = NYU_adv_metadata_filtered, aes(x=age_3_grps, y=risk_score))+
  geom_boxplot()+
  stat_compare_means(comparisons = list(c("middle", "old"), 
                                        c("old", "young"), 
                                        c("middle", "young")))

table_counts <- table(NYU_adv_metadata_filtered$aging_signature, NYU_adv_metadata_filtered$death)


ggplot(NYU_adv_metadata_filtered, aes(x = aging_signature, fill = death)) +
  geom_bar(position = "dodge")


# Assuming you have a dataset with the following columns: 'AgingSignature' (0 for absent, 1 for present) and 'TimeToRecurrence' (time to recurrence event)
# Replace 'your_data' with the name of your dataset

# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- surv_obj

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature, data = NYU_adv_metadata_filtered)

# Plot the Kaplan-Meier curve
ggsurvplot(
  surv_fit,
  data = NYU_adv_metadata_filtered,
  pval = TRUE,  # Add p-value for the comparison between groups
  conf.int = TRUE,  # Add confidence intervals
  risk.table = TRUE,  # Add a risk table
  legend.title = "Aging Signature",
  xlab = "Time (in months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Survival Curve by Aging Signature"
)





res <- mycounts_advanced %>% t() %>% data.frame() %>% select(IL6, IL6R)


res$age_3_grps <- NYU_adv_metadata_filtered$age_3_grps
ggplot(res ,aes(x=age_3_grps, y=IL6))+
  geom_boxplot()+
  geom_jitter()+
  stat_compare_means(comparisons = list(c("middle", "old"), 
                                        c("old", "young"), 
                                        c("middle", "young")))+
  scale_y_log10()


#IL6R
ggplot(res ,aes(x=age_3_grps, y=IL6R))+
  geom_boxplot()+
  geom_jitter()+
  stat_compare_means(comparisons = list(c("middle", "old"), 
                                        c("old", "young"), 
                                        c("middle", "young")))+
  scale_y_log10()






#read fulle counts 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

#read tumor results 
res <- read.csv(file = "Results/RNA/edgeR.results_age_3_grp_tumor.csv")

#filter significant ones only 
res <- res %>% filter(FDR <= 0.1)

meta <- RNA_data_tumor %>% filter(ProgType_Lab!="Systemic")

obstime <- as.numeric(meta$New_time_followup.or.death)
delta <- as.numeric(meta$Progression)

counts <- mycounts[res$Gene.symbol,]

RA.com <- counts

RA.tem <- RA.com[,rownames(meta)]

library(survival)
library(survminer)

model_data <- data.frame(obstime, delta, meta$Age, meta$Male_1 )

cox.results <- NULL

 for(i in 1:nrow(RA.tem)){
   # Create a data frame with selected columns
   genes_data <- t(RA.tem)
   
   # Fit Cox proportional hazards regression model
   fit.surv <- coxph(Surv(obstime, delta) ~ . + meta.Age + meta.Male_1, data = cbind(model_data, genes_data))
   
   # Extract coefficients and p-value
   coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")
  
write.csv(cox.results, file="Results/RNA/COX_PH_genes_assocaited_with_age_tumor.csv")

#filter only sig genes 
sig_cox <- cox.results %>% filter(adj.p<=0.2)


#beneficical genes 
ben_genes <- sig_cox %>% filter(hr<=1)

#determinant genes 
deter_genes <- sig_cox %>% filter(hr>1)
deter_genes <- deter_genes[-1,]
deter_genes <- deter_genes[-1,]


## the inner CV regarding tuning parameters
folds.inner <- createFolds(meta$Progression, k = 10, list = FALSE)

RNA.training <- RA.tem[rownames(deter_genes),]

delta.training <- meta$Progression

tunings=NULL
for(alpha0 in (seq(0,20,1)/20)^2) {
  
  cvfit <- cv.glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family="binomial",
                     type.measure="auc", foldid=folds.inner, alpha=alpha0, keep=TRUE)
  tunings=rbind(tunings, cbind(rep(alpha0,length(cvfit$lambda)),cvfit$lambda,cvfit$cvm))
}  

colnames(tunings)=c("alpha", "lambda","cvm")
tunings=data.frame(tunings)
tunings=tunings[which.max(tunings$cvm),]

## the optimal model based on the training
fit <- glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family = "binomial",
              alpha=tunings$alpha,lambda =tunings$lambda)

coef(fit)


lasso_selected_features <- coef(fit)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

gene_expression_subset <- mycounts[rownames(selected_genes),]
gene_expression_subset <- gene_expression_subset %>% select(starts_with("NYU"))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed)

RNA_data_tumor$risk_score <- final_risk_score
RNA_data_tumor$aging_signature <- ifelse(RNA_data_tumor$risk_score > median(RNA_data_tumor$risk_score), "Aging Signature Present", "Aging Signature Absent")
RNA_data_tumor$age_3_grps <- ifelse(RNA_data_tumor$Age >74, "old",
                                    ifelse(RNA_data_tumor$Age < 66, "young", 
                                           "middle"))

#


ggplot(data = RNA_data_tumor, aes(x=age_3_grps, y=risk_score))+
  geom_boxplot()+
  stat_compare_means(comparisons = list(c("middle", "old"), 
                                        c("old", "young"), 
                                        c("middle", "young")))

table_counts <- table(RNA_data_tumor$aging_signature, RNA_data_tumor$Progression)


ggplot(RNA_data_tumor, aes(x = aging_signature, fill = Progression)) +
  geom_bar(position = "dodge")

# Create a contingency table for the chi-squared test
contingency_table <- table(RNA_data_tumor$aging_signature, RNA_data_tumor$Progression)

# Perform the chi-squared test
chi_squared_result <- chisq.test(contingency_table)

# Print the p-value from the chi-squared test
p_value <- chi_squared_result$p.value
cat("Chi-squared p-value:", p_value, "\n")

# Assuming you have a dataset with the following columns: 'AgingSignature' (0 for absent, 1 for present) and 'TimeToRecurrence' (time to recurrence event)
# Replace 'your_data' with the name of your dataset

# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature, data = RNA_data_tumor)

# Plot the Kaplan-Meier curve
ggsurvplot(
  surv_fit,
  data = RNA_data_tumor,
  pval = TRUE,  # Add p-value for the comparison between groups
  conf.int = TRUE,  # Add confidence intervals
  risk.table = TRUE,  # Add a risk table
  legend.title = "Aging Signature",
  xlab = "Time (in months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Survival Curve by Aging Signature"
)





#aging and recurrence associated genes are deter_genes 
#now find expression of those genes and categorize patients as having them or not 

#try to categorize patients according to the signatures 


















#Lung 

#read fulle counts 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

#read tumor results 
res <- read.csv(file = "Results/RNA/edgeR.results_age_3_grp_lung.csv")

#filter significant ones only 
res <- res %>% filter(FDR <= 0.1)

meta <- RNA_data_lung %>% filter(ProgType_Lab!="Systemic")

obstime <- as.numeric(meta$New_time_followup.or.death)
delta <- as.numeric(meta$Progression)

counts <- mycounts[res$Gene.symbol,]

RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))

RA.tem <- RA.com[,rownames(meta)]

library(survival)
library(survminer)

model_data <- data.frame(obstime, delta, meta$Age, meta$Male_1 )

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . + meta.Age + meta.Male_1, data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="Results/RNA/COX_PH_genes_assocaited_with_age_lung.csv")

#filter only sig genes 
sig_cox <- cox.results %>% filter(adj.p<=0.2)


#beneficical genes 
ben_genes <- sig_cox %>% filter(hr<=1)

#determinant genes 
deter_genes <- sig_cox %>% filter(hr>1)
deter_genes <- deter_genes[-1,]


## the inner CV regarding tuning parameters
folds.inner <- createFolds(RNA_data_lung$Progression, k = 10, list = FALSE)

RNA.training <- mycounts <- mycounts %>% select(-starts_with("NYU"))

RNA.training <- na.omit(RNA.training)

delta.training <- RNA_data_lung$Progression

tunings=NULL
for(alpha0 in (seq(0,20,1)/20)^2) {
  
  cvfit <- cv.glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family="binomial",
                     type.measure="auc", foldid=folds.inner, alpha=alpha0, keep=TRUE)
  tunings=rbind(tunings, cbind(rep(alpha0,length(cvfit$lambda)),cvfit$lambda,cvfit$cvm))
}  

colnames(tunings)=c("alpha", "lambda","cvm")
tunings=data.frame(tunings)
tunings=tunings[which.max(tunings$cvm),]

## the optimal model based on the training
fit <- glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family = "binomial",
              alpha=tunings$alpha,lambda =tunings$lambda)

coef(fit)


lasso_selected_features <- coef(fit)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

gene_expression_subset <- mycounts[rownames(selected_genes),]
gene_expression_subset <- gene_expression_subset %>% select(-starts_with("NYU"))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes

risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed)

RNA_data_lung$risk_score <- final_risk_score
RNA_data_lung$aging_signature <- ifelse(RNA_data_lung$risk_score > median(RNA_data_lung$risk_score), "Aging Signature Present", "Aging Signature Absent")
RNA_data_lung$age_3_grps <- ifelse(RNA_data_lung$Age >74, "old",
                                    ifelse(RNA_data_lung$Age < 66, "young", 
                                           "middle"))

#


ggplot(data = RNA_data_lung, aes(x=age_3_grps, y=risk_score))+
  geom_boxplot()+
  stat_compare_means(comparisons = list(c("middle", "old"), 
                                        c("old", "young"), 
                                        c("middle", "young")))

ggplot(data = RNA_data_lung, aes(x=age_grp, y=risk_score))+
  geom_boxplot()+
  stat_compare_means()

table_counts <- table(RNA_data_lung$aging_signature, RNA_data_lung$Progression)


ggplot(RNA_data_lung, aes(x = aging_signature, fill = Progression)) +
  geom_bar(position = "dodge")

# Create a contingency table for the chi-squared test
contingency_table <- table(RNA_data_lung$aging_signature, RNA_data_lung$Progression)

# Perform the chi-squared test
chi_squared_result <- chisq.test(contingency_table)

# Print the p-value from the chi-squared test
p_value <- chi_squared_result$p.value
cat("Chi-squared p-value:", p_value, "\n")

# Assuming you have a dataset with the following columns: 'AgingSignature' (0 for absent, 1 for present) and 'TimeToRecurrence' (time to recurrence event)
# Replace 'your_data' with the name of your dataset

# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_lung$New_TTP), event = as.numeric(RNA_data_lung$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature, data = RNA_data_lung)

# Plot the Kaplan-Meier curve
ggsurvplot(
  surv_fit,
  data = RNA_data_lung,
  pval = TRUE,  # Add p-value for the comparison between groups
  conf.int = TRUE,  # Add confidence intervals
  risk.table = TRUE,  # Add a risk table
  legend.title = "Aging Signature",
  xlab = "Time (in months)",
  ylab = "Survival Probability",
  title = "Kaplan-Meier Survival Curve by Aging Signature"
)

















############## Building risk score from peters et al genes using Cox and Elastic Net model ##########
##### Tumor subset ####

#read counts 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)
#read peters genes list 
genes_list_2 <- read.csv(file = "genes_associated_with_age_peters_et_al.csv")
#filter metadata to include recurrence events without second primary 
meta <- RNA_data_tumor %>% filter(ProgType_Lab!="Secondary.Primary")
#get time and outcome to build survival object
obstime <- as.numeric(meta$New_TTP)
delta <- as.numeric(meta$Progression)
#get genes needed for the Cox model
counts <- mycounts[genes_list_2$Gene,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

#Run Cox model to find genes associated with recurrence 
library(survival)
library(survminer)
model_data <- data.frame(obstime, delta, meta$Age, meta$Male_1 )
cox.results <- NULL
#loop over every gene
for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . + meta.Age + meta.Male_1, data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}
# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]
# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]
# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]

# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

#output results 
write.csv(cox.results, file="Results/RNA/COX_PH_genes_assocaited_with_age_tumor_from_peters_genes.csv")

#filter only sig genes 
sig_cox <- cox.results %>% filter(adj.p<=0.2)

#beneficical genes : HR < 1 
ben_genes <- sig_cox %>% filter(hr<=1)

#determinant genes : HR > 1 
deter_genes <- sig_cox %>% filter(hr>1)
#deter_genes <- deter_genes[-1,]

# Run elastic net model using 10k folds
## the inner CV regarding tuning parameters
folds.inner <- createFolds(meta$Progression, k = 10, list = FALSE)
RNA.training <- RA.tem[rownames(deter_genes),]
delta.training <- meta$Progression

tunings=NULL
for(alpha0 in (seq(0,20,1)/20)^2) {
  
  cvfit <- cv.glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family="binomial",
                     type.measure="auc", foldid=folds.inner, alpha=alpha0, keep=TRUE)
  tunings=rbind(tunings, cbind(rep(alpha0,length(cvfit$lambda)),cvfit$lambda,cvfit$cvm))
}  

colnames(tunings)=c("alpha", "lambda","cvm")
tunings=data.frame(tunings)
tunings=tunings[which.max(tunings$cvm),]

## the optimal model based on the training
fit <- glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family = "binomial",
              alpha=tunings$alpha,lambda =tunings$lambda)

#get coeficients 
lasso_selected_features <- coef(fit)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

write.csv(selected_genes, file = "Results/RNA/genes_aging_risk_score_elastic_cox_tumor.csv")

#calculate risk score: risk score is = Log[Coef * gene expression values (add 1 to normalization)]
gene_expression_subset <- mycounts[rownames(selected_genes),]
gene_expression_subset <- gene_expression_subset %>% select(starts_with("NYU"))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes
#transpose to calculate finall score for every patients
risk_scores_t <- t(risk_scores)
#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed) here using median as cutoff
RNA_data_tumor$risk_score <- final_risk_score
RNA_data_tumor$aging_signature <- ifelse(RNA_data_tumor$risk_score > median(RNA_data_tumor$risk_score), "Aging Signature Present", "Aging Signature Absent")
RNA_data_tumor$age_3_grps <- ifelse(RNA_data_tumor$Age >74, "old",
                                   ifelse(RNA_data_tumor$Age < 66, "young", 
                                          "middle"))
RNA_data_tumor$age_3_grps <- factor(RNA_data_tumor$age_3_grps, levels = c("young", "middle", "old"))

# Plot 
#compare risk score among age groups 
pdf(file = "Figures/RNA/risk_score_age_3_grps_tumor.pdf", height = 8, width = 6)
ggplot(data = RNA_data_tumor, aes(x=age_3_grps, y=risk_score, color=age_3_grps))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "yellow2", "blue3"))+
  scale_x_discrete( labels=c("Young", "Middle", "Old"))+
  stat_compare_means(comparisons = list(c("middle", "young"), 
                                        c("middle", "old"), 
                                        c("young", "old")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()

#compare risk score between old and young according to median age 
pdf(file = "Figures/RNA/risk_score_age_grp_tumor.pdf", height = 8, width = 6)
ggplot(data = RNA_data_tumor, aes(x=age_grp, y=risk_score, color=age_grp))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("blue3", "green4"))+
  scale_x_discrete( labels=c("Old", "Young"))+
  stat_compare_means(comparisons = list(c("old", "young")))+  
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()

#compare progression across aging signature groups 
table_counts <- table(RNA_data_tumor$aging_signature, RNA_data_tumor$Progression)

pdf(file = "Figures/RNA/progression_aging_signature_tumor.pdf", height = 8, width = 6)
ggplot(RNA_data_tumor, aes(x = aging_signature, fill = Progression)) +
  geom_bar(position = "dodge")+
  scale_fill_manual(values = c("orange", "red"), labels=c("0"= "No Recurrence", "1"="Recurrence"))+
  theme_bw()+
  xlab("Aging Signature")+ylab("")+labs(fill="")+
  scale_x_discrete(labels=c("Absent", "Present"))+
  ggtitle("p_value of 0.99")+
  theme(axis.text.x = element_text(size = 14, face = "bold", angle = 45, vjust = 0.5), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()

# Create a contingency table for the chi-squared test
contingency_table <- table(RNA_data_tumor$aging_signature, RNA_data_tumor$Progression)

# Perform the chi-squared test
chi_squared_result <- chisq.test(contingency_table)

# Print the p-value from the chi-squared test
p_value <- chi_squared_result$p.value
cat("Chi-squared p-value:", p_value, "\n")

###### compare survival across aging signatures groups 
# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature, data = RNA_data_tumor)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = RNA_data_tumor,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Absent", "Present"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot


#comparison without second primary 

surv_data <- RNA_data_tumor %>% filter(ProgType_Lab!="Secondary.Primary")
# Create a survival object
surv_obj <- Surv(time = as.numeric(surv_data$New_TTP), event = as.numeric(surv_data$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature, data = surv_data)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = surv_data,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Absent", "Present"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot










##### Lung subset ####
#read counts
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)
#read genes list from peters et al
genes_list_2 <- read.csv(file = "genes_associated_with_age_peters_et_al.csv")
#get metadata without second primary
meta <- RNA_data_lung %>% filter(ProgType_Lab!="Secondary.Primary")
#prepare survival object 
obstime <- as.numeric(meta$New_TTP)
delta <- as.numeric(meta$Progression)
#get relevant counts from genes list 
counts <- mycounts[genes_list_2$Gene,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

#run Cox model to find genes associated with recurrence 
library(survival)
library(survminer)
model_data <- data.frame(obstime, delta, meta$Age, meta$Male_1 )
cox.results <- NULL
for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . + meta.Age + meta.Male_1, data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]

# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")
#write resutls 
write.csv(cox.results, file="Results/RNA/COX_PH_genes_assocaited_with_age_lung_from_peters_genes.csv")

#filter only sig genes 
sig_cox <- cox.results %>% filter(adj.p<=0.2)

#beneficical genes 
ben_genes <- sig_cox %>% filter(hr<=1)

#determinant genes 
deter_genes <- sig_cox %>% filter(hr>1)
deter_genes <- deter_genes[-1,]

#Run elastic net model to reduce number of genes. 10 folds 
folds.inner <- createFolds(meta$Progression, k = 10, list = FALSE)
#RNA.training <- mycounts <- mycounts %>% select(starts_with("NYU"))
RNA.training <- RA.tem[rownames(deter_genes),]
delta.training <- meta$Progression
tunings=NULL
for(alpha0 in (seq(0,20,1)/20)^2) {
  
  cvfit <- cv.glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family="binomial",
                     type.measure="auc", foldid=folds.inner, alpha=alpha0, keep=TRUE)
  tunings=rbind(tunings, cbind(rep(alpha0,length(cvfit$lambda)),cvfit$lambda,cvfit$cvm))
}  

colnames(tunings)=c("alpha", "lambda","cvm")
tunings=data.frame(tunings)
tunings=tunings[which.max(tunings$cvm),]

## the optimal model based on the training
fit <- glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family = "binomial",
              alpha=tunings$alpha,lambda =tunings$lambda)

#get coefficients 
lasso_selected_features <- coef(fit)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

write.csv(selected_genes, file = "Results/RNA/genes_aging_risk_score_elastic_cox_lung.csv")

#construct risk score as done in tumor 
gene_expression_subset <- mycounts[rownames(selected_genes),]
gene_expression_subset <- gene_expression_subset %>% select(-starts_with("NYU"))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes
risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed)
RNA_data_lung$risk_score <- final_risk_score
RNA_data_lung$aging_signature <- ifelse(RNA_data_lung$risk_score > median(RNA_data_lung$risk_score), "Aging Signature Present", "Aging Signature Absent")
RNA_data_lung$age_3_grps <- ifelse(RNA_data_lung$Age >74, "old",
                                    ifelse(RNA_data_lung$Age < 66, "young", 
                                           "middle"))


RNA_data_lung$age_3_grps <- factor(RNA_data_lung$age_3_grps, levels = c("young", "middle", "old"))

# Plot 
#compare risk score among age groups 
pdf(file = "Figures/RNA/risk_score_age_3_grps_lung.pdf", height = 8, width = 6)
ggplot(data = RNA_data_lung, aes(x=age_3_grps, y=risk_score, color=age_3_grps))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "yellow2", "blue3"))+
  scale_x_discrete( labels=c("Young", "Middle", "Old"))+
  stat_compare_means(comparisons = list(c("middle", "young"), 
                                        c("middle", "old"), 
                                        c("young", "old")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()

#compare risk score between old and young according to median age 
pdf(file = "Figures/RNA/risk_score_age_grp_lung.pdf", height = 8, width = 6)
ggplot(data = RNA_data_lung, aes(x=age_grp, y=risk_score, color=age_grp))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("blue3", "green4"))+
  scale_x_discrete( labels=c("Old", "Young"))+
  stat_compare_means(comparisons = list(c("old", "young")))+  
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()

#compare progression across aging signature groups 
table_counts <- table(RNA_data_lung$aging_signature, RNA_data_lung$Progression)

pdf(file = "Figures/RNA/progression_aging_signature_lung.pdf", height = 8, width = 6)
ggplot(RNA_data_lung, aes(x = aging_signature, fill = Progression)) +
  geom_bar(position = "dodge")+
  scale_fill_manual(values = c("orange", "red"), labels=c("0"= "No Recurrence", "1"="Recurrence"))+
  theme_bw()+
  xlab("Aging Signature")+ylab("")+labs(fill="")+
  scale_x_discrete(labels=c("Absent", "Present"))+
  ggtitle("p_value of < 0.001")+
  theme(axis.text.x = element_text(size = 14, face = "bold", angle = 45, vjust = 0.5), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()

# Create a contingency table for the chi-squared test
contingency_table <- table(RNA_data_lung$aging_signature, RNA_data_lung$Progression)

# Perform the chi-squared test
chi_squared_result <- chisq.test(contingency_table)

# Print the p-value from the chi-squared test
p_value <- chi_squared_result$p.value
cat("Chi-squared p-value:", p_value, "\n")

###### compare survival across aging signatures groups 
# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_lung$New_TTP), event = as.numeric(RNA_data_lung$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature, data = RNA_data_lung)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = RNA_data_lung,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Absent", "Present"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot




#comparison without second primary 

surv_data <- RNA_data_lung %>% filter(ProgType_Lab!="Secondary.Primary")
# Create a survival object
surv_obj <- Surv(time = as.numeric(surv_data$New_TTP), event = as.numeric(surv_data$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature, data = surv_data)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = surv_data,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Absent", "Present"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot



#####correlation between risk score and age 
#lung
pdf(file = "Figures/RNA/correlation_age_risk_score_lung.pdf", height = 8, width = 6)
ggplot(RNA_data_lung, aes(x=Age, y=risk_score))+
  geom_point(color="black", alpha=0.7)+
  geom_smooth(method = "lm")+
  stat_cor(method = "spearman")+
  theme_bw()+
  xlab("Age")+ylab("Aging Risk Score")+
  theme(axis.text.x = element_text(size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()


  
#tumor
pdf(file = "Figures/RNA/correlation_age_risk_score_tumor.pdf", height = 8, width = 6)
ggplot(RNA_data_tumor, aes(x=Age, y=risk_score))+
  geom_point(color="black", alpha=0.7)+
  geom_smooth(method = "lm")+
  stat_cor(method = "spearman")+
  theme_bw()+
  xlab("Age")+ylab("Aging Risk Score")+
  theme(axis.text.x = element_text(size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()



# plot number of patients with increasing score 
# Sample data frame (replace with your actual data)
data <- RNA_data_tumor
# Sort the data by the 'risk score' column
data <- data[order(data$risk_score), ]

# Calculate the cumulative sum of patients with increasing scores
data$Cumulative_Patients <- seq_len(nrow(data))

# Create a scatter plot
pdf(file = "Figures/RNA/cumulative_patients_with_increasign_aging_score_tumor.pdf", height = 8, width = 12)
ggplot(data, aes(x = Cumulative_Patients, y = risk_score, color=aging_signature)) +
  geom_point() +
  scale_color_manual(values = c("dodgerblue3", "goldenrod2"))+
  geom_segment(aes( y = median(data$risk_score), yend = median(data$risk_score), x=0, xend=max(data$Cumulative_Patients)), linetype = "dashed", color="grey") +
  geom_segment(aes(x = median(data$Cumulative_Patients), xend = median(data$Cumulative_Patients), y = min(data$risk_score), yend = max(data$risk_score)), linetype = "dashed", color="grey") +
  labs(x = "Number of Patients with Increasing Aging Signature", y = "Aging Signature Score", color="") +
  theme_bw()+
  theme(axis.text.x = element_text(size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()



#cibersort from tumor samples according to aging signature 
cibersort_res_tumor <- cibersort_res %>% filter(Sample_Type_Involved=="Lung.Tissue.In")

cibersort_res_tumor$risk_score <- RNA_data_tumor$risk_score

cibersort_res_tumor$aging_signature <- RNA_data_tumor$aging_signature

cibersort_res_tumor$aging_signature<- gsub(" ", "_",cibersort_res_tumor$aging_signature)

cibersort_res_tumor$aging_signature<- factor(cibersort_res_tumor$aging_signature)


#compare cells 
#creating a variable to loop over 
col_names_cibersort <- colnames(cibersort_res_tumor)
col_names_cibersort <- col_names_cibersort[1:22]

#loop over columns 
for (i in col_names_cibersort){
  p <- ggplot(cibersort_res_tumor, aes_string(x= cibersort_res_tumor$aging_signature, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=aging_signature))+
    scale_color_manual(values = c("dodgerblue3", "goldenrod2"))+
    stat_compare_means(comparisons = list(c("Aging_Signature_Absent", "Aging_Signature_Present")))+ 
    scale_x_discrete(labels=c("Absent", "Present"))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_text(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Cibersort/", paste0(i, paste0(".boxplot"), paste0(".Cibersort.by.aging_signature_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


###### ssGSEA for tumor according to aging signature 

ssGSEA_res_t_tumor <- ssGSEA_res_t %>% filter(Sample_Type_Involved=="Lung.Tissue.In")

ssGSEA_res_t_tumor$risk_score <- RNA_data_tumor$risk_score

ssGSEA_res_t_tumor$aging_signature <- RNA_data_tumor$aging_signature

ssGSEA_res_t_tumor$aging_signature<- gsub(" ", "_",ssGSEA_res_t_tumor$aging_signature)

ssGSEA_res_t_tumor$aging_signature<- factor(ssGSEA_res_t_tumor$aging_signature)


#compare cells 
#creating a variable to loop over 
col_names_ssgsea <- colnames(ssGSEA_res_t_tumor)
col_names_ssgsea <- col_names_ssgsea[1:52]

#loop over columns 
for (i in col_names_ssgsea){
  p <- ggplot(ssGSEA_res_t_tumor, aes_string(x= ssGSEA_res_t_tumor$aging_signature, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=aging_signature))+
    scale_color_manual(values = c("dodgerblue3", "goldenrod2"))+
    stat_compare_means(comparisons = list(c("Aging_Signature_Absent", "Aging_Signature_Present")))+ 
    scale_x_discrete(labels=c("Absent", "Present"))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_text(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("ssGSEA/", paste0(i, paste0(".boxplot"), paste0(".ssGSEA.by.aging_signature_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


####compare DGE according to aging signature####
#build dds object 

mycounts
RNA.data$Sample_Type_Involved
RNA.data$aging_signature <- length(1:nrow(RNA.data))
RNA.data$aging_signature[1:148] <- RNA_data_lung$aging_signature
RNA.data$aging_signature[149:294] <- RNA_data_tumor$aging_signature

#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(mycounts, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(mycounts))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)

#Convert Model Variable into Factor
RNA.data$aging_signature <- as.factor(RNA.data$aging_signature)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = RNA.data, design = ~ aging_signature)

#Normalization Step 
dds <- estimateSizeFactors(dds)

#Retrive normalized counts matrix 
normalized_counts <- counts(dds, normalized=TRUE)
#save it 
write.table(normalized_counts, file="Results/normalized_counts_aging_signature.txt", sep="\t", quote=F, col.names=NA)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#Drop Levels
dds$aging_signature   <- droplevels(dds$aging_signature)
vsd$aging_signature   <- droplevels(vsd$aging_signature)


###############################################################################
################Running Differential Analysis for tumor subset ##################

#run aging signature vs not in tumor samples only 
dds_tumor <- dds[,dds$Sample_Type_Involved=="Lung.Tissue.In"]
vsd_tumor <- vsd[,vsd$Sample_Type_Involved=="Lung.Tissue.In"]


#define variables 
dds_tumor$aging_signature
v= "aging_signature"

#Set Reference Level for Comparison (Control Group)
dds_tumor[[v]] <- factor(dds_tumor[[v]])
dds_tumor[[v]] <- relevel(dds_tumor[[v]], ref = "Aging_Signature_Absent")

vsd_tumor[[v]] <- factor(vsd_tumor[[v]])
vsd_tumor[[v]] <- relevel(vsd_tumor[[v]], ref = "Aging_Signature_Absent")


######################Plot PCoA
library(vegan)

#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_tumor)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_tumor), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ aging_signature,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="aging_signature",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ aging_signature, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.Tumor_", paste0(v, paste0(".txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.Tumor.samples_aging_signature_present_vs_absent.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= aging_signature)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("dodgerblue3", "goldenrod2")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= aging_signature), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= aging_signature)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Absent", "Present"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()


#first select tumor samples only from metadata and counts table 
mycounts_Tumor <- assay(dds_tumor)

#get genes table and add 1
x= as(mycounts_Tumor, "matrix")
x= x+1 

#get Lung only table 
RNA_data_analysis <- RNA_data_tumor 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_analysis, "aging_signature")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)


#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_aging_signature_present_vs_absent_tumor.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "goldenrod2"
cols[res$logFC < 0 & res$FDR < alpha ] <- "dodgerblue3"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_aging_signature_present_vs_absent_RNA_tumor", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()









#### repeat plots for lung 
data <- RNA_data_lung
# Sort the data by the 'risk score' column
data <- data[order(data$risk_score), ]

# Calculate the cumulative sum of patients with increasing scores
data$Cumulative_Patients <- seq_len(nrow(data))

# Create a scatter plot
pdf(file = "Figures/RNA/cumulative_patients_with_increasign_aging_score_lung.pdf", height = 8, width = 12)
ggplot(data, aes(x = Cumulative_Patients, y = risk_score, color=aging_signature)) +
  geom_point() +
  scale_color_manual(values = c("dodgerblue3", "goldenrod2"))+
  geom_segment(aes( y = median(data$risk_score), yend = median(data$risk_score), x=0, xend=max(data$Cumulative_Patients)), linetype = "dashed", color="grey") +
  geom_segment(aes(x = median(data$Cumulative_Patients), xend = median(data$Cumulative_Patients), y = min(data$risk_score), yend = max(data$risk_score)), linetype = "dashed", color="grey") +
  labs(x = "Number of Patients with Increasing Aging Signature", y = "Aging Signature Score", color="") +
  theme_bw()+
  theme(axis.text.x = element_text(size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()


#cibersort 
cibersort_res_lung <- cibersort_res %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")

cibersort_res_lung$risk_score <- RNA_data_lung$risk_score

cibersort_res_lung$aging_signature <- RNA_data_lung$aging_signature

cibersort_res_lung$aging_signature<- gsub(" ", "_",cibersort_res_lung$aging_signature)

cibersort_res_lung$aging_signature<- factor(cibersort_res_lung$aging_signature)


#compare cells 
#creating a variable to loop over 
col_names_cibersort <- colnames(cibersort_res_lung)
col_names_cibersort <- col_names_cibersort[1:22]

#loop over columns 
for (i in col_names_cibersort){
  p <- ggplot(cibersort_res_lung, aes_string(x= cibersort_res_lung$aging_signature, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=aging_signature))+
    scale_color_manual(values = c("dodgerblue3", "goldenrod2"))+
    stat_compare_means(comparisons = list(c("Aging_Signature_Absent", "Aging_Signature_Present")))+ 
    scale_x_discrete(labels=c("Absent", "Present"))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_text(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Cibersort/", paste0(i, paste0(".boxplot"), paste0(".Cibersort.by.aging_signature_lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


###### ssGSEA for lung according to aging signature 

ssGSEA_res_t_lung <- ssGSEA_res_t %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")

ssGSEA_res_t_lung$risk_score <- RNA_data_lung$risk_score

ssGSEA_res_t_lung$aging_signature <- RNA_data_lung$aging_signature

ssGSEA_res_t_lung$aging_signature<- gsub(" ", "_",ssGSEA_res_t_lung$aging_signature)

ssGSEA_res_t_lung$aging_signature<- factor(ssGSEA_res_t_lung$aging_signature)


#compare cells 
#creating a variable to loop over 
col_names_ssgsea <- colnames(ssGSEA_res_t_lung)
col_names_ssgsea <- col_names_ssgsea[1:52]

#loop over columns 
for (i in col_names_ssgsea){
  p <- ggplot(ssGSEA_res_t_lung, aes_string(x= ssGSEA_res_t_lung$aging_signature, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=aging_signature))+
    scale_color_manual(values = c("dodgerblue3", "goldenrod2"))+
    stat_compare_means(comparisons = list(c("Aging_Signature_Absent", "Aging_Signature_Present")))+ 
    scale_x_discrete(labels=c("Absent", "Present"))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_text(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("ssGSEA/", paste0(i, paste0(".boxplot"), paste0(".ssGSEA.by.aging_signature_lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


#####compare  DGE according to aging signature in lung###

dds_lung <- dds[,dds$Sample_Type_Involved=="Lung.Tissue.UnIn"]
vsd_lung <- vsd[,vsd$Sample_Type_Involved=="Lung.Tissue.UnIn"]

#define variables 
dds_lung$aging_signature
v= "aging_signature"

#Set Reference Level for Comparison (Control Group)
dds_lung[[v]] <- factor(dds_lung[[v]])
dds_lung[[v]] <- relevel(dds_lung[[v]], ref = "Aging_Signature_Absent")

vsd_lung[[v]] <- factor(vsd_lung[[v]])
vsd_lung[[v]] <- relevel(vsd_lung[[v]], ref = "Aging_Signature_Absent")


######################Plot PCoA
library(vegan)

#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_lung)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_lung), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ aging_signature,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="aging_signature",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ aging_signature, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.lung_", paste0(v, paste0(".txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.lung.samples_aging_signature_present_vs_absent.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= aging_signature)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("dodgerblue3", "goldenrod2")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= aging_signature), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= aging_signature)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Absent", "Present"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_lung <- assay(dds_lung)

#get genes table and add 1
x= as(mycounts_lung, "matrix")
x= x+1 

#get Lung only table 
RNA_data_analysis <- RNA_data_lung

# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_analysis, "aging_signature")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)


#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_aging_signature_present_vs_absent_lung.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "goldenrod2"
cols[res$logFC < 0 & res$FDR < alpha ] <- "dodgerblue3"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_aging_signature_present_vs_absent_RNA_lung", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()




####plot IPA results of aging signature comparisons in tumor and lung ####

IPA_res <- read.csv(file = "IPA/ipa_comparison_NYU_aging_signature_present_vs_absent_tumor_lung.csv")


#get max and min values 
max(IPA_res$Tumor, na.rm = TRUE)
min(IPA_res$Tumor, na.rm = TRUE)
max(IPA_res$Lung, na.rm = TRUE)
min(IPA_res$Lung, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-4.454, 0, 6.215), c("blue", "white", "orange"))
col_fun(seq(-4.454, 0, 6.215))

#convert data to matrix 
IPA_res_mat <- IPA_res

IPA_res_mat <- IPA_res_mat %>% arrange(desc(Lung))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/ipa_comparison_NYU_aging_signature_present_vs_absent_tumor_lung_COX_elastic.pdf", height = 30, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()

























######## Aging signature using peters et al genes and elastic net only (no Cox) #########
##### Tumor subset ####

#read counts 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)
#read peters genes list 
genes_list_2 <- read.csv(file = "genes_associated_with_age_peters_et_al.csv")
#filter metadata to include recurrence events without second primary 
meta <- RNA_data_tumor %>% filter(ProgType_Lab!="Secondary.Primary")

counts <- mycounts[genes_list_2$Gene,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

# Run elastic net model using 10k folds
## the inner CV regarding tuning parameters
folds.inner <- createFolds(meta$Progression, k = 10, list = FALSE)
RNA.training <- RA.tem
delta.training <- meta$Progression

tunings=NULL
for(alpha0 in (seq(0,20,1)/20)^2) {
  
  cvfit <- cv.glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family="binomial",
                     type.measure="auc", foldid=folds.inner, alpha=alpha0, keep=TRUE)
  tunings=rbind(tunings, cbind(rep(alpha0,length(cvfit$lambda)),cvfit$lambda,cvfit$cvm))
}  

colnames(tunings)=c("alpha", "lambda","cvm")
tunings=data.frame(tunings)
tunings=tunings[which.max(tunings$cvm),]

## the optimal model based on the training
fit <- glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family = "binomial",
              alpha=tunings$alpha,lambda =tunings$lambda)

#get coeficients 
lasso_selected_features <- coef(fit)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

#save results 
write.csv(selected_genes, file = "Results/RNA/genes_aging_risk_score_elastic_only_tumor.csv")

#calculate risk score: risk score is = Log[Coef * gene expression values (add 1 to normalization)]
gene_expression_subset <- mycounts[rownames(selected_genes),]
gene_expression_subset <- gene_expression_subset %>% select(starts_with("NYU"))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes
#transpose to calculate finall score for every patients
risk_scores_t <- t(risk_scores)
#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed) here using median as cutoff
RNA_data_tumor$risk_score_elastic <- final_risk_score
RNA_data_tumor$aging_signature_elastic <- ifelse(RNA_data_tumor$risk_score_elastic > median(RNA_data_tumor$risk_score_elastic), "Aging Signature Present", "Aging Signature Absent")

RNA_data_tumor$age_3_grps <- factor(RNA_data_tumor$age_3_grps, levels = c("young", "middle", "old"))

# Plot 
#compare risk score among age groups 
pdf(file = "Figures/RNA/risk_score_elastic_only_age_3_grps_tumor.pdf", height = 8, width = 6)
ggplot(data = RNA_data_tumor, aes(x=age_3_grps, y=risk_score_elastic, color=age_3_grps))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "yellow2", "blue3"))+
  scale_x_discrete( labels=c("Young", "Middle", "Old"))+
  stat_compare_means(comparisons = list(c("middle", "young"), 
                                        c("middle", "old"), 
                                        c("young", "old")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()

#compare risk score between old and young according to median age 
pdf(file = "Figures/RNA/risk_score_elastic_only_age_grp_tumor.pdf", height = 8, width = 6)
ggplot(data = RNA_data_tumor, aes(x=age_grp, y=risk_score_elastic, color=age_grp))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("blue3", "green4"))+
  scale_x_discrete( labels=c("Old", "Young"))+
  stat_compare_means(comparisons = list(c("old", "young")))+  
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()

#compare progression across aging signature groups 
table_counts <- table(RNA_data_tumor$aging_signature_elastic, RNA_data_tumor$Progression)

pdf(file = "Figures/RNA/progression_aging_signature_elastic_tumor.pdf", height = 8, width = 6)
ggplot(RNA_data_tumor, aes(x = aging_signature_elastic, fill = Progression)) +
  geom_bar(position = "dodge")+
  scale_fill_manual(values = c("orange", "red"), labels=c("0"= "No Recurrence", "1"="Recurrence"))+
  theme_bw()+
  xlab("Aging Signature")+ylab("")+labs(fill="")+
  scale_x_discrete(labels=c("Absent", "Present"))+
  ggtitle("p_value of 0.287862")+
  theme(axis.text.x = element_text(size = 14, face = "bold", angle = 45, vjust = 0.5), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()

# Create a contingency table for the chi-squared test
contingency_table <- table(RNA_data_tumor$aging_signature_elastic, RNA_data_tumor$Progression)

# Perform the chi-squared test
chi_squared_result <- chisq.test(contingency_table)

# Print the p-value from the chi-squared test
p_value <- chi_squared_result$p.value
cat("Chi-squared p-value:", p_value, "\n")

###### compare survival across aging signatures groups 
# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_elastic, data = RNA_data_tumor)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = RNA_data_tumor,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Absent", "Present"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot


## repeat KM witout secondary primary 

surv_data <- RNA_data_tumor %>% filter(ProgType_Lab!="Secondary.Primary")
# Create a survival object
surv_obj <- Surv(time = as.numeric(surv_data$New_TTP), event = as.numeric(surv_data$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_elastic, data = surv_data)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = surv_data,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Absent", "Present"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot







##### Lung subset ####
#read counts
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)
#read genes list from peters et al
genes_list_2 <- read.csv(file = "genes_associated_with_age_peters_et_al.csv")
#filter metadata to include recurrence events without second primary 
meta <- RNA_data_lung %>% filter(ProgType_Lab!="Secondary.Primary")

counts <- mycounts[genes_list_2$Gene,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

# Run elastic net model using 10k folds
## the inner CV regarding tuning parameters
folds.inner <- createFolds(meta$Progression, k = 10, list = FALSE)
RNA.training <- RA.tem
delta.training <- meta$Progression

tunings=NULL
for(alpha0 in (seq(0,20,1)/20)^2) {
  
  cvfit <- cv.glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family="binomial",
                     type.measure="auc", foldid=folds.inner, alpha=alpha0, keep=TRUE)
  tunings=rbind(tunings, cbind(rep(alpha0,length(cvfit$lambda)),cvfit$lambda,cvfit$cvm))
}  

colnames(tunings)=c("alpha", "lambda","cvm")
tunings=data.frame(tunings)
tunings=tunings[which.max(tunings$cvm),]

## the optimal model based on the training
fit <- glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family = "binomial",
              alpha=tunings$alpha,lambda =tunings$lambda)

#get coefficients 
lasso_selected_features <- coef(fit)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

#save results 
write.csv(selected_genes, file = "Results/RNA/genes_aging_risk_score_elastic_only_lung.csv")
#construct risk score as done in tumor 
gene_expression_subset <- mycounts[rownames(selected_genes),]
gene_expression_subset <- gene_expression_subset %>% select(-starts_with("NYU"))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes
risk_scores_t <- t(risk_scores)

#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed)
RNA_data_lung$risk_score_elastic <- final_risk_score
RNA_data_lung$aging_signature_elastic <- ifelse(RNA_data_lung$risk_score_elastic > median(RNA_data_lung$risk_score_elastic), "Aging Signature Present", "Aging Signature Absent")
RNA_data_lung$age_3_grps <- factor(RNA_data_lung$age_3_grps, levels = c("young", "middle", "old"))

# Plot 
#compare risk score among age groups 
pdf(file = "Figures/RNA/risk_score_elastic_age_3_grps_lung.pdf", height = 8, width = 6)
ggplot(data = RNA_data_lung, aes(x=age_3_grps, y=risk_score_elastic, color=age_3_grps))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "yellow2", "blue3"))+
  scale_x_discrete( labels=c("Young", "Middle", "Old"))+
  stat_compare_means(comparisons = list(c("middle", "young"), 
                                        c("middle", "old"), 
                                        c("young", "old")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()

#compare risk score between old and young according to median age 
pdf(file = "Figures/RNA/risk_score_elastic_age_grp_lung.pdf", height = 8, width = 6)
ggplot(data = RNA_data_lung, aes(x=age_grp, y=risk_score_elastic, color=age_grp))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("blue3", "green4"))+
  scale_x_discrete( labels=c("Old", "Young"))+
  stat_compare_means(comparisons = list(c("old", "young")))+  
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()

#compare progression across aging signature groups 
table_counts <- table(RNA_data_lung$aging_signature_elastic, RNA_data_lung$Progression)

pdf(file = "Figures/RNA/progression_aging_signature_elastic_lung.pdf", height = 8, width = 6)
ggplot(RNA_data_lung, aes(x = aging_signature_elastic, fill = Progression)) +
  geom_bar(position = "dodge")+
  scale_fill_manual(values = c("orange", "red"), labels=c("0"= "No Recurrence", "1"="Recurrence"))+
  theme_bw()+
  xlab("Aging Signature")+ylab("")+labs(fill="")+
  scale_x_discrete(labels=c("Absent", "Present"))+
  ggtitle("p_value of < 0.001")+
  theme(axis.text.x = element_text(size = 14, face = "bold", angle = 45, vjust = 0.5), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()

# Create a contingency table for the chi-squared test
contingency_table <- table(RNA_data_lung$aging_signature_elastic, RNA_data_lung$Progression)

# Perform the chi-squared test
chi_squared_result <- chisq.test(contingency_table)

# Print the p-value from the chi-squared test
p_value <- chi_squared_result$p.value
cat("Chi-squared p-value:", p_value, "\n")

###### compare survival across aging signatures groups 
# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_lung$New_TTP), event = as.numeric(RNA_data_lung$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_elastic, data = RNA_data_lung)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = RNA_data_lung,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Absent", "Present"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot


#repeat survival plot without second primary 
## repeat KM witout secondary primary 

surv_data <- RNA_data_lung %>% filter(ProgType_Lab!="Secondary.Primary")
# Create a survival object
surv_obj <- Surv(time = as.numeric(surv_data$New_TTP), event = as.numeric(surv_data$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_elastic, data = surv_data)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = surv_data,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Absent", "Present"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot



#####correlation between risk score and age 
#lung
pdf(file = "Figures/RNA/correlation_age_risk_score_elastic_lung.pdf", height = 8, width = 6)
ggplot(RNA_data_lung, aes(x=Age, y=risk_score_elastic))+
  geom_point(color="black", alpha=0.7)+
  geom_smooth(method = "lm")+
  stat_cor(method = "spearman")+
  theme_bw()+
  xlab("Age")+ylab("Aging Risk Score")+
  theme(axis.text.x = element_text(size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()



#tumor
pdf(file = "Figures/RNA/correlation_age_risk_score_elastic_tumor.pdf", height = 8, width = 6)
ggplot(RNA_data_tumor, aes(x=Age, y=risk_score_elastic))+
  geom_point(color="black", alpha=0.7)+
  geom_smooth(method = "lm")+
  stat_cor(method = "spearman")+
  theme_bw()+
  xlab("Age")+ylab("Aging Risk Score")+
  theme(axis.text.x = element_text(size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()



# plot number of patients with increasing score 
# Sample data frame (replace with your actual data)
data <- RNA_data_tumor
# Sort the data by the 'risk score' column
data <- data[order(data$risk_score_elastic), ]

# Calculate the cumulative sum of patients with increasing scores
data$Cumulative_Patients <- seq_len(nrow(data))

# Create a scatter plot
pdf(file = "Figures/RNA/cumulative_patients_with_increasign_aging_score_elastic_tumor.pdf", height = 8, width = 12)
ggplot(data, aes(x = Cumulative_Patients, y = risk_score_elastic, color=aging_signature_elastic)) +
  geom_point() +
  scale_color_manual(values = c("dodgerblue3", "goldenrod2"))+
  geom_segment(aes( y = median(data$risk_score_elastic), yend = median(data$risk_score_elastic), x=0, xend=max(data$Cumulative_Patients)), linetype = "dashed", color="grey") +
  geom_segment(aes(x = median(data$Cumulative_Patients), xend = median(data$Cumulative_Patients), y = min(data$risk_score_elastic), yend = max(data$risk_score_elastic)), linetype = "dashed", color="grey") +
  labs(x = "Number of Patients with Increasing Aging Signature", y = "Aging Signature Score", color="") +
  theme_bw()+
  theme(axis.text.x = element_text(size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()



#cibersort from tumor samples according to aging signature 
cibersort_res_tumor <- cibersort_res %>% filter(Sample_Type_Involved=="Lung.Tissue.In")

cibersort_res_tumor$risk_score_elastic <- RNA_data_tumor$risk_score_elastic

cibersort_res_tumor$aging_signature_elastic <- RNA_data_tumor$aging_signature_elastic

cibersort_res_tumor$aging_signature_elastic<- gsub(" ", "_",cibersort_res_tumor$aging_signature_elastic)

cibersort_res_tumor$aging_signature_elastic<- factor(cibersort_res_tumor$aging_signature_elastic)


#compare cells 
#creating a variable to loop over 
col_names_cibersort <- colnames(cibersort_res_tumor)
col_names_cibersort <- col_names_cibersort[1:22]

#loop over columns 
for (i in col_names_cibersort){
  p <- ggplot(cibersort_res_tumor, aes_string(x= cibersort_res_tumor$aging_signature_elastic, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=aging_signature_elastic))+
    scale_color_manual(values = c("dodgerblue3", "goldenrod2"))+
    stat_compare_means(comparisons = list(c("Aging_Signature_Absent", "Aging_Signature_Present")))+ 
    scale_x_discrete(labels=c("Absent", "Present"))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_text(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Cibersort/", paste0(i, paste0(".boxplot"), paste0(".Cibersort.by.aging_signature_elastic_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


###### ssGSEA for tumor according to aging signature 

ssGSEA_res_t_tumor <- ssGSEA_res_t %>% filter(Sample_Type_Involved=="Lung.Tissue.In")

ssGSEA_res_t_tumor$risk_score_elastic <- RNA_data_tumor$risk_score_elastic

ssGSEA_res_t_tumor$aging_signature_elastic <- RNA_data_tumor$aging_signature_elastic

ssGSEA_res_t_tumor$aging_signature_elastic<- gsub(" ", "_",ssGSEA_res_t_tumor$aging_signature_elastic)

ssGSEA_res_t_tumor$aging_signature_elastic<- factor(ssGSEA_res_t_tumor$aging_signature_elastic)


#compare cells 
#creating a variable to loop over 
col_names_ssgsea <- colnames(ssGSEA_res_t_tumor)
col_names_ssgsea <- col_names_ssgsea[1:52]

#loop over columns 
for (i in col_names_ssgsea){
  p <- ggplot(ssGSEA_res_t_tumor, aes_string(x= ssGSEA_res_t_tumor$aging_signature_elastic, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=aging_signature_elastic))+
    scale_color_manual(values = c("dodgerblue3", "goldenrod2"))+
    stat_compare_means(comparisons = list(c("Aging_Signature_Absent", "Aging_Signature_Present")))+ 
    scale_x_discrete(labels=c("Absent", "Present"))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_text(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("ssGSEA/", paste0(i, paste0(".boxplot"), paste0(".ssGSEA.by.aging_signature_elastic_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


####compare DGE according to aging signature####
#build dds object 


RNA.data$Sample_Type_Involved
RNA.data$aging_signature_elastic <- length(1:nrow(RNA.data))
RNA.data$aging_signature_elastic[1:148] <- RNA_data_lung$aging_signature_elastic
RNA.data$aging_signature_elastic[149:294] <- RNA_data_tumor$aging_signature_elastic
RNA.data$aging_signature_elastic <- gsub(" ", "_", RNA.data$aging_signature_elastic)


#add new aging signature 
dds$aging_signature_elastic <- RNA.data$aging_signature_elastic
vsd$aging_signature_elastic <- RNA.data$aging_signature_elastic


###############################################################################
################Running Differential Analysis for tumor subset ##################

#run aging signature vs not in tumor samples only 
dds_tumor <- dds[,dds$Sample_Type_Involved=="Lung.Tissue.In"]
vsd_tumor <- vsd[,vsd$Sample_Type_Involved=="Lung.Tissue.In"]


#define variables 
dds_tumor$aging_signature_elastic
v= "aging_signature_elastic"

#Set Reference Level for Comparison (Control Group)
dds_tumor[[v]] <- factor(dds_tumor[[v]])
dds_tumor[[v]] <- relevel(dds_tumor[[v]], ref = "Aging_Signature_Absent")

vsd_tumor[[v]] <- factor(vsd_tumor[[v]])
vsd_tumor[[v]] <- relevel(vsd_tumor[[v]], ref = "Aging_Signature_Absent")


######################Plot PCoA
library(vegan)

#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_tumor)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_tumor), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ aging_signature_elastic,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="aging_signature_elastic",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ aging_signature_elastic, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.Tumor_", paste0(v, paste0("_elastic.txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.Tumor.samples_aging_signature_elastic_present_vs_absent.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= aging_signature_elastic)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("dodgerblue3", "goldenrod2")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= aging_signature_elastic), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= aging_signature_elastic)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Absent", "Present"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()


#first select tumor samples only from metadata and counts table 
mycounts_Tumor <- assay(dds_tumor)

#get genes table and add 1
x= as(mycounts_Tumor, "matrix")
x= x+1 

#get Lung only table 
RNA_data_analysis <- RNA_data_tumor 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_analysis, "aging_signature_elastic")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)


#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_aging_signature_elastic_present_vs_absent_tumor.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "goldenrod2"
cols[res$logFC < 0 & res$FDR < alpha ] <- "dodgerblue3"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_aging_signature_elastic_present_vs_absent_RNA_tumor", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()









#### repeat plots for lung 
data <- RNA_data_lung
# Sort the data by the 'risk score' column
data <- data[order(data$risk_score_elastic), ]

# Calculate the cumulative sum of patients with increasing scores
data$Cumulative_Patients <- seq_len(nrow(data))

# Create a scatter plot
pdf(file = "Figures/RNA/cumulative_patients_with_increasign_aging_score_elastic_lung.pdf", height = 8, width = 12)
ggplot(data, aes(x = Cumulative_Patients, y = risk_score_elastic, color=aging_signature_elastic)) +
  geom_point() +
  scale_color_manual(values = c("dodgerblue3", "goldenrod2"))+
  geom_segment(aes( y = median(data$risk_score_elastic), yend = median(data$risk_score_elastic), x=0, xend=max(data$Cumulative_Patients)), linetype = "dashed", color="grey") +
  geom_segment(aes(x = median(data$Cumulative_Patients), xend = median(data$Cumulative_Patients), y = min(data$risk_score_elastic), yend = max(data$risk_score_elastic)), linetype = "dashed", color="grey") +
  labs(x = "Number of Patients with Increasing Aging Signature", y = "Aging Signature Score", color="") +
  theme_bw()+
  theme(axis.text.x = element_text(size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()


#cibersort 
cibersort_res_lung <- cibersort_res %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")

cibersort_res_lung$risk_score_elastic <- RNA_data_lung$risk_score_elastic

cibersort_res_lung$aging_signature_elastic <- RNA_data_lung$aging_signature_elastic

cibersort_res_lung$aging_signature_elastic<- gsub(" ", "_",cibersort_res_lung$aging_signature_elastic)

cibersort_res_lung$aging_signature_elastic<- factor(cibersort_res_lung$aging_signature_elastic)


#compare cells 
#creating a variable to loop over 
col_names_cibersort <- colnames(cibersort_res_lung)
col_names_cibersort <- col_names_cibersort[1:22]

#loop over columns 
for (i in col_names_cibersort){
  p <- ggplot(cibersort_res_lung, aes_string(x= cibersort_res_lung$aging_signature_elastic, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=aging_signature_elastic))+
    scale_color_manual(values = c("dodgerblue3", "goldenrod2"))+
    stat_compare_means(comparisons = list(c("Aging_Signature_Absent", "Aging_Signature_Present")))+ 
    scale_x_discrete(labels=c("Absent", "Present"))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_text(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Cibersort/", paste0(i, paste0(".boxplot"), paste0(".Cibersort.by.aging_signature_elastic_lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}



ggplot(cibersort_res_lung, aes(x= cibersort_res_lung$aging_signature_elastic, y=Dendritic.cells.resting))+
  geom_boxplot()+
  geom_jitter(aes(alpha=0.7, color=aging_signature_elastic))+
  scale_color_manual(values = c("dodgerblue3", "goldenrod2"))+
  stat_compare_means(comparisons = list(c("Aging_Signature_Absent", "Aging_Signature_Present")))+ 
  scale_x_discrete(labels=c("Absent", "Present"))+
  xlab("")+
  ylab("")+
  ggtitle(i)+
  scale_y_log10()



###### ssGSEA for lung according to aging signature 

ssGSEA_res_t_lung <- ssGSEA_res_t %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")

ssGSEA_res_t_lung$risk_score_elastic <- RNA_data_lung$risk_score_elastic

ssGSEA_res_t_lung$aging_signature_elastic <- RNA_data_lung$aging_signature_elastic

ssGSEA_res_t_lung$aging_signature_elastic<- gsub(" ", "_",ssGSEA_res_t_lung$aging_signature_elastic)

ssGSEA_res_t_lung$aging_signature_elastic<- factor(ssGSEA_res_t_lung$aging_signature_elastic)


#compare cells 
#creating a variable to loop over 
col_names_ssgsea <- colnames(ssGSEA_res_t_lung)
col_names_ssgsea <- col_names_ssgsea[1:52]

#loop over columns 
for (i in col_names_ssgsea){
  p <- ggplot(ssGSEA_res_t_lung, aes_string(x= ssGSEA_res_t_lung$aging_signature_elastic, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=aging_signature_elastic))+
    scale_color_manual(values = c("dodgerblue3", "goldenrod2"))+
    stat_compare_means(comparisons = list(c("Aging_Signature_Absent", "Aging_Signature_Present")))+ 
    scale_x_discrete(labels=c("Absent", "Present"))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_text(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("ssGSEA/", paste0(i, paste0(".boxplot"), paste0(".ssGSEA.by.aging_signature_elastic_lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


#####compare  DGE according to aging signature in lung###

dds_lung <- dds[,dds$Sample_Type_Involved=="Lung.Tissue.UnIn"]
vsd_lung <- vsd[,vsd$Sample_Type_Involved=="Lung.Tissue.UnIn"]

#define variables 
dds_lung$aging_signature_elastic
v= "aging_signature_elastic"

#Set Reference Level for Comparison (Control Group)
dds_lung[[v]] <- factor(dds_lung[[v]])
dds_lung[[v]] <- relevel(dds_lung[[v]], ref = "Aging_Signature_Absent")

vsd_lung[[v]] <- factor(vsd_lung[[v]])
vsd_lung[[v]] <- relevel(vsd_lung[[v]], ref = "Aging_Signature_Absent")


######################Plot PCoA
library(vegan)

#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_lung)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_lung), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ aging_signature_elastic,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="aging_signature_elastic",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ aging_signature_elastic, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.lung_", paste0(v, paste0("_elastic.txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.lung.samples_aging_signature_elastic_present_vs_absent.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= aging_signature_elastic)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("dodgerblue3", "goldenrod2")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= aging_signature_elastic), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= aging_signature_elastic)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Absent", "Present"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_lung <- assay(dds_lung)

#get genes table and add 1
x= as(mycounts_lung, "matrix")
x= x+1 

#get Lung only table 
RNA_data_analysis <- RNA_data_lung

# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_analysis, "aging_signature_elastic")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)


#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_aging_signature_elastic_present_vs_absent_lung.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "goldenrod2"
cols[res$logFC < 0 & res$FDR < alpha ] <- "dodgerblue3"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_aging_signature_elastic_present_vs_absent_RNA_lung", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()




####plot IPA results of aging signature comparisons in tumor and lung ####

IPA_res <- read.csv(file = "IPA/ipa_comparison_NYU_aging_signature_elastic_present_vs_absent_tumor_lung.csv")


#get max and min values 
max(IPA_res$Tumor, na.rm = TRUE)
min(IPA_res$Tumor, na.rm = TRUE)
max(IPA_res$Lung, na.rm = TRUE)
min(IPA_res$Lung, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-7.14, 0, 8.05), c("blue", "white", "orange"))
col_fun(seq(-7.14, 0, 8.05))

#convert data to matrix 
IPA_res_mat <- IPA_res

IPA_res_mat <- IPA_res_mat %>% arrange(desc(Lung))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/ipa_comparison_NYU_aging_signature_elastic_present_vs_absent_tumor_lung.pdf", height = 30, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()


























































###### repeat analysis while removing secondary primary as recurrence events ####

#repeat regular analysis 



#repeat risk score from genes upregualted in old 

#survival plot with and without second primary as recurrence 



#repeat risk score from genes upregualted in old with recurrence 


#survival plot with and without second primary as recurrence 




#survival plot according to median age 
# Load the necessary libraries
library(survival)
library(survminer)
surv_data <- RNA_data_tumor %>% filter(ProgType_Lab!="Secondary.Primary")

# Create a survival object
surv_obj <- Surv(time = as.numeric(surv_data$New_TTP), event = as.numeric(surv_data$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ age_grp, data = surv_data)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = surv_data,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("darkblue", "darkgreen"), size=1,
  legend.labs=c("Old", "Young"), legend.title="Age",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Age",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)

survival.plot


#survival plot according to 3 age groups 
library(survival)
library(survminer)
surv_data <- RNA_data_tumor %>% filter(ProgType_Lab!="Secondary.Primary")


# Create a survival object
surv_obj <- Surv(time = as.numeric(surv_data$New_TTP), event = as.numeric(surv_data$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ age_3_grps, data = surv_data)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = surv_data,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("green4", "yellow2", "blue3"), size=1,
  legend.labs=c("Young", "Middle", "Old"), legend.title="Age",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Age",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot

#find p values between groups 

#young vs middle 
subset_data <- subset(surv_data, age_3_grps %in% c("young", "middle"))
logrank_test <- survdiff(Surv(time = as.numeric(subset_data$New_TTP), event = as.numeric(subset_data$Progression)) 
                         ~ age_3_grps, 
                         data = subset_data)
#get p value 
logrank_test$pvalue #0.14

#middle vs old  
subset_data <- subset(surv_data, age_3_grps %in% c("old", "middle"))
logrank_test <- survdiff(Surv(time = as.numeric(subset_data$New_TTP), event = as.numeric(subset_data$Progression)) 
                         ~ age_3_grps, 
                         data = subset_data)
#get p value 
logrank_test$pvalue # 0.856

#young vs old 
subset_data <- subset(surv_data, age_3_grps %in% c("young", "old"))
logrank_test <- survdiff(Surv(time = as.numeric(subset_data$New_TTP), event = as.numeric(subset_data$Progression)) 
                         ~ age_3_grps, 
                         data = subset_data)
#get p value 
logrank_test$pvalue # 0.2















######## develop0 risk scroe from DGEs in old patients 
#tumor and lung together to get shared genes

#read counts 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)
#read upregulated genes genes list 
res <- read.csv(file = "Results/RNA/edgeR.results_age_3_grp_tumor.csv")
res1 <- read.csv(file = "Results/RNA/edgeR.results_age_3_grp_lung.csv")
#filter only sig ones and overalpping genes 
res <- res %>% filter(FDR<0.2)
res1 <- res1 %>% filter(FDR < 0.2)
#get overlapping genes 
common_genes <- intersect(res$Gene.symbol, res1$Gene.symbol)

#overall 220 genes 

###construct the score based on tumor samples expression levels 
#filter metadata to include recurrence events without second primary 
meta <- RNA_data_tumor %>% filter(ProgType_Lab!="Secondary.Primary")

counts <- mycounts[common_genes,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))


#get model from expression in tumor subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

# Run elastic net model using 10k folds
## the inner CV regarding tuning parameters
folds.inner <- createFolds(meta$Progression, k = 10, list = FALSE)
RNA.training <- RA.tem
delta.training <- meta$Progression

tunings=NULL
for(alpha0 in (seq(0,20,1)/20)^2) {
  
  cvfit <- cv.glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family="binomial",
                     type.measure="auc", foldid=folds.inner, alpha=alpha0, keep=TRUE)
  tunings=rbind(tunings, cbind(rep(alpha0,length(cvfit$lambda)),cvfit$lambda,cvfit$cvm))
}  

colnames(tunings)=c("alpha", "lambda","cvm")
tunings=data.frame(tunings)
tunings=tunings[which.max(tunings$cvm),]

## the optimal model based on the training
fit <- glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family = "binomial",
              alpha=tunings$alpha,lambda =tunings$lambda)

#get coeficients 
lasso_selected_features <- coef(fit)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

#save results 
write.csv(selected_genes, file = "Results/RNA/genes_aging_risk_score_from_shared_genes_DGE_in_old_vs_young_from_tumor_counts.csv")

#calculate risk score: risk score is = Log[Coef * gene expression values (add 1 to normalization)]
gene_expression_subset <- mycounts[rownames(selected_genes),]
gene_expression_subset <- gene_expression_subset %>% select(starts_with("NYU"))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes
#transpose to calculate finall score for every patients
risk_scores_t <- t(risk_scores)
#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed) here using median as cutoff
RNA_data_tumor$risk_score_shared_genes_tumor <- final_risk_score
RNA_data_tumor$aging_signature_shared_genes_tumor <- ifelse(RNA_data_tumor$risk_score_shared_genes_tumor > median(RNA_data_tumor$risk_score_shared_genes_tumor), "Aging Signature Present", "Aging Signature Absent")



# Plot 
#compare risk score among age groups 
pdf(file = "Figures/RNA/risk_score_shared_genes_age_3_grps_tumor.pdf", height = 8, width = 6)
ggplot(data = RNA_data_tumor, aes(x=age_3_grps, y=risk_score_shared_genes_tumor, color=age_3_grps))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "yellow2", "blue3"))+
  scale_x_discrete( labels=c("Young", "Middle", "Old"))+
  stat_compare_means(comparisons = list(c("middle", "young"), 
                                        c("middle", "old"), 
                                        c("young", "old")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()

#compare risk score between old and young according to median age 
pdf(file = "Figures/RNA/risk_score_shared_genes_age_grp_tumor.pdf", height = 8, width = 6)
ggplot(data = RNA_data_tumor, aes(x=age_grp, y=risk_score_shared_genes_tumor, color=age_grp))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("blue3", "green4"))+
  scale_x_discrete( labels=c("Old", "Young"))+
  stat_compare_means(comparisons = list(c("old", "young")))+  
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()

#compare progression across aging signature groups 
table_counts <- table(RNA_data_tumor$aging_signature_shared_genes_tumor, RNA_data_tumor$Progression)

pdf(file = "Figures/RNA/progression_aging_signature_shared_genes_tumor.pdf", height = 8, width = 6)
ggplot(RNA_data_tumor, aes(x = aging_signature_shared_genes_tumor, fill = Progression)) +
  geom_bar(position = "dodge")+
  scale_fill_manual(values = c("orange", "red"), labels=c("0"= "No Recurrence", "1"="Recurrence"))+
  theme_bw()+
  xlab("Aging Signature")+ylab("")+labs(fill="")+
  scale_x_discrete(labels=c("Absent", "Present"))+
  ggtitle("p_value of 0.076")+
  theme(axis.text.x = element_text(size = 14, face = "bold", angle = 45, vjust = 0.5), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()

# Create a contingency table for the chi-squared test
contingency_table <- table(RNA_data_tumor$aging_signature_shared_genes_tumor, RNA_data_tumor$Progression)

# Perform the chi-squared test
chi_squared_result <- chisq.test(contingency_table)

# Print the p-value from the chi-squared test
p_value <- chi_squared_result$p.value
cat("Chi-squared p-value:", p_value, "\n")

###### compare survival across aging signatures groups 
# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_shared_genes_tumor, data = RNA_data_tumor)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = RNA_data_tumor,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Absent", "Present"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot


## repeat KM witout secondary primary 

surv_data <- RNA_data_tumor %>% filter(ProgType_Lab!="Secondary.Primary")
# Create a survival object
surv_obj <- Surv(time = as.numeric(surv_data$New_TTP), event = as.numeric(surv_data$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_shared_genes_tumor, data = surv_data)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = surv_data,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Absent", "Present"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot





#####construct the score based on lung samples ###
###construct the score based on tumor samples expression levels 
#filter metadata to include recurrence events without second primary 
meta <- RNA_data_lung %>% filter(ProgType_Lab!="Secondary.Primary")

counts <- mycounts[common_genes,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))


#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

# Run elastic net model using 10k folds
## the inner CV regarding tuning parameters
folds.inner <- createFolds(meta$Progression, k = 10, list = FALSE)
RNA.training <- RA.tem
delta.training <- meta$Progression

tunings=NULL
for(alpha0 in (seq(0,20,1)/20)^2) {
  
  cvfit <- cv.glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family="binomial",
                     type.measure="auc", foldid=folds.inner, alpha=alpha0, keep=TRUE)
  tunings=rbind(tunings, cbind(rep(alpha0,length(cvfit$lambda)),cvfit$lambda,cvfit$cvm))
}  

colnames(tunings)=c("alpha", "lambda","cvm")
tunings=data.frame(tunings)
tunings=tunings[which.max(tunings$cvm),]

## the optimal model based on the training
fit <- glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family = "binomial",
              alpha=tunings$alpha,lambda =tunings$lambda)

#get coeficients 
lasso_selected_features <- coef(fit)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

#save results 
write.csv(selected_genes, file = "Results/RNA/genes_aging_risk_score_from_shared_genes_DGE_in_old_vs_young_from_lung_counts.csv")

#calculate risk score: risk score is = Log[Coef * gene expression values (add 1 to normalization)]
gene_expression_subset <- mycounts[rownames(selected_genes),]
gene_expression_subset <- gene_expression_subset %>% select(-starts_with("NYU"))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes
#transpose to calculate finall score for every patients
risk_scores_t <- t(risk_scores)
#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed) here using median as cutoff
RNA_data_lung$risk_score_shared_genes_lung <- final_risk_score
RNA_data_lung$aging_signature_shared_genes_lung <- ifelse(RNA_data_lung$risk_score_shared_genes_lung > median(RNA_data_lung$risk_score_shared_genes_lung), "Aging Signature Present", "Aging Signature Absent")



# Plot 
#compare risk score among age groups 
pdf(file = "Figures/RNA/risk_score_shared_genes_age_3_grps_lung.pdf", height = 8, width = 6)
ggplot(data = RNA_data_lung, aes(x=age_3_grps, y=risk_score_shared_genes_lung, color=age_3_grps))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "yellow2", "blue3"))+
  scale_x_discrete( labels=c("Young", "Middle", "Old"))+
  stat_compare_means(comparisons = list(c("middle", "young"), 
                                        c("middle", "old"), 
                                        c("young", "old")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()

#compare risk score between old and young according to median age 
pdf(file = "Figures/RNA/risk_score_shared_genes_age_grp_lung.pdf", height = 8, width = 6)
ggplot(data = RNA_data_lung, aes(x=age_grp, y=risk_score_shared_genes_lung, color=age_grp))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("blue3", "green4"))+
  scale_x_discrete( labels=c("Old", "Young"))+
  stat_compare_means(comparisons = list(c("old", "young")))+  
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()

#compare progression across aging signature groups 
table_counts <- table(RNA_data_lung$aging_signature_shared_genes_lung, RNA_data_lung$Progression)

pdf(file = "Figures/RNA/progression_aging_signature_shared_genes_lung.pdf", height = 8, width = 6)
ggplot(RNA_data_lung, aes(x = aging_signature_shared_genes_lung, fill = Progression)) +
  geom_bar(position = "dodge")+
  scale_fill_manual(values = c("orange", "red"), labels=c("0"= "No Recurrence", "1"="Recurrence"))+
  theme_bw()+
  xlab("Aging Signature")+ylab("")+labs(fill="")+
  scale_x_discrete(labels=c("Absent", "Present"))+
  ggtitle("p_value of 0.007")+
  theme(axis.text.x = element_text(size = 14, face = "bold", angle = 45, vjust = 0.5), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()

# Create a contingency table for the chi-squared test
contingency_table <- table(RNA_data_lung$aging_signature_shared_genes_lung, RNA_data_lung$Progression)

# Perform the chi-squared test
chi_squared_result <- chisq.test(contingency_table)

# Print the p-value from the chi-squared test
p_value <- chi_squared_result$p.value
cat("Chi-squared p-value:", p_value, "\n")

###### compare survival across aging signatures groups 
# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_lung$New_TTP), event = as.numeric(RNA_data_lung$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_shared_genes_lung, data = RNA_data_lung)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = RNA_data_lung,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Absent", "Present"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot


## repeat KM witout secondary primary 

surv_data <- RNA_data_lung %>% filter(ProgType_Lab!="Secondary.Primary")
# Create a survival object
surv_obj <- Surv(time = as.numeric(surv_data$New_TTP), event = as.numeric(surv_data$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_shared_genes_lung, data = surv_data)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = surv_data,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Absent", "Present"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot



#####continue analysis from here 

##### reoeat DGEs analysis while removing second primary according to median age ###

#build deseq object 

#get genes counts 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)

colnames(mycounts) <- gsub("X", "", colnames(mycounts))

#metadata 
RNA.data$age_grp <- ifelse(RNA.data$Age <= median(RNA.data$Age), "less_equal_70", "greater_70")

meta <- data.frame(RNA.data)


#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(mycounts, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(mycounts))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)

#Convert Model Variable into Factor
meta$age_grp <- factor(meta$age_grp)
meta$age_3_grps <- as.factor(meta$age_3_grps)
meta$Sample_Type_Involved <- as.factor(meta$Sample_Type_Involved)
meta$Progression_Lab_Inv <- as.factor(meta$Progression_Lab_Inv)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = meta, design = ~ age_grp + Progression_Lab_Inv)

#Normalization Step 
dds <- estimateSizeFactors(dds)

#Retrive normalized counts matrix 
normalized_counts <- counts(dds, normalized=TRUE)
#save it 
write.table(normalized_counts, file="Results/normalized_counts_age_grp.txt", sep="\t", quote=F, col.names=NA)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#Drop Levels
dds$age_grp   <- droplevels(dds$age_grp)
vsd$age_grp   <- droplevels(vsd$age_grp)



###############################################################################
################Running Differential Analysis##################

#run old vs young 
#remove second primary from analysis 


###Subset for Tumor

dds_tumor <- dds[,dds$Sample_Type_Involved=="Lung.Tissue.In"]
vsd_tumor <- vsd[,vsd$Sample_Type_Involved=="Lung.Tissue.In"]

#remove second primary 
dds_tumor <- dds_tumor[,dds_tumor$ProgType_Lab!="Secondary.Primary"]
vsd_tumor <- vsd_tumor[,vsd_tumor$ProgType_Lab!="Secondary.Primary"]


#### compare old vs young in tumor without second primary according to median age ####


#define variables 
dds_tumor$age_grp
v= "age_grp"

#Set Reference Level for Comparison (Control Group)
dds_tumor[[v]] <- factor(dds_tumor[[v]])
dds_tumor[[v]] <- relevel(dds_tumor[[v]], ref = "less_equal_70")

vsd_tumor[[v]] <- factor(vsd_tumor[[v]])
vsd_tumor[[v]] <- relevel(vsd_tumor[[v]], ref = "less_equal_70")


######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_tumor)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_tumor), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ age_grp,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="age_grp",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ age_grp, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.Tumor_old_vs_young", paste0(v, paste0("_no_second_prim.txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.Tumor.samples.age_grp_RNA_no_second_prim.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= age_grp)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("green4", "blue3")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= age_grp), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= age_grp)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_Tumor <- assay(dds_tumor)

#get genes table and add 1
x= as(mycounts_Tumor, "matrix")
x= x+1 

#get Lung only table 
RNA_data_analysis <- meta %>% filter(Sample_Type_Involved=="Lung.Tissue.In") %>% filter(ProgType_Lab!="Secondary.Primary")


# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_analysis, "age_grp")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_age_grp_tumor_no_second_primary.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "blue3"
cols[res$logFC < 0 & res$FDR < alpha ] <- "green4"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_Old_vs_Young_RNA_tumor_no_second_primary", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()

########## repeat for Lung subset : old vs young, removing second primary, age median ####
#run old vs young 
#remove second primary from analysis 


###Subset for lung

dds_lung <- dds[,dds$Sample_Type_Involved=="Lung.Tissue.UnIn"]
vsd_lung <- vsd[,vsd$Sample_Type_Involved=="Lung.Tissue.UnIn"]

#remove second primary 
dds_lung <- dds_lung[,dds_lung$ProgType_Lab!="Secondary.Primary"]
vsd_lung <- vsd_lung[,vsd_lung$ProgType_Lab!="Secondary.Primary"]


#### compare old vs young in lung without second primary according to median age ####


#define variables 
dds_lung$age_grp
v= "age_grp"

#Set Reference Level for Comparison (Control Group)
dds_lung[[v]] <- factor(dds_lung[[v]])
dds_lung[[v]] <- relevel(dds_lung[[v]], ref = "less_equal_70")

vsd_lung[[v]] <- factor(vsd_lung[[v]])
vsd_lung[[v]] <- relevel(vsd_lung[[v]], ref = "less_equal_70")


######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd_lung)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd_lung), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ age_grp,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="age_grp",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ age_grp, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.lung_old_vs_young", paste0(v, paste0("_no_second_prim.txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.lung.samples.age_grp_RNA_no_second_prim.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= age_grp)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("green4", "blue3")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= age_grp), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= age_grp)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_lung <- assay(dds_lung)

#get genes table and add 1
x= as(mycounts_lung, "matrix")
x= x+1 

#get Lung only table 
RNA_data_analysis <- meta %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn") %>% filter(ProgType_Lab!="Secondary.Primary")


# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_analysis, "age_grp")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_age_grp_lung_no_second_primary.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "blue3"
cols[res$logFC < 0 & res$FDR < alpha ] <- "green4"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_Old_vs_Young_RNA_lung_no_second_primary", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


#plot IPA heatmap 

IPA_res <- read.csv(file = "IPA/IPA_comparison_NYU_early_stage_tumor_lung_old_vs_young_no_second_primary.csv")


#get max and min values 
max(IPA_res$Tumor, na.rm = TRUE)
min(IPA_res$Tumor, na.rm = TRUE)
max(IPA_res$Lung, na.rm = TRUE)
min(IPA_res$Lung, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-5, 0, 5.735), c("blue", "white", "orange"))
col_fun(seq(-5, 0, 5.735))

IPA_res <- IPA_res %>% arrange(desc(Lung))

#convert data to matrix 
IPA_res_mat <- IPA_res


#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/IPA_comparison_NYU_early_stage_tumor_lung_old_vs_young_no_second_primary.pdf", height = 30, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()



##### analyzing recurrence vs no recurrence without second primary, using median age as cutoff ######


###Subset for Tumor

dds_tumor <- dds[,dds$Sample_Type_Involved=="Lung.Tissue.In"]
vsd_tumor <- vsd[,vsd$Sample_Type_Involved=="Lung.Tissue.In"]

#remove second primary 
dds_tumor <- dds_tumor[,dds_tumor$ProgType_Lab!="Secondary.Primary"]
vsd_tumor <- vsd_tumor[,vsd_tumor$ProgType_Lab!="Secondary.Primary"]

#subset old only 
dds_tumor_old <- dds_tumor[,dds_tumor$age_grp=="greater_70"]
vsd_tumor_old <- vsd_tumor[,vsd_tumor$age_grp=="greater_70"]


#### compare recurrence vs no recurrence in old in tumor without second primary according to median age ####

#change desgin 
dds.analysis <- dds_tumor_old
vsd.analysis <- vsd_tumor_old

design(dds.analysis) <- ~ Progression_Lab_Inv

#define variables 
dds.analysis$Progression_Lab_Inv
v= "Progression_Lab_Inv"

#Set Reference Level for Comparison (Control Group)
dds.analysis[[v]] <- factor(dds.analysis[[v]])
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "In.No.Recurrence")

vsd.analysis[[v]] <- factor(vsd.analysis[[v]])
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "In.No.Recurrence")


######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ Progression_Lab_Inv,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="Progression_Lab_Inv",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ Progression_Lab_Inv, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.Tumor_old_rec_vs_norec", paste0(v, paste0("_no_second_prim.txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.Tumor.samples.old_rec_vs_no_rec_RNA_no_second_prim.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= Progression_Lab_Inv)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("orange", "red")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= Progression_Lab_Inv), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= Progression_Lab_Inv)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_Tumor <- assay(dds.analysis)

ncol(mycounts_Tumor)
#get genes table and add 1
x= as(mycounts_Tumor, "matrix")
x= x+1 

#get Lung only table 
RNA_data_analysis <- meta %>% filter(Sample_Type_Involved=="Lung.Tissue.In") %>% filter(ProgType_Lab!="Secondary.Primary") %>% filter(age_grp=="greater_70")


# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_analysis, "Progression_Lab_Inv")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_tumor_no_second_primary.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "red"
cols[res$logFC < 0 & res$FDR < alpha ] <- "orange"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_Old_rec_vs_no_rec_RNA_tumor_no_second_primary", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


#repeat for young: rec vs no recu in tumor 

dds_tumor_young <- dds_tumor[,dds_tumor$age_grp=="less_equal_70"]
vsd_tumor_young <- vsd_tumor[,vsd_tumor$age_grp=="less_equal_70"]

dds.analysis <- dds_tumor_young
vsd.analysis <- vsd_tumor_young

design(dds.analysis) <- ~ Progression_Lab_Inv

#define variables 
dds.analysis$Progression_Lab_Inv
v= "Progression_Lab_Inv"

#Set Reference Level for Comparison (Control Group)
dds.analysis[[v]] <- factor(dds.analysis[[v]])
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "In.No.Recurrence")

vsd.analysis[[v]] <- factor(vsd.analysis[[v]])
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "In.No.Recurrence")


######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ Progression_Lab_Inv,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="Progression_Lab_Inv",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ Progression_Lab_Inv, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.Tumor_young_rec_vs_norec", paste0(v, paste0("_no_second_prim.txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.Tumor.samples.young_rec_vs_no_rec_RNA_no_second_prim.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= Progression_Lab_Inv)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("skyblue2", "blue2")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= Progression_Lab_Inv), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= Progression_Lab_Inv)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_Tumor <- assay(dds.analysis)

ncol(mycounts_Tumor)
#get genes table and add 1
x= as(mycounts_Tumor, "matrix")
x= x+1 

#get Lung only table 
RNA_data_analysis <- meta %>% filter(Sample_Type_Involved=="Lung.Tissue.In") %>% filter(ProgType_Lab!="Secondary.Primary") %>% filter(age_grp=="less_equal_70")


# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_analysis, "Progression_Lab_Inv")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_tumor_no_second_primary.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "blue2"
cols[res$logFC < 0 & res$FDR < alpha ] <- "skyblue2"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_young_rec_vs_no_rec_RNA_tumor_no_second_primary", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



##### analyzing recurrence vs no recurrence without second primary, using median age as cutoff ######


###Subset for Lung###

dds_lung <- dds[,dds$Sample_Type_Involved=="Lung.Tissue.UnIn"]
vsd_lung <- vsd[,vsd$Sample_Type_Involved=="Lung.Tissue.UnIn"]

#remove second primary 
dds_lung <- dds_lung[,dds_lung$ProgType_Lab!="Secondary.Primary"]
vsd_lung <- vsd_lung[,vsd_lung$ProgType_Lab!="Secondary.Primary"]

#subset old only 
dds_lung_old <- dds_lung[,dds_lung$age_grp=="greater_70"]
vsd_lung_old <- vsd_lung[,vsd_lung$age_grp=="greater_70"]


#### compare recurrence vs no recurrence in old in lung without second primary according to median age ####

#change desgin 
dds.analysis <- dds_lung_old
vsd.analysis <- vsd_lung_old

design(dds.analysis) <- ~ Progression_Lab_Inv

#define variables 
dds.analysis$Progression_Lab_Inv
v= "Progression_Lab_Inv"

#Set Reference Level for Comparison (Control Group)
dds.analysis[[v]] <- factor(dds.analysis[[v]])
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "UnIn.No.Recurrence")

vsd.analysis[[v]] <- factor(vsd.analysis[[v]])
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "UnIn.No.Recurrence")


######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ Progression_Lab_Inv,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="Progression_Lab_Inv",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ Progression_Lab_Inv, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.lung_old_rec_vs_norec", paste0(v, paste0("_no_second_prim.txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.lung.samples.old_rec_vs_no_rec_RNA_no_second_prim.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= Progression_Lab_Inv)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("orangered", "darkred")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= Progression_Lab_Inv), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= Progression_Lab_Inv)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_lung <- assay(dds.analysis)

ncol(mycounts_lung)
#get genes table and add 1
x= as(mycounts_lung, "matrix")
x= x+1 

#get Lung only table 
RNA_data_analysis <- meta %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn") %>% filter(ProgType_Lab!="Secondary.Primary") %>% filter(age_grp=="greater_70")


# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_analysis, "Progression_Lab_Inv")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_lung_no_second_primary.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "darkred"
cols[res$logFC < 0 & res$FDR < alpha ] <- "orangered"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_Old_rec_vs_no_rec_RNA_lung_no_second_primary", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


#repeat for young: rec vs no recu in lung 

dds_lung_young <- dds_lung[,dds_lung$age_grp=="less_equal_70"]
vsd_lung_young <- vsd_lung[,vsd_lung$age_grp=="less_equal_70"]

dds.analysis <- dds_lung_young
vsd.analysis <- vsd_lung_young

design(dds.analysis) <- ~ Progression_Lab_Inv

#define variables 
dds.analysis$Progression_Lab_Inv
v= "Progression_Lab_Inv"

#Set Reference Level for Comparison (Control Group)
dds.analysis[[v]] <- factor(dds.analysis[[v]])
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "UnIn.No.Recurrence")

vsd.analysis[[v]] <- factor(vsd.analysis[[v]])
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "UnIn.No.Recurrence")


######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "name"

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ Progression_Lab_Inv,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="Progression_Lab_Inv",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ Progression_Lab_Inv, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.lung_young_rec_vs_norec", paste0(v, paste0("_no_second_prim.txt")))
            , sep = "\t", row.names = T)


pdf(file = "Figures/RNA/Beta.Diversity.Bray.lung.samples.young_rec_vs_no_rec_RNA_no_second_prim.pdf", 
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= Progression_Lab_Inv)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c("skyblue", "darkblue")) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= Progression_Lab_Inv), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= Progression_Lab_Inv)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################

#first select Lung samples only from metadata and counts table 
mycounts_lung <- assay(dds.analysis)

ncol(mycounts_lung)
#get genes table and add 1
x= as(mycounts_lung, "matrix")
x= x+1 

#get Lung only table 
RNA_data_analysis <- meta %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn") %>% filter(ProgType_Lab!="Secondary.Primary") %>% filter(age_grp=="less_equal_70")


# get your group variable (the condition you want to analyze according to it)
group = get_variable(RNA_data_analysis, "Progression_Lab_Inv")

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_lung_no_second_primary.csv")

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- "darkblue"
cols[res$logFC < 0 & res$FDR < alpha ] <- "skyblue"


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR_young_rec_vs_no_rec_RNA_lung_no_second_primary", paste0(alpha, paste0(".pdf"))), height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()






#plot IPA heatmap 

IPA_res <- read.csv(file = "IPA/IPA_comparison_NYU_early_tumor_lung_rec_vs_norec_age_no_second_prim.csv")


#get max and min values 
max(IPA_res$Old_Tumor, na.rm = TRUE)
min(IPA_res$Old_Tumor, na.rm = TRUE)
max(IPA_res$Young_Tumor, na.rm = TRUE)
min(IPA_res$Young_Tumor, na.rm = TRUE)
max(IPA_res$Old_Lung, na.rm = TRUE)
min(IPA_res$Old_Lung, na.rm = TRUE)
max(IPA_res$Young_Lung, na.rm = TRUE)
min(IPA_res$Young_Lung, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.887, 0, 5.578), c("blue", "white", "orange"))
col_fun(seq(-2.887, 0, 5.578))

#convert data to matrix 
IPA_res_mat <- IPA_res

IPA_res_mat <- IPA_res_mat %>% arrange(desc(Old_Lung))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/IPA_comparison_NYU_early_tumor_lung_rec_vs_norec_age_no_second_prim.pdf", height = 30, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()


#subset for tumor only 

IPA_res <- read.csv(file = "IPA/IPA_comparison_NYU_early_tumor_rec_vs_norec_age_no_second_prim.csv")

#get max and min values 
max(IPA_res$Old_Tumor, na.rm = TRUE)
min(IPA_res$Old_Tumor, na.rm = TRUE)
max(IPA_res$Young_Tumor, na.rm = TRUE)
min(IPA_res$Young_Tumor, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-1.633, 0, 4.914), c("blue", "white", "orange"))
col_fun(seq(-1.633, 0, 4.914))

#convert data to matrix 
IPA_res <- IPA_res %>% arrange(desc(Old_Tumor))

IPA_res_mat <- IPA_res


#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/IPA_comparison_NYU_early_tumor_rec_vs_norec_age_no_second_prim.pdf", height = 12, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()


#####lung subset 

IPA_res <- read.csv(file = "IPA/IPA_comparison_NYU_early_lung_rec_vs_norec_age_no_second_prim.csv")


#get max and min values 
max(IPA_res$Old_Lung, na.rm = TRUE)
min(IPA_res$Old_Lung, na.rm = TRUE)
max(IPA_res$Young_Lung, na.rm = TRUE)
min(IPA_res$Young_Lung, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-3.162, 0, 6.272), c("blue", "white", "orange"))
col_fun(seq(-3.162, 0, 6.272))

#convert data to matrix 
IPA_res_mat <- IPA_res

IPA_res_mat <- IPA_res_mat %>% arrange(desc(Old_Lung))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/IPA_comparison_NYU_early_lung_rec_vs_norec_age_no_second_prim.pdf", height = 30, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()





############# repeat the above analysis in TCGA using the same cutoff of age as used in NYU cohort. focus on stage I only #################

#age cutoff = 70
tcga_metadata_stage_I


#get clinical metadata of early stage (overall n=325 samples)

tcga_metadata_stage_I <- tcga_metadata %>% 
  dplyr::filter(ajcc_pathologic_stage %in% c("Stage_I", "Stage_IA", "Stage_IB"))


#get the cont table accordingly 
tcga_counts_stage_I <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_stage_I))

ncol(tcga_counts_stage_I) == nrow(tcga_metadata_stage_I)

############## Create summarized experiment object #########################

#Convert Model Variable into Factor
tcga_metadata_stage_I$age_grp_new <- ifelse(tcga_metadata_stage_I$age_at_index<=70, "less_equal_70", "greater_70")

tcga_metadata_stage_I$age_grp <- factor(tcga_metadata_stage_I$age_grp)
tcga_metadata_stage_I$DFS_STATUS <- factor(tcga_metadata_stage_I$DFS_STATUS)

#remove any missing data without age or recurrence information (overall 301 for analysis)
tcga_metadata_stage_I_no_NA <- tcga_metadata_stage_I %>% 
  dplyr::filter(age_grp_new != "NA") %>% 
  dplyr::filter(DFS_STATUS != "NA")


#now select the final counts table 
tcga_counts_stage_I_no_NA <- tcga_counts_filtered %>% 
  dplyr::select(rownames(tcga_metadata_stage_I_no_NA))


#Deseq 
#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(tcga_counts_stage_I_no_NA, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(tcga_counts_stage_I_no_NA))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = tcga_metadata_stage_I_no_NA, design = ~ age_grp_new + DFS_STATUS)

#Normalization Step 
dds <- estimateSizeFactors(dds)

#Retrive normalized counts matrix 
normalized_counts <- counts(dds, normalized=TRUE)
#save it 
write.table(normalized_counts, file="Results/RNA/normalized_counts_tcga_stage_I_median_age_new.txt", sep="\t", quote=F, col.names=NA)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#Drop Levels
dds$age_grp_new   <- droplevels(dds$age_grp_new)
vsd$age_grp_new   <- droplevels(vsd$age_grp_new)

dds$DFS_STATUS   <- droplevels(dds$DFS_STATUS)
vsd$DFS_STATUS   <- droplevels(vsd$DFS_STATUS)

#subset tumor and lung objects 
dds_tumor <- dds[,dds$sample_type=="Primary Tumor"]
dds_lung <- dds[, dds$sample_type=="Solid Tissue Normal"]

vsd_tumor <- vsd[,vsd$sample_type=="Primary Tumor"]
vsd_lung <- vsd[, vsd$sample_type=="Solid Tissue Normal"]



######### Table 1 of early lung cancer by median age #######


#get tabel 1 information 

Table.1.data <- tcga_metadata_stage_I_no_NA

#filter for number of subjects only (363 patients)
Table.1.data.subjects <- Table.1.data %>% 
  distinct(patient,.keep_all = TRUE)

#calculate median age = 66 
median(Table.1.data.subjects$age_at_index, na.rm = TRUE)

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever) +factor(dead_or_not_five_years)+factor(DFS_STATUS)
       # set the variable you want to stratify by 
       | age_grp_new, 
       #set data 
       data=Table.1.data.subjects, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))

#now add stats (same as above except where notes added )
table1(~ factor(synchronous_malignancy) + factor(ajcc_pathologic_stage) + as.numeric(age_at_index) + factor(race) + as.numeric(pack_years_smoked) 
       + factor(ajcc_pathologic_stage) +factor(gender) + factor(vital_status) + as.numeric(days_to_death) + factor(smoking_ever)+factor(dead_or_not_five_years)+factor(DFS_STATUS)
       | age_grp_new, 
       data=Table.1.data.subjects, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))



################ Kaplan Meier for Recurrence early stage, by median age ########


#use patients data 
Table.1.data.subjects

#We need data from our metadata that include time to recurrence, status of recurrence, mortality
metadata <- Table.1.data.subjects

#search for columns to keep 
#DFS status give recurrence or progression status 
metadata$DFS_STATUS
#DFS_MONTHS give time to recurrenc ein months, should convert this to days 
metadata$DFS_MONTHS
metadata$DFS_days <-  as.numeric(metadata$DFS_MONTHS) * 30.4167

###plot for recurrence 
#Column to be used as time (in days) - DFS_days 
# column to be used as status is DFS_STATUS
survival.data <- metadata[, c("DFS_days","DFS_STATUS", "age_grp_new" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

survival.data$status <- ifelse(survival.data$status=="Recurrence", 1, 0)

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- as.factor(survival.data$Age)

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Old", "Young"), legend.title="Age",  
                            palette=c("blue3", "green4"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to Age",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot (export as PNG)





#################### Tumor Subset Analysis  #run old vs young ##############

dds.analysis <- dds_tumor
vsd.analysis <- vsd_tumor

#define variables 
dds.analysis$age_grp_new
v= "age_grp_new"
tissue <- "tumor"
stage <- "stage_I_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "less_equal_70")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "less_equal_70")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_grp_new

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


####################### Repeat for Lung old vs young, early stage, by median age ####


dds.analysis <- dds_lung
vsd.analysis <- vsd_lung

#define variables 
dds.analysis$age_grp_new
v= "age_grp_new"
tissue <- "lung"
stage <- "stage_I_TCGA"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "less_equal_70")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "less_equal_70")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# old
col1 <- "blue3"

#young
col2 <- "green4"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$age_grp_new

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray.", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".txt")))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".pdf"))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("Young", "Old"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(".csv"))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0(alpha, paste0("_.pdf")))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()


###################plot IPA heatmap, old vs young 


IPA_res <- read.csv(file = "IPA/TCGA/IPA_comparison_TCGA_stage_I_age_70_tumor_lung_old_vs_young.csv")


#get max and min values 
max(IPA_res$TCGA_Tumor, na.rm = TRUE)
min(IPA_res$TCGA_Tumor, na.rm = TRUE)
max(IPA_res$TCGA_Lung, na.rm = TRUE)
min(IPA_res$TCGA_Lung, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-1.732, 0, 3.9), c("blue", "white", "orange"))
col_fun(seq(-1.732, 0, 3.9))

IPA_res <- IPA_res %>% arrange(desc(TCGA_Tumor))

#convert data to matrix 
IPA_res_mat <- IPA_res

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/IPA_comparison_TCGA_stage_I_age_70_tumor_lung_old_vs_young.pdf", height = 20, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()



################ Early stage Tumor tissue, comparing recurrence in age groups (according to median)#####

### subset for old and young tables 
dds_old <- dds[,dds$age_grp_new=="greater_70"]
dds_young <- dds[,dds$age_grp_new=="less_equal_70"]

vsd_old <- vsd[,vsd$age_grp_new=="greater_70"]
vsd_young <- vsd[,vsd$age_grp_new=="less_equal_70"]


####################################### Old subset#### 
#old tumor comparing recu to no rec 
dds.analysis <- dds_old[,dds_old$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Primary solid Tumor"]

#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "tumor"
stage <- "stage_I_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "red2"

#no rec
col2 <- "orange2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_cutoff_70.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_cutoff_70.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_cutoff_70.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_cutoff_70.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Primary solid Tumor"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Primary solid Tumor"]



#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "tumor"
stage <- "stage_I_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "blue2"

#no rec
col2 <- "skyblue2"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_cutoff_70.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_cutoff_70.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_cutoff_70.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_cutoff_70.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()



################ stage I Lung tissue, comparing recurrence in age groups (according to median)#####


####################################### Old subset#### 
#old tumor comparing recu to no rec 
dds.analysis <- dds_old[,dds_old$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_old[,vsd_old$definition=="Solid Tissue Normal"]

#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "Lung"
stage <- "stage_I_TCGA"
age_group <- "old"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "darkred"

#no rec
col2 <- "orangered"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =8)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_cutoff_70.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_cutoff_70.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_cutoff_70.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.2
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_cutoff_70.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()





####################################### Young subset#### 

#young tumor comparing recu to no rec 
dds.analysis <- dds_young[,dds_young$definition=="Solid Tissue Normal"]
vsd.analysis <- vsd_young[,vsd_young$definition=="Solid Tissue Normal"]



#change design 
design(dds.analysis) <- ~ DFS_STATUS

#define variables 
dds.analysis$DFS_STATUS
v= "DFS_STATUS"
tissue <- "Lung"
stage <- "stage_I_TCGA"
age_group <- "young"

#convert to factor 
dds.analysis[[v]] <- factor(dds.analysis[[v]])
vsd.analysis[[v]] <- factor(vsd.analysis[[v]])

#set reference levels 
dds.analysis[[v]] <- relevel(dds.analysis[[v]], ref = "No.Recurrence")
vsd.analysis[[v]] <- relevel(vsd.analysis[[v]], ref = "No.Recurrence")

#define metadata 
metadata_analysis <- data.frame(colData(dds.analysis))

#define colors 
# rec
col1 <- "darkblue"

#no rec
col2 <- "skyblue"
######################Plot PCoA


#Create Distance Matrix
vegdist = vegdist(t(assay(vsd.analysis)), method = "bray")

#Formulate principal component co-ordinates for PCOA plot, k as the choice of PCs
CmdScale <- cmdscale(vegdist, k =10)
#calculated Sample variance for each PC
vars <- apply(CmdScale, 2, var)
#Create Variable with the Percent Variance
percentVar <- round(100 * (vars/sum(vars)))

#Merge PC Data with MetaData
newResults <- merge(x = CmdScale, y = colData(vsd.analysis), by = "row.names", all.x = TRUE)
#Rename Variables for PC1 and PC2
colnames(newResults)[colnames(newResults)=="V1"] <- "PC1"
colnames(newResults)[colnames(newResults)=="V2"] <- "PC2"
colnames(newResults)[colnames(newResults)=="Row.names"] <- "names"

newResults$v <- newResults$DFS_STATUS

#Calculate the Centroid Value
centroids <- aggregate(cbind(PC1,PC2)~ v,data= newResults, mean)
#Merge the Centroid Data into the PCOA Data
newResults <- merge(newResults,centroids,by="v",suffixes=c("",".centroid"))


#stats 
x <- adonis2(vegdist ~ v, data = newResults)
write.table(x, file = paste0("Results/RNA/Beta.Diversity.Bray_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_cutoff_70.txt")))))))))
            , sep = "\t", row.names = T)

pdf(file = paste0("Figures/RNA/Beta.Diversity.Bray_PCoA_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_cutoff_70.pdf"))))))))),
    height = 20, width = 18)
ggplot(newResults, aes(PC1, PC2, color= v)) + # Graph PC1 and PC2
  geom_point(size=5) + # Set the size of the points
  xlab(paste0("PC1: ",percentVar[1],"% variance")) + #Label PC1
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + #Label PC2
  #Set colors for each category, should be the same number of categories
  scale_color_manual(values=c(col2, col1)) + 
  #plot point and lines from centroid
  geom_point(data=centroids, aes(x=PC1, y=PC2, color= v), size=0) +
  geom_segment(aes(x=PC1.centroid, y=PC2.centroid, xend=PC1, yend=PC2, color= v)) + 
  #labels centroids should be same number of categories
  geom_label_repel(data = centroids, aes(x=PC1, y=PC2, label=c("No Recurrence", "Recurrence"), size=10)) +
  labs(title = "Beta Diversity, Bray", subtitle = paste0("Adonis = ", paste0(x$`Pr(>F)`)))+
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "darkgrey"),panel.grid.minor = element_blank(),strip.background=element_blank(),axis.title=element_text(size=30,face="bold"),axis.text.x=element_text(colour = "darkgrey", size = rel(0.75)),axis.text.y=element_text(colour = "darkgrey", size = rel(0.75)),axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), legend.position="none")
dev.off()

##############Differential Analysis###################
mycounts.analysis <- assay(dds.analysis)

#get genes table and add 1
x= as(mycounts.analysis, "matrix")
x= x+1 

# get your group variable (the condition you want to analyze according to it)
group = get_variable(metadata_analysis, v)

#create edgeR list 
dgeFull <- DGEList(counts = x, 
                   group = group, 
                   remove.zeros = TRUE)

# calculatee normalization method
dgeFull <- calcNormFactors(dgeFull, method = "TMM")
# Estimate dispersions
dgeFull <- estimateCommonDisp(dgeFull)

dgeFull <- estimateTagwiseDisp(dgeFull)

dgeTest <- exactTest(dgeFull)

#create table
resNoFilt <- topTags(dgeTest, n=nrow(dgeTest$table), adjust.method = "BH", sort.by = "PValue")

############continue edgeR here#############

res <- resNoFilt$table
#Reverse Directionality if you need to  
#res$logFC <- res$logFC*(-1)

#clean the results df 

#Remove Any Data without LOGFC data
res <- res[!is.na(res$logFC),]

#Convert Important columns to Numeric
res$FDR <-   as.numeric(as.character(res$FDR))
res$logFC <-       as.numeric(as.character(res$logFC))

# drop any NA values 
res<- res %>% 
  drop_na(., FDR) %>% 
  dplyr::arrange(desc(FDR))

#create gene symbol column 
res<- res %>% 
  dplyr::mutate(Gene.symbol = rownames(.))

# save results (can be used in IPA also)
write.csv(res, file = paste0("Results/RNA/edgeR.results_",paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group, paste0("_age_cutoff_70.csv"))))))))))

###### volcano plot####
# create color variable 
res$sig <- -log10(res$FDR)

# Create variable for color gradient of the dots in the Volcano Plot
alpha = 0.25
cols <- densCols(res$logFC, res$sig)
cols[res$PValue ==0] <- "purple"
cols[res$logFC > 0 & res$FDR < alpha ] <- col1
cols[res$logFC < 0 & res$FDR < alpha ] <- col2


#plot with labels 
pdf(file = paste0("Figures/RNA/edgeR.results_", paste0(tissue, paste0("_", paste0(stage, paste0("_", paste0(v, paste0("_", paste0(age_group,  paste0("_", paste0(alpha, paste0("_age_cutoff_70.pdf"))))))))))), 
    height = 8 , width = 6)
ggplot(res, aes(x= logFC, y=sig, label= Gene.symbol))+ 
  geom_point(color = cols)+
  geom_text_repel(label=ifelse(res$logFC>0 & res$FDR < alpha , as.character(res$Gene.symbol),
                               ifelse(res$logFC<0 & res$FDR < alpha, as.character(res$Gene.symbol),'')),
                  size= 4, 
                  force = 25,
                  segment.colour="grey",
                  segment.alpha=0.5) + #Label values based on parameters, including pcal and logFC
  geom_hline(yintercept=-log10(alpha), color="red",linetype="dashed") + #Create Reference line for FDR
  xlab("Effect size: log2(fold-change)") + #label X Axis
  ylab("-log10(adjusted p-value)")+  #label Y Axis
  theme(panel.background = element_blank(),panel.border=element_rect(fill=NA),
        panel.grid.major = element_line(linetype = "dashed", size = 0.5, colour = "grey80"),
        panel.grid.minor = element_blank(),
        strip.background=element_blank(),
        axis.title=element_text(size=20,face="bold"),
        axis.text.x=element_text(colour = "grey80", size = rel(0.75)),
        axis.text.y=element_text(colour = "grey80", size = rel(0.75)),
        axis.ticks=element_blank(),plot.margin=unit(c(1,1,1,1),"line"), 
        legend.position="none")
dev.off()















######## plot IPA heatmap for TCGA stage I , rec vs no rec, age cutoff of 70 



#plot IPA heatmap 

IPA_res <- read.csv(file = "IPA/TCGA/IPA_comparison_stage_I_age_70_rec_vs_norec_tumor_lung.csv")


#get max and min values 
max(IPA_res$TCGA_Tumor_Old, na.rm = TRUE)
min(IPA_res$TCGA_Tumor_Old, na.rm = TRUE)
max(IPA_res$TCGA_Tumor_Young, na.rm = TRUE)
min(IPA_res$TCGA_Tumor_Young, na.rm = TRUE)
max(IPA_res$TCGA_Lung_Old, na.rm = TRUE)
min(IPA_res$TCGA_Lung_Old, na.rm = TRUE)
max(IPA_res$TCGA_Lung_Young, na.rm = TRUE)
min(IPA_res$TCGA_Lung_Young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.449, 0, 9.065), c("blue", "white", "orange"))
col_fun(seq(-2.449, 0, 9.065))

#convert data to matrix 
IPA_res_mat <- IPA_res

IPA_res_mat <- IPA_res_mat %>% arrange(desc(TCGA_Tumor_Old))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/IPA_comparison_TCGA_stage_I_age_70_rec_vs_norec_tumor_lung.pdf", height = 30, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()


#subset for tumor only 

IPA_res <- read.csv(file = "IPA/TCGA/IPA_comparison_TCGA_stage_I_age_70_rec_vs_norec_tumor_only.csv")

#get max and min values 
max(IPA_res$TCGA_Tumor_Old, na.rm = TRUE)
min(IPA_res$TCGA_Tumor_Old, na.rm = TRUE)
max(IPA_res$TCGA_Tumor_Young, na.rm = TRUE)
min(IPA_res$TCGA_Tumor_Young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.668, 0, 9.065), c("blue", "white", "orange"))
col_fun(seq(-2.668, 0, 9.065))

#convert data to matrix 
IPA_res_mat <- IPA_res

IPA_res_mat <- IPA_res_mat %>% arrange(desc(TCGA_Tumor_Old))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/IPA_comparison_TCGA_stage_I_age_70_rec_vs_norec_tumor_only.pdf", height = 26, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()


#####lung subset 

IPA_res <- read.csv(file = "IPA/TCGA/IPA_comparison_TCGA_stage_I_age_70_rec_vs_norec_lung_only.csv")


#get max and min values 
max(IPA_res$TCGA_Lung_Old, na.rm = TRUE)
min(IPA_res$TCGA_Lung_Old, na.rm = TRUE)
max(IPA_res$TCGA_Lung_Young, na.rm = TRUE)
min(IPA_res$TCGA_Lung_Young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)

# Create a custom color scale using only orange
col_fun <- colorRamp2(c(0, 2.887), c("white", "orange"))
col_fun(seq(0, 2.887))

#convert data to matrix 
IPA_res_mat <- IPA_res

IPA_res_mat <- IPA_res_mat %>% arrange(desc(TCGA_Lung_Old))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/IPA_comparison_TCGA_stage_I_age_70_rec_vs_norec_lung_only.pdf", height = 10, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()


################################################################################
#################### Cibersort NYU without second primary ###################
cibersort_res$ProgType_Lab <- RNA.data$ProgType_Lab

cibersort_res$age_grp <- RNA.data$age_grp

cibersort_res$Progression <- RNA.data$Progression

cibersort_res<- cibersort_res %>% 
  mutate(age_rec=case_when(
    age_grp=="greater_70" & Progression=="1" ~ "old_rec", 
    age_grp=="less_equal_70" & Progression=="1" ~ "young_rec", 
    age_grp=="greater_70" & Progression=="0" ~ "old_no_rec", 
    age_grp=="less_equal_70" & Progression=="0" ~ "young_no_rec"))

cibersort_res_no_seond_prim <- cibersort_res %>% filter(ProgType_Lab!="Secondary.Primary")

cibersort_res_no_seond_prim_tumor <- cibersort_res_no_seond_prim %>% filter(Sample_Type_Involved=="Lung.Tissue.In")

cibersort_res_no_seond_prim_lung <- cibersort_res_no_seond_prim %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")


###tumor subset 

#plot old vs young 

#prepare data in long format 
cibersort_res_no_seond_prim_tumor_long <- cibersort_res_no_seond_prim_tumor %>%
  select(-c(P.value, Correlation, RMSE, Sample_Type_Involved, Progression_Lab_Inv, age_3_grps, ProgType_Lab, Progression, age_rec)) %>%
  gather(key = "celltype", value = "value", -age_grp)
#correct value to remove zeros 
cibersort_res_no_seond_prim_tumor_long$value <- cibersort_res_no_seond_prim_tumor_long$value +0.001
#subset data for young and old 
young_data <- subset(cibersort_res_no_seond_prim_tumor_long, age_grp == "less_equal_70")
old_data <- subset(cibersort_res_no_seond_prim_tumor_long, age_grp == "greater_70")

# Create a list to store the results
results_list <- list()

# Loop through each cell type
cell_types <- unique(cibersort_res_no_seond_prim_tumor_long$celltype)
for (cell_type in cell_types) {
  data_subset <- filter(cibersort_res_no_seond_prim_tumor_long, celltype == cell_type)
  
  # Perform Wilcoxon rank-sum test to compare values between old and young groups
  wilcox_result <- wilcox.test(value ~ age_grp, data = data_subset)
  
  # Extract the p-value
  p_value <- wilcox_result$p.value
  
  # Store the results in a list
  results_list[[cell_type]] <- data.frame(CellType = cell_type, PValue = p_value)
}

# Combine the results into a single data frame
results_df <- do.call(rbind, results_list)
#turn to FDR 
results_df$FDR <- p.adjust(results_df$PValue, method = "fdr")
results_df <- results_df %>% dplyr::rename(celltype=CellType)

merged_data <- cibersort_res_no_seond_prim_tumor_long %>%
  left_join(results_df, by = "celltype")


# Create a plot
pdf(file = "Figures/RNA/NYU_cibersort_age_grp_no_second_prim.pdf", width = 14, height = 8)
ggplot(merged_data, aes(x = fct_reorder(celltype,-value, .fun = median), y = value, fill = age_grp)) +
  #geom_violin() +
  geom_boxplot(color = "black") +
  geom_text(aes(label = ifelse(PValue < 0.05, sprintf("P = %.3f", PValue), "ns")),
            y = rep(max(merged_data$value), nrow(merged_data)),
            size = 3)+
  labs(x = "", y = "", fill="Age") +
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("darkblue", "green4"), labels=c(">70", "â‰¤70"))  # Change the palette as needed
dev.off()
            

#### repeat for age and recurrence 

#prepare data in long format 
cibersort_res_no_seond_prim_tumor_long <- cibersort_res_no_seond_prim_tumor %>% 
  select(-c(P.value, Correlation, RMSE, Sample_Type_Involved, Progression_Lab_Inv, age_3_grps, ProgType_Lab, Progression,age_grp )) %>%
  gather(key = "celltype", value = "value", -age_rec)
#correct value to remove zeros 
cibersort_res_no_seond_prim_tumor_long$value <- cibersort_res_no_seond_prim_tumor_long$value +0.001
cibersort_res_no_seond_prim_tumor_long$age_rec <- factor(cibersort_res_no_seond_prim_tumor_long$age_rec, 
                                                         levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

# perform stat analysis
stat.test <- cibersort_res_no_seond_prim_tumor_long %>%
  group_by(celltype) %>%
  wilcox_test(value ~ age_rec)

#add xy position
stat.test <- stat.test %>%
  add_xy_position(x = "celltype", dodge = 1.5)

#filter to visualize only comparisons between recurrence and no recurrence 
stat.test <- stat.test %>% 
  filter(group1 %in% "young_rec" & group2 %in% "old_rec" | group1 %in% "young_no_rec" & group2 %in% "old_no_rec")

#plot 
pdf(file = "Figures/RNA/NYU_cibersort_age_rec_no_second_prim.pdf", width = 22, height = 12)
ggplot(cibersort_res_no_seond_prim_tumor_long, aes(x = celltype, y = value)) +
  geom_boxplot(color = "black", aes(fill=age_rec))+
  stat_pvalue_manual(
    stat.test %>% filter(p.adj< 0.2),
    label = "p.adj",
    tip.length = 0.01,
    y.position = 0.3
  ) +
  labs(x = "", y = "", fill="Age, Recurrence") +
  scale_y_continuous(limits = c(0,0.6))+
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("lightblue", "orange", "blue", "red"), 
                    labels=c("â‰¤70 No Recu", ">70 No Recu", "â‰¤70 Recu", ">70 Recu"))  # Change the palette as needed
dev.off()


######### repeat for lung 
#plot old vs young 

#prepare data in long format 
cibersort_res_no_seond_prim_lung_long <- cibersort_res_no_seond_prim_lung %>%
  select(-c(P.value, Correlation, RMSE, Sample_Type_Involved, Progression_Lab_Inv, age_3_grps, ProgType_Lab, Progression, age_rec)) %>%
  gather(key = "celltype", value = "value", -age_grp)
#correct value to remove zeros 
cibersort_res_no_seond_prim_lung_long$value <- cibersort_res_no_seond_prim_lung_long$value +0.001
#subset data for young and old 
young_data <- subset(cibersort_res_no_seond_prim_lung_long, age_grp == "less_equal_70")
old_data <- subset(cibersort_res_no_seond_prim_lung_long, age_grp == "greater_70")

# Create a list to store the results
results_list <- list()

# Loop through each cell type
cell_types <- unique(cibersort_res_no_seond_prim_lung_long$celltype)
for (cell_type in cell_types) {
  data_subset <- filter(cibersort_res_no_seond_prim_lung_long, celltype == cell_type)
  
  # Perform Wilcoxon rank-sum test to compare values between old and young groups
  wilcox_result <- wilcox.test(value ~ age_grp, data = data_subset)
  
  # Extract the p-value
  p_value <- wilcox_result$p.value
  
  # Store the results in a list
  results_list[[cell_type]] <- data.frame(CellType = cell_type, PValue = p_value)
}

# Combine the results into a single data frame
results_df <- do.call(rbind, results_list)
#turn to FDR 
results_df$FDR <- p.adjust(results_df$PValue, method = "fdr")
results_df <- results_df %>% dplyr::rename(celltype=CellType)

merged_data <- cibersort_res_no_seond_prim_lung_long %>%
  left_join(results_df, by = "celltype")


# Create a plot
pdf(file = "Figures/RNA/NYU_cibersort_lung_age_grp_no_second_prim.pdf", width = 14, height = 8)
ggplot(merged_data, aes(x = fct_reorder(celltype,-value, .fun = median), y = value, fill = age_grp)) +
  #geom_violin() +
  geom_boxplot(color = "black") +
  geom_text(aes(label = ifelse(PValue < 0.05, sprintf("P = %.3f", PValue), "ns")),
            y = rep(max(merged_data$value), nrow(merged_data)),
            size = 3)+
  labs(x = "", y = "", fill="Age") +
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("darkblue", "green4"), labels=c(">70", "â‰¤70"))  # Change the palette as needed
dev.off()


#### repeat for age and recurrence 

#prepare data in long format 
cibersort_res_no_seond_prim_lung_long <- cibersort_res_no_seond_prim_lung %>% 
  select(-c(P.value, Correlation, RMSE, Sample_Type_Involved, Progression_Lab_Inv, age_3_grps, ProgType_Lab, Progression,age_grp )) %>%
  gather(key = "celltype", value = "value", -age_rec)
#correct value to remove zeros 
cibersort_res_no_seond_prim_lung_long$value <- cibersort_res_no_seond_prim_lung_long$value +0.001
cibersort_res_no_seond_prim_lung_long$age_rec <- factor(cibersort_res_no_seond_prim_lung_long$age_rec, 
                                                         levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

# perform stat analysis
stat.test <- cibersort_res_no_seond_prim_lung_long %>%
  group_by(celltype) %>%
  wilcox_test(value ~ age_rec)

#add xy position
stat.test <- stat.test %>%
  add_xy_position(x = "celltype", dodge = 0.8)

#filter to visualize only comparisons between recurrence and no recurrence 
stat.test <- stat.test %>% 
  filter(group1 %in% "young_rec" & group2 %in% "old_rec" | group1 %in% "young_no_rec" & group2 %in% "old_no_rec")

#plot 
pdf(file = "Figures/RNA/NYU_cibersort_lung_age_rec_no_second_prim.pdf", width = 22, height = 12)
ggplot(cibersort_res_no_seond_prim_lung_long, aes(x = celltype, y = value)) +
  geom_boxplot(color = "black", aes(fill=age_rec))+
  stat_pvalue_manual(
    stat.test %>% filter(p.adj< 0.2),
    label = "p.adj",
    tip.length = 0.01,
    y.position = 0.3
  ) +
  labs(x = "", y = "", fill="Age, Recurrence") +
  scale_y_continuous(limits = c(0,0.6))+
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("skyblue", "orangered", "darkblue", "darkred"), 
                    labels=c("â‰¤70 No Recu", ">70 No Recu", "â‰¤70 Recu", ">70 Recu"))  # Change the palette as needed
dev.off()


###### plot according to age signature 










 #validate in TCGA all risk score options 

tcga_counts_stage_I



########### TCGA stage I cibersort ########

#get TCGA counts to perform cibersort 
write.csv(tcga_counts_stage_I, file = "TCGA_counts_stage_I.csv")
write.table(tcga_counts_stage_I, file = "TCGA_counts_stage_I.txt", sep = "\t")


#read cibersort res 
cibersort_res_TCGA <- read.csv(file = "CIBERSORTx_Job26_Results_TCGA_stage_I.csv")

rownames(cibersort_res_TCGA) <- cibersort_res_TCGA$Mixture

cibersort_res_TCGA <- cibersort_res_TCGA %>% select(-Mixture)

#add metadata to cibersort res 

cibersort_res_TCGA$age_grp_new <- tcga_metadata_stage_I$age_grp_new
cibersort_res_TCGA$age_3_grps <- tcga_metadata_stage_I$age_3_grps
cibersort_res_TCGA$dead_or_not_five_years <- tcga_metadata_stage_I$dead_or_not_five_years
cibersort_res_TCGA$DFS_STATUS <- tcga_metadata_stage_I$DFS_STATUS
cibersort_res_TCGA$shortLetterCode <- tcga_metadata_stage_I$shortLetterCode
cibersort_res_TCGA<- cibersort_res_TCGA %>% 
  mutate(age_rec=case_when(
    age_grp_new=="greater_70" & DFS_STATUS=="Recurrence" ~ "old_rec", 
    age_grp_new=="less_equal_70" & DFS_STATUS=="Recurrence" ~ "young_rec", 
    age_grp_new=="greater_70" & DFS_STATUS=="No.Recurrence" ~ "old_no_rec", 
    age_grp_new=="less_equal_70" & DFS_STATUS=="No.Recurrence" ~ "young_no_rec"))

#remove any NA
cibersort_res_TCGA <- na.omit(cibersort_res_TCGA)

cibersort_res_TCGA_tumor <- cibersort_res_TCGA %>% filter(shortLetterCode=="TP")

cibersort_res_TCGA_lung <- cibersort_res_TCGA %>% filter(shortLetterCode=="NT")


###tumor subset 

#plot old vs young 

#prepare data in long format 
cibersort_res_TCGA_tumor_long <- cibersort_res_TCGA_tumor %>%
  select(-c(P.value, Correlation, RMSE, dead_or_not_five_years, DFS_STATUS, age_3_grps, shortLetterCode, age_rec)) %>%
  gather(key = "celltype", value = "value", -age_grp_new)
#correct value to remove zeros 
cibersort_res_TCGA_tumor_long$value <- cibersort_res_TCGA_tumor_long$value +0.001

# Create a list to store the results
results_list <- list()

# Loop through each cell type
cell_types <- unique(cibersort_res_TCGA_tumor_long$celltype)
for (cell_type in cell_types) {
  data_subset <- filter(cibersort_res_TCGA_tumor_long, celltype == cell_type)
  
  # Perform Wilcoxon rank-sum test to compare values between old and young groups
  wilcox_result <- wilcox.test(value ~ age_grp_new, data = data_subset)
  
  # Extract the p-value
  p_value <- wilcox_result$p.value
  
  # Store the results in a list
  results_list[[cell_type]] <- data.frame(CellType = cell_type, PValue = p_value)
}

# Combine the results into a single data frame
results_df <- do.call(rbind, results_list)
#turn to FDR 
results_df$FDR <- p.adjust(results_df$PValue, method = "fdr")
results_df <- results_df %>% dplyr::rename(celltype=CellType)

merged_data <- cibersort_res_TCGA_tumor_long %>%
  left_join(results_df, by = "celltype")


# Create a plot
pdf(file = "Figures/RNA/TCGA_cibersort_age_grp_new.pdf", width = 14, height = 8)
ggplot(merged_data, aes(x = fct_reorder(celltype,-value, .fun = median), y = value, fill = age_grp_new)) +
  #geom_violin() +
  geom_boxplot(color = "black") +
  geom_text(aes(label = ifelse(PValue < 0.05, sprintf("P = %.3f", PValue), "ns")),
            y = rep(max(merged_data$value), nrow(merged_data)),
            size = 3)+
  labs(x = "", y = "", fill="Age") +
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("darkblue", "green4"), labels=c(">70", "â‰¤70"))  # Change the palette as needed
dev.off()



#### repeat for age and recurrence 

#prepare data in long format 
cibersort_res_TCGA_tumor_long <- cibersort_res_TCGA_tumor %>% 
  select(-c(P.value, Correlation, RMSE, shortLetterCode, age_grp_new, age_3_grps, dead_or_not_five_years,DFS_STATUS )) %>%
  gather(key = "celltype", value = "value", -age_rec)
#correct value to remove zeros 
cibersort_res_TCGA_tumor_long$value <- cibersort_res_TCGA_tumor_long$value +0.001
cibersort_res_TCGA_tumor_long$age_rec <- factor(cibersort_res_TCGA_tumor_long$age_rec, 
                                                         levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))
cibersort_res_TCGA_tumor_long$value <- as.numeric(cibersort_res_TCGA_tumor_long$value)
cibersort_res_TCGA_tumor_long <- na.omit(cibersort_res_TCGA_tumor_long)

# perform stat analysis
stat.test <- cibersort_res_TCGA_tumor_long %>%
  group_by(celltype) %>%
  mutate(celltype=factor(celltype)) %>% 
  wilcox_test(data=., value ~ age_rec)

#add xy position
stat.test <- stat.test %>%
  add_xy_position(x = "celltype", dodge = 1.5)

#filter to visualize only comparisons between recurrence and no recurrence 
stat.test <- stat.test %>% 
  filter(group1 %in% "young_rec" & group2 %in% "old_rec" | group1 %in% "young_no_rec" & group2 %in% "old_no_rec")


#plot 
pdf(file = "Figures/RNA/TCGA_cibersort_age_rec_tumor.pdf", width = 22, height = 12)
ggplot(cibersort_res_TCGA_tumor_long, aes(x = fct_reorder(celltype,-value, .fun = median), y = value)) +
  geom_boxplot(color = "black", aes(fill=age_rec))+
  #stat_pvalue_manual(
  #  stat.test %>% filter(p.adj< 0.2),
  #  label = "p.adj",
  #  tip.length = 0.01,
  #  y.position = 0.3
  #) +
  stat_compare_means()+
  labs(x = "", y = "", fill="Age, Recurrence") +
  scale_y_continuous(limits = c(0,0.6))+
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("lightblue", "orange", "blue", "red"), 
                    labels=c("â‰¤70 No Recu", ">70 No Recu", "â‰¤70 Recu", ">70 Recu"))  # Change the palette as needed
dev.off()



######### repeat for lung 
#plot old vs young 

#prepare data in long format 
cibersort_res_TCGA_lung_long <- cibersort_res_TCGA_lung %>%
  select(-c(P.value, Correlation, RMSE, dead_or_not_five_years, DFS_STATUS, age_3_grps, shortLetterCode, age_rec)) %>%
  gather(key = "celltype", value = "value", -age_grp_new)
#correct value to remove zeros 
cibersort_res_TCGA_lung_long$value <- cibersort_res_TCGA_lung_long$value +0.001

# Create a list to store the results
results_list <- list()

# Loop through each cell type
cell_types <- unique(cibersort_res_TCGA_lung_long$celltype)
for (cell_type in cell_types) {
  data_subset <- filter(cibersort_res_TCGA_lung_long, celltype == cell_type)
  
  # Perform Wilcoxon rank-sum test to compare values between old and young groups
  wilcox_result <- wilcox.test(value ~ age_grp_new, data = data_subset)
  
  # Extract the p-value
  p_value <- wilcox_result$p.value
  
  # Store the results in a list
  results_list[[cell_type]] <- data.frame(CellType = cell_type, PValue = p_value)
}

# Combine the results into a single data frame
results_df <- do.call(rbind, results_list)
#turn to FDR 
results_df$FDR <- p.adjust(results_df$PValue, method = "fdr")
results_df <- results_df %>% dplyr::rename(celltype=CellType)

merged_data <- cibersort_res_TCGA_lung_long %>%
  left_join(results_df, by = "celltype")


# Create a plot
pdf(file = "Figures/RNA/TCGA_cibersort_lung_age_grp_new.pdf", width = 14, height = 8)
ggplot(merged_data, aes(x = fct_reorder(celltype,-value, .fun = median), y = value, fill = age_grp_new)) +
  #geom_violin() +
  geom_boxplot(color = "black") +
  geom_text(aes(label = ifelse(PValue < 0.05, sprintf("P = %.3f", PValue), "ns")),
            y = rep(max(merged_data$value), nrow(merged_data)),
            size = 3)+
  labs(x = "", y = "", fill="Age") +
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("darkblue", "green4"), labels=c(">70", "â‰¤70"))  # Change the palette as needed
dev.off()


#### repeat for age and recurrence 

#prepare data in long format 
cibersort_res_TCGA_lung_long <- cibersort_res_TCGA_lung %>%
  select(-c(P.value, Correlation, RMSE, shortLetterCode, age_grp_new, age_3_grps, dead_or_not_five_years,DFS_STATUS )) %>%
  gather(key = "celltype", value = "value", -age_rec)
#correct value to remove zeros 
cibersort_res_TCGA_lung_long$value <- cibersort_res_TCGA_lung_long$value +0.001
cibersort_res_TCGA_lung_long$age_rec <- factor(cibersort_res_TCGA_lung_long$age_rec, 
                                                        levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

# perform stat analysis
stat.test <- cibersort_res_TCGA_lung_long %>%
  group_by(celltype) %>%
  wilcox_test(value ~ age_rec)

#add xy position
stat.test <- stat.test %>%
  add_xy_position(x = "celltype", dodge = 0.8)

#filter to visualize only comparisons between recurrence and no recurrence 
stat.test <- stat.test %>% 
  filter(group1 %in% "young_rec" & group2 %in% "old_rec" | group1 %in% "young_no_rec" & group2 %in% "old_no_rec")

#plot 
pdf(file = "Figures/RNA/TCGA_cibersort_lung_age_rec.pdf", width = 22, height = 12)
ggplot(cibersort_res_TCGA_lung_long, aes(x = fct_reorder(celltype,-value, .fun = median), y = value)) +
  geom_boxplot(color = "black", aes(fill=age_rec))+
  #stat_pvalue_manual(
  #  stat.test %>% filter(p.adj< 0.2),
  #  label = "p.adj",
  #  tip.length = 0.01,
  #  y.position = 0.3
  #) +
  stat_compare_means()+
  labs(x = "", y = "", fill="Age, Recurrence") +
  scale_y_continuous(limits = c(0,0.6))+
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("skyblue", "orangered", "darkblue", "darkred"), 
                    labels=c("â‰¤70 No Recu", ">70 No Recu", "â‰¤70 Recu", ">70 Recu"))  # Change the palette as needed
dev.off()



##### loop over all cibersort results to plot bboxplots by age and recurrence 

#tumor 
plot_data <- cibersort_res_TCGA_tumor %>% select(-c(P.value, Correlation, RMSE, age_grp_new, age_3_grps, dead_or_not_five_years, DFS_STATUS, shortLetterCode))
#creating a variable to loop over 
col_names_cibersort <- colnames(cibersort_res_TCGA_tumor)
col_names_cibersort <- col_names_cibersort[1:22]

plot_data$age_rec <- factor(plot_data$age_rec, 
                                               levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))
#add 0.001 to all values 
plot_data <- plot_data %>% mutate_at(vars(-age_rec), ~ . + 0.001)

#loop over columns 
for (i in col_names_cibersort){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("old_no_rec", "young_no_rec"), 
                                          c("old_rec", "young_rec")))+
    scale_color_manual(values = c("lightblue", "orange", "blue", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "old_no_rec", "young_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Cibersort/TCGA/tumor/", paste0(i, paste0(".boxplot"), paste0(".Cibersort.by.age_recu_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}




#lung 

plot_data <- cibersort_res_TCGA_lung %>% select(-c(P.value, Correlation, RMSE, age_grp_new, age_3_grps, dead_or_not_five_years, DFS_STATUS, shortLetterCode))
#creating a variable to loop over 
col_names_cibersort <- colnames(cibersort_res_TCGA_lung)
col_names_cibersort <- col_names_cibersort[1:22]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))
#add 0.001 to all values 
plot_data <- plot_data %>% mutate_at(vars(-age_rec), ~ . + 0.001)

#loop over columns 
for (i in col_names_cibersort){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("old_no_rec", "young_no_rec"), 
                                          c("old_rec", "young_rec")))+
    scale_color_manual(values = c("skyblue", "orangered", "darkblue", "darkred"))+
    scale_x_discrete(breaks= c("young_no_rec", "old_no_rec", "young_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Cibersort/TCGA/lung/", paste0(i, paste0(".boxplot"), paste0(".Cibersort.by.age_recu_lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}




#perform a heatmap for all samples 
#set colors 
library(circlize)

#get matrix for heatmap  
heatmap_mat <- cibersort_res_TCGA %>% select(-c(P.value, Correlation, RMSE, age_grp_new, age_3_grps, dead_or_not_five_years, DFS_STATUS, shortLetterCode, age_rec))

#get maximal calues 
# Get the maximal enrichment score for each column (pathway)
max_scores <- apply(heatmap_mat, 2, max)

# Get the minimal enrichment score for each column (pathway)
min_scores <- apply(heatmap_mat, 2, min)

# Print the maximal and minimal scores for each pathway
max_min_scores <- data.frame(celltype = colnames(heatmap_mat), Max_Score = max_scores, Min_Score = min_scores)
print(max_min_scores)


#get maximal and minimal scores 
max(max_min_scores$Max_Score)
min(max_min_scores$Max_Score)
max(max_min_scores$Min_Score)
min(max_min_scores$Min_Score)

col_fun = colorRamp2(c(0, 0.4885287), c("white", "red"))
col_fun(seq(0, 0.4885287))

#transplse so you get pathways as rows 
heatmap_mat_t <- as.data.frame(t(heatmap_mat))

#convert to matrix 
heatmap_mat_t <- as.matrix(heatmap_mat_t)

#plot heatmap using complex heatmaps 

set.seed(1234)

# Define colors for each levels of qualitative variables

col = list(age_grp_new = c("greater_70" = "darkblue", "less_equal_70" = "darkgreen"), 
           DFS_STATUS=c("Recurrence" = "darkred", "No.Recurrence" = "orange"), 
           shortLetterCode=c("TP" ="red", "NT"="blue"))

# Create the heatmap annotation
library(ComplexHeatmap)

ha <- HeatmapAnnotation(
  age_grp_new = cibersort_res_TCGA$age_grp_new,
  DFS_STATUS = cibersort_res_TCGA$DFS_STATUS,
  sample_type=cibersort_res_TCGA$shortLetterCode,
  col = col)

#plot
pdf(file = "Figures/RNA/TCGA_cibersort_heatmap_clustered.pdf", height = 20, width = 50)
ComplexHeatmap::Heatmap(heatmap_mat_t, 
                        rect_gp = gpar(col = "black", lwd = 2),
                        col = col_fun, 
                        row_title_side = "left", 
                        column_title_side = "bottom",
                        cluster_rows = FALSE, 
                        cluster_columns = TRUE,
                        row_names_gp = gpar(fontsface="bold", fontsize= 18),
                        row_names_side = "left", 
                        column_title = "", row_title = "", 
                        row_labels =rownames(heatmap_mat_t),
                        top_annotation = ha)
dev.off()




###### repeat the above (age_rec) and heatmap for NYU data #######

##### loop over all cibersort results to plot bboxplots by age and recurrence 

#tumor 
plot_data <- cibersort_res_no_seond_prim_tumor %>% select(-c(P.value, Correlation, RMSE, 
                                                             Sample_Type_Involved, Progression_Lab_Inv, 
                                                             age_3_grps, ProgType_Lab, age_grp, Progression))
#creating a variable to loop over 
col_names_cibersort <- colnames(cibersort_res_no_seond_prim_tumor)
col_names_cibersort <- col_names_cibersort[1:22]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))
#add 0.001 to all values 
plot_data <- plot_data %>% mutate_at(vars(-age_rec), ~ . + 0.001)

#loop over columns 
for (i in col_names_cibersort){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("old_no_rec", "young_no_rec"), 
                                          c("old_rec", "young_rec")))+
    scale_color_manual(values = c("lightblue", "orange", "blue", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "old_no_rec", "young_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Cibersort/Tumor/", paste0(i, paste0(".boxplot"), paste0(".Cibersort.by.age_recu_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}




#lung 

plot_data <- cibersort_res_no_seond_prim_lung %>% select(-c(P.value, Correlation, RMSE, 
                                                            Sample_Type_Involved, Progression_Lab_Inv, 
                                                            age_3_grps, ProgType_Lab, age_grp, Progression))
#creating a variable to loop over 
col_names_cibersort <- colnames(cibersort_res_no_seond_prim_lung)
col_names_cibersort <- col_names_cibersort[1:22]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))
#add 0.001 to all values 
plot_data <- plot_data %>% mutate_at(vars(-age_rec), ~ . + 0.001)

#loop over columns 
for (i in col_names_cibersort){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("old_no_rec", "young_no_rec"), 
                                          c("old_rec", "young_rec")))+
    scale_color_manual(values = c("skyblue", "orangered", "darkblue", "darkred"))+
    scale_x_discrete(breaks= c("young_no_rec", "old_no_rec", "young_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    scale_y_log10()+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("Cibersort/Lung/", paste0(i, paste0(".boxplot"), paste0(".Cibersort.by.age_recu_lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}




#perform a heatmap for all samples 
#set colors 
library(circlize)

#get matrix for heatmap  
heatmap_mat <- cibersort_res_no_seond_prim %>% select(-c(P.value, Correlation, RMSE, age_grp, age_3_grps, Sample_Type_Involved, ProgType_Lab, Progression, age_rec, Progression_Lab_Inv))

#get maximal calues 
# Get the maximal enrichment score for each column (pathway)
max_scores <- apply(heatmap_mat, 2, max)

# Get the minimal enrichment score for each column (pathway)
min_scores <- apply(heatmap_mat, 2, min)

# Print the maximal and minimal scores for each pathway
max_min_scores <- data.frame(celltype = colnames(heatmap_mat), Max_Score = max_scores, Min_Score = min_scores)
print(max_min_scores)


#get maximal and minimal scores 
max(max_min_scores$Max_Score)
min(max_min_scores$Max_Score)
max(max_min_scores$Min_Score)
min(max_min_scores$Min_Score)

col_fun = colorRamp2(c(0, 0.4638758), c("white", "red"))
col_fun(seq(0, 0.4638758))

#transplse so you get pathways as rows 
heatmap_mat_t <- as.data.frame(t(heatmap_mat))

#convert to matrix 
heatmap_mat_t <- as.matrix(heatmap_mat_t)

#plot heatmap using complex heatmaps 

set.seed(1234)

# Define colors for each levels of qualitative variables

col = list(age_grp = c("greater_70" = "darkblue", "less_equal_70" = "darkgreen"), 
           Progression=c("1" = "darkred", "0" = "orange"), 
           Sample_Type_Involved=c("Lung.Tissue.In" ="red", "Lung.Tissue.UnIn"="blue"))

# Create the heatmap annotation
library(ComplexHeatmap)

ha <- HeatmapAnnotation(
  age_grp = cibersort_res_no_seond_prim$age_grp,
  Progression = cibersort_res_no_seond_prim$Progression,
  sample_type=cibersort_res_no_seond_prim$Sample_Type_Involved,
  col = col)


#plot
pdf(file = "Figures/RNA/NYU_cibersort_heatmap_clustered.pdf", height = 26, width = 30)
ComplexHeatmap::Heatmap(heatmap_mat_t, 
                        rect_gp = gpar(col = "black", lwd = 2),
                        col = col_fun, 
                        row_title_side = "left", 
                        column_title_side = "bottom",
                        cluster_rows = FALSE, 
                        cluster_columns = TRUE,
                        row_names_gp = gpar(fontsface="bold", fontsize= 18),
                        row_names_side = "left", 
                        column_title = "", row_title = "", 
                        row_labels =rownames(heatmap_mat_t),
                        top_annotation = ha)
dev.off()





##########table 1 without secondary primary ##################

Table.1.data <- RNA.data %>% data.frame() %>%  filter(ProgType_Lab!="Secondary.Primary")
Table.1.data <- Table.1.data %>% 
  dplyr::filter(Sample_Type_Involved=="Lung.Tissue.In")

#add statistical analysis column 
#define p value function 

pvalue <- function(x, ...) {
  # Construct vectors of data y, and groups (strata) g
  y <- unlist(x)
  g <- factor(rep(1:length(x), times=sapply(x, length)))
  if (is.numeric(y)) {
    # For numeric variables, perform a standard 2-sample t-test
    p <- t.test(y ~ g)$p.value
  } else {
    # For categorical variables, perform a chi-squared test of independence
    p <- chisq.test(table(y, g))$p.value
  }
  # Format the p-value, using an HTML entity for the less-than sign.
  # The initial empty string places the output on the line below the variable label.
  c("", sub("<", "&lt;", format.pval(p, digits=3, eps=0.001)))
}

#create table 1 using table 1 package 
table1(~ 
         #set variables you want to display. Categorical as factors, continous as numeric 
         factor(Male_1) + factor(RACE) + as.numeric(Age) + factor(Smoking_status) + as.numeric(Pack_Years) 
       + factor(Stage) +factor(Outcome) + factor(Progression_Lab) + factor(ProgType_Lab)+ as.numeric(Size_cm) + factor(five_y_mortality)
       # set the variable you want to stratify by 
       | age_grp, 
       #set data 
       data=Table.1.data, 
       #set stat display options for continous variables (options from stat.default)
       render.continuous = c((.="Median [Q1, Q3]")))
#now add stats (same as above except where notes added ) for these two groups only 
table1(~ 
         factor(Male_1) + factor(RACE) + as.numeric(Age) + factor(Smoking_status) + as.numeric(Pack_Years) 
       + factor(Stage) +factor(Outcome) + factor(Progression_Lab) + factor(ProgType_Lab)+ as.numeric(Size_cm) + factor(five_y_mortality)
       | age_grp, data=Table.1.data, 
       # don't display overall column 
       overall = F,
       render.continuous = c((.="Median [Q1, Q3]")),
       #add p value as extra column (defined in function above)
       extra.col = list("P-value" = pvalue))

#stats for recurrence type without the group of no recurrence 
stats.table <- Table.1.data %>% 
  dplyr::filter(ProgType_Lab != "No.Recurrence")

chisq.test(stats.table$ProgType_Lab, stats.table$age_grp) #p=0.5584

#get p value of numerical variables 
t.test(Table.1.data$Age ~ Table.1.data$age_grp)$p.value # p < 0.001
t.test(as.numeric(Table.1.data$Pack_Years) ~ Table.1.data$age_grp) #p-value = 0.00372
t.test(as.numeric(Table.1.data$Size_cm) ~ Table.1.data$age_grp) #p-value = 0.00372

#copy and paste the above results and edit in excel / word 

####### KM of recurrence according to age, NYU early stage, according to age median (70 )########

#use patients data 
Table.1.data <- RNA.data %>% data.frame() %>%  filter(ProgType_Lab!="Secondary.Primary")
Table.1.data <- Table.1.data %>% 
  dplyr::filter(Sample_Type_Involved=="Lung.Tissue.In")

# column to be used as status is DFS_STATUS
survival.data <- Table.1.data[, c("New_TTP","Progression", "age_grp" )]

#rename the new df 
colnames(survival.data) <- c("time", "status", "Age")

# turn the data into data frame so it can be used in survival function. 
#turn the class of columns so its either factor or numeric to be used in survival functions 
survival.data<- data.frame(survival.data)
survival.data$time <- as.numeric(survival.data$time)
survival.data$status <- as.numeric(survival.data$status)
survival.data$Age <- factor(survival.data$Age, levels=c("less_equal_70", "greater_70"))

#remove NA 
survival.data <- na.omit(survival.data)

#get median survival in each group 
survival.data %>% 
  group_by(Age) %>% 
  summarise(median=median(time), 
            Q1=quantile(time, 0.25), 
            Q3=quantile(time, 0.75))

#create survival object

surv <- Surv(survival.data$time, survival.data$status)

#create survival df
sfit <- survfit(Surv(time, status)~Age, data=survival.data)
sfit

survival.plot <- ggsurvplot(sfit, data = survival.data,
                            fun = "pct", ggtheme = theme_pubr(), 
                            conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
                            legend.labs=c("Young", "Old"), legend.title="Age",  
                            palette=c("green4", "blue3"), size=1,
                            title="Kaplan-Meier Curve for Recurrence According to Age",
                            ylab="Overall Recurrence Probability",
                            xlab="Time(Days)",
                            # tables.col = "strata", #color of numbers inside risk table
                            tables.height = 0.15,
                            fontsize = 4,
                            risk.table.y.text.col = T,
                            cumcensor = TRUE, 
                            tables.theme = theme_cleantable(),
                            # risk.table.y.text = FALSE,
                            risk.table.title = "Number at risk (cumulative number of recurrence)",
                            cumcensor.title = "Cumulative number of censored subjects"
)


#save the plot (export as PNG)
survival.plot




####### NYU ssGSEA correlation with age ###########
#add age (median)
ssGSEA_res_t$age_grp <- RNA.data$age_grp
ssGSEA_res_t$ProgType_Lab <- RNA.data$ProgType_Lab


#choose only no second primary 
ssGSEA_res_t_no_second_prim <- ssGSEA_res_t %>% filter(ProgType_Lab!="Secondary.Primary")

#split tumor and lung 
ssGSEA_res_t_no_second_prim_tumor <- ssGSEA_res_t_no_second_prim %>% filter(Sample_Type_Involved=="Lung.Tissue.In")
ssGSEA_res_t_no_second_prim_lung <- ssGSEA_res_t_no_second_prim %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")

#examine one plot 
ggplot(ssGSEA_res_t_no_second_prim_tumor, aes(x=Age, y=HALLMARK_TNFA_SIGNALING_VIA_NFKB))+
  geom_point()+
  geom_smooth(method = "lm")+
  stat_cor(method = "spearman")+
  theme_bw()+
  xlab("Age")+ylab("")+
  theme(axis.text.x = element_text(size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")


#plto all pathways 
# List of pathway column names
pathway_columns <- colnames(ssGSEA_res_t_no_second_prim_tumor)[1:52]  # 
for (i in pathway_columns){
  p <- ggplot(ssGSEA_res_t_no_second_prim_tumor, aes_string(x= ssGSEA_res_t_no_second_prim_tumor$Age, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    theme_bw()+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "top")+
    facet_grid(. ~ Progression_Lab)  # Facet by the "Progression_Lab" column
  
  #save it 
  pdf_output <- paste0("ssGSEA/tumor/", paste0(i, paste0("correlation"), paste0("with_age_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


## repeat for lung 
pathway_columns <- colnames(ssGSEA_res_t_no_second_prim_lung)[1:52]  # 
for (i in pathway_columns){
  p <- ggplot(ssGSEA_res_t_no_second_prim_lung, aes_string(x= ssGSEA_res_t_no_second_prim_lung$Age, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    theme_bw()+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "top")+
    facet_grid(. ~ Progression_Lab)  # Facet by the "Progression_Lab" column
  
  #save it 
  pdf_output <- paste0("ssGSEA/lung/", paste0(i, paste0("correlation"), paste0("with_age_lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


####determine  How much of the pathway activation is due to age  using regression model ####

###Tumor subset 
# List of pathway column names
pathway_columns <- colnames(ssGSEA_res_t_no_second_prim_tumor)[1:52]  # 

# Create an empty data frame to store regression results
regression_results <- data.frame(Pathway = character(0), Coefficient = numeric(0))

# Perform linear regression for each pathway
for (pathway in pathway_columns) {
  lm_model <- lm(ssGSEA_res_t_no_second_prim_tumor[[pathway]] ~ Age, data = ssGSEA_res_t_no_second_prim_tumor)
  
  # Extract the coefficient for the "Age" variable
  coefficient <- coef(lm_model)["Age"]
  
  # Store the pathway name and its coefficient in the results data frame
  result <- data.frame(Pathway = pathway, Coefficient = coefficient)
  regression_results <- bind_rows(regression_results, result)
}

regression_results <- regression_results %>% arrange(desc(Coefficient))

# Print the results
print(regression_results)
#save 
write.csv(regression_results, file = "ssGSEA/tumor/regression_results_NYU_tumor.csv")

#### repeat for lung 
# List of pathway column names
pathway_columns <- colnames(ssGSEA_res_t_no_second_prim_lung)[1:52]  # 

# Create an empty data frame to store regression results
regression_results <- data.frame(Pathway = character(0), Coefficient = numeric(0))

# Perform linear regression for each pathway
for (pathway in pathway_columns) {
  lm_model <- lm(ssGSEA_res_t_no_second_prim_lung[[pathway]] ~ Age, data = ssGSEA_res_t_no_second_prim_lung)
  
  # Extract the coefficient for the "Age" variable
  coefficient <- coef(lm_model)["Age"]
  
  # Store the pathway name and its coefficient in the results data frame
  result <- data.frame(Pathway = pathway, Coefficient = coefficient)
  regression_results <- bind_rows(regression_results, result)
}

regression_results <- regression_results %>% arrange(desc(Coefficient))

# Print the results
print(regression_results)
#save 
write.csv(regression_results, file = "ssGSEA/lung/regression_results_NYU_lung.csv")




##### account for age and recurrence using linear model ##### 

####tumor subset 

# Load necessary libraries
library(ggplot2)
library(broom)

# Create an empty data frame to store the regression results
regression_results <- data.frame()

# List of pathway column names
pathway_columns <- colnames(ssGSEA_res_t_no_second_prim_tumor)[1:52]  # 

# Loop through each pathway and perform regression
for (pathway in pathway_columns) {
  # Create a formula for the regression model
  formula <- as.formula(paste(pathway, "~ Age + Progression_Lab"))
  
  # Fit the multiple linear regression model
  model <- lm(formula, data = ssGSEA_res_t_no_second_prim_tumor)
  
  # Summarize the regression results
  summary <- tidy(model)
  
  # Add the pathway name as a column in the results
  summary$pathway <- pathway
  
  # Append the results to the overall results data frame
  regression_results <- rbind(regression_results, summary)
}

#save results 
write.csv(regression_results, file = "ssGSEA/tumor/regression_results_NYU_with_recurrence_tumor.csv")



#plot results 
plot_data <- regression_results %>% filter(term!="(Intercept)")

#set size 
plot_data$size <- ifelse(plot_data$p.value <=0.05, 8, 4)
plot_data$size <- factor(plot_data$size)

pdf(file = "ssGSEA/tumor/linear_regression_model_results_age_and_rec_NYU_tumor.pdf", height = 15, width = 30)
ggplot(plot_data, aes(x=pathway, y=estimate, color=term, size=size))+
  geom_point(alpha=0.7)+
  scale_color_manual(values = c("darkblue", "red"), labels=c("Age", "Recurrence"))+
  scale_size_manual(values = c(4, 8), labels=c("ns", "â‰¤0.05")) +  # Set size range
  xlab("")+ylab("")+
  labs(
    x = "",
    y = "Effect Estimate",
    size = "p-value",
    color = "Variable") +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 22, face = "bold"))
dev.off()






####lung subset 

# Load necessary libraries
library(ggplot2)
library(broom)

# Create an empty data frame to store the regression results
regression_results <- data.frame()

# List of pathway column names
pathway_columns <- colnames(ssGSEA_res_t_no_second_prim_lung)[1:52]  # 

# Loop through each pathway and perform regression
for (pathway in pathway_columns) {
  # Create a formula for the regression model
  formula <- as.formula(paste(pathway, "~ Age + Progression_Lab"))
  
  # Fit the multiple linear regression model
  model <- lm(formula, data = ssGSEA_res_t_no_second_prim_lung)
  
  # Summarize the regression results
  summary <- tidy(model)
  
  # Add the pathway name as a column in the results
  summary$pathway <- pathway
  
  # Append the results to the overall results data frame
  regression_results <- rbind(regression_results, summary)
}

#save results 
write.csv(regression_results, file = "ssGSEA/lung/regression_results_NYU_with_recurrence_lung.csv")




#plot results 
plot_data <- regression_results %>% filter(term!="(Intercept)")

#set size 
plot_data$size <- ifelse(plot_data$p.value <=0.05, 8, 4)
plot_data$size <- factor(plot_data$size)

pdf(file = "ssGSEA/lung/linear_regression_model_results_age_and_rec_NYU_lung.pdf", height = 15, width = 30)
ggplot(plot_data, aes(x=pathway, y=estimate, color=term, size=size))+
  geom_point(alpha=0.7)+
  scale_color_manual(values = c("darkblue", "red"), labels=c("Age", "Recurrence"))+
  scale_size_manual(values = c(4, 8), labels=c("ns", "â‰¤0.05")) +  # Set size range
  xlab("")+ylab("")+
  labs(
    x = "",
    y = "Effect Estimate",
    size = "p-value",
    color = "Variable") +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 22, face = "bold"))
dev.off()




#########ssGSEA differences between groups of patients (age_rec)

#create age_rec variable 
ssGSEA_res_t_no_second_prim_tumor <- ssGSEA_res_t_no_second_prim_tumor %>% 
  mutate(age_rec=case_when(
    age_grp=="greater_70" & Progression_Lab=="Recurrence" ~ "old_rec", 
    age_grp=="greater_70" & Progression_Lab=="No.Recurrence" ~ "old_no_rec", 
    age_grp=="less_equal_70" & Progression_Lab=="Recurrence" ~ "young_rec", 
    age_grp=="less_equal_70" & Progression_Lab=="No.Recurrence" ~ "young_no_rec", 
  ))


ssGSEA_res_t_no_second_prim_lung <- ssGSEA_res_t_no_second_prim_lung %>% 
  mutate(age_rec=case_when(
    age_grp=="greater_70" & Progression_Lab=="Recurrence" ~ "old_rec", 
    age_grp=="greater_70" & Progression_Lab=="No.Recurrence" ~ "old_no_rec", 
    age_grp=="less_equal_70" & Progression_Lab=="Recurrence" ~ "young_rec", 
    age_grp=="less_equal_70" & Progression_Lab=="No.Recurrence" ~ "young_no_rec", 
  ))





##### loop over columns with age_rec

#tumor subset 

plot_data <- ssGSEA_res_t_no_second_prim_tumor
#creating a variable to loop over 
pathways <- colnames(ssGSEA_res_t_no_second_prim_tumor)
pathways <- pathways[1:52]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

#loop over columns 
for (i in pathways){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("old_no_rec", "young_no_rec"), 
                                          c("old_rec", "young_rec")))+
    scale_color_manual(values = c("lightblue", "orange", "blue", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "old_no_rec", "young_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("ssGSEA/tumor/age_rec/", paste0(i, paste0(".boxplot"), paste0(".ssGSEA.by.age_recu_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


#lung subset

plot_data <- ssGSEA_res_t_no_second_prim_lung
#creating a variable to loop over 
pathways <- colnames(ssGSEA_res_t_no_second_prim_lung)
pathways <- pathways[1:52]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

#loop over columns 
for (i in pathways){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("old_no_rec", "young_no_rec"), 
                                          c("old_rec", "young_rec")))+
    scale_color_manual(values = c("skyblue", "orangered", "darkblue", "darkred"))+
    scale_x_discrete(breaks= c("young_no_rec", "old_no_rec", "young_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("ssGSEA/lung/age_rec/", paste0(i, paste0(".boxplot"), paste0(".ssGSEA.by.age_recu_lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}





################################################################################
########################### TCGA ssGSEA analysis ###############################

#read results 
ssGSEA_res_TCGA <- read.delim2(file = "Data/ssGSEA_results_TCGA_stage_I.txt", row.names = 1, header = TRUE)

#transpose 
ssGSEA_res_TCGA_t <- data.frame(t(ssGSEA_res_TCGA))
ssGSEA_res_TCGA_t <- ssGSEA_res_TCGA_t %>% mutate_all(as.numeric)

#add metadata 
ssGSEA_res_TCGA_t$Age <- tcga_metadata_stage_I$age_at_index
ssGSEA_res_TCGA_t$age_grp_new <- tcga_metadata_stage_I$age_grp_new
ssGSEA_res_TCGA_t$DFS_STATUS <- tcga_metadata_stage_I$DFS_STATUS
ssGSEA_res_TCGA_t$sample_type <- tcga_metadata_stage_I$shortLetterCode
ssGSEA_res_TCGA_t <- ssGSEA_res_TCGA_t %>% 
  mutate(age_rec=case_when(
    age_grp_new=="greater_70" & DFS_STATUS=="Recurrence" ~ "old_rec", 
    age_grp_new=="greater_70" & DFS_STATUS=="No.Recurrence" ~ "old_no_rec", 
    age_grp_new=="less_equal_70" & DFS_STATUS=="Recurrence" ~ "young_rec", 
    age_grp_new=="less_equal_70" & DFS_STATUS=="No.Recurrence" ~ "young_no_rec", 
  ))
  


#remove any NA in DFS or age_grp_new 
ssGSEA_res_TCGA_t <- ssGSEA_res_TCGA_t %>% filter(age_grp_new!="NA")
ssGSEA_res_TCGA_t <- ssGSEA_res_TCGA_t %>% filter(DFS_STATUS!="NA")

#seperate tutmor and lung 
ssGSEA_res_TCGA_t_tumor <- ssGSEA_res_TCGA_t %>% filter(sample_type=="TP")
ssGSEA_res_TCGA_t_lung <- ssGSEA_res_TCGA_t %>% filter(sample_type=="NT")


##### loop over columns with age_rec

#tumor subset 

plot_data <- ssGSEA_res_TCGA_t_tumor
#creating a variable to loop over 
pathways <- colnames(ssGSEA_res_TCGA_t)
pathways <- pathways[1:52]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

#loop over columns 
for (i in pathways){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("old_no_rec", "young_no_rec"), 
                                          c("old_rec", "young_rec")))+
    scale_color_manual(values = c("lightblue", "orange", "blue", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "old_no_rec", "young_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("ssGSEA/TCGA/tumor/age_rec/", paste0(i, paste0(".boxplot"), paste0(".ssGSEA.by.age_recu_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


#lung subset

plot_data <- ssGSEA_res_TCGA_t_lung
#creating a variable to loop over 
pathways <- colnames(ssGSEA_res_TCGA_t)
pathways <- pathways[1:52]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

#loop over columns 
for (i in pathways){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("old_no_rec", "young_no_rec"), 
                                          c("old_rec", "young_rec")))+
    scale_color_manual(values = c("skyblue", "orangered", "darkblue", "darkred"))+
    scale_x_discrete(breaks= c("young_no_rec", "old_no_rec", "young_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(plot.title = element_text(face="bold"), 
          axis.text.x = element_markdown(face = "bold", size=14), 
          axis.text.y = element_text(face = "bold", size = 14), 
          legend.position = "none")
  
  #save it 
  pdf_output <- paste0("ssGSEA/TCGA/lung/age_rec/", paste0(i, paste0(".boxplot"), paste0(".ssGSEA.by.age_recu_lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


########### correlation with age ssGSEA TCGA ########

#tumor subset correlation plots 

plot_data <- ssGSEA_res_TCGA_t_tumor
#creating a variable to loop over 
pathways <- colnames(ssGSEA_res_TCGA_t)
pathways <- pathways[1:52]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))


for (i in pathways){
  p <- ggplot(plot_data, aes_string(x= plot_data$Age, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    theme_bw()+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "top")+
    facet_grid(. ~ DFS_STATUS)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("ssGSEA/TCGA/tumor/correlation_plots/", paste0(i, paste0("correlation"), paste0("_with_age_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


## repeat for lung 
plot_data <- ssGSEA_res_TCGA_t_lung
#creating a variable to loop over 
pathways <- colnames(ssGSEA_res_TCGA_t)
pathways <- pathways[1:52]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))


for (i in pathways){
  p <- ggplot(plot_data, aes_string(x= plot_data$Age, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    theme_bw()+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "top")+
    facet_grid(. ~ DFS_STATUS)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("ssGSEA/TCGA/lung/correlation_plots/", paste0(i, paste0("correlation"), paste0("_with_age_lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


####determine  How much of the pathway activation is due to age  using regression model TCGA cohort  ####

###Tumor subset 
# List of pathway column names
pathway_columns <- colnames(ssGSEA_res_TCGA_t_tumor)[1:52]  # 

# Create an empty data frame to store regression results
regression_results <- data.frame(Pathway = character(0), Coefficient = numeric(0))

# Perform linear regression for each pathway
for (pathway in pathway_columns) {
  lm_model <- lm(ssGSEA_res_TCGA_t_tumor[[pathway]] ~ Age, data = ssGSEA_res_TCGA_t_tumor)
  
  # Extract the coefficient for the "Age" variable
  coefficient <- coef(lm_model)["Age"]
  
  # Store the pathway name and its coefficient in the results data frame
  result <- data.frame(Pathway = pathway, Coefficient = coefficient)
  regression_results <- bind_rows(regression_results, result)
}

regression_results <- regression_results %>% arrange(desc(Coefficient))

# Print the results
print(regression_results)
#save 
write.csv(regression_results, file = "ssGSEA/TCGA/tumor/regression_results_TCGA_tumor.csv")

#### repeat for lung 
pathway_columns <- colnames(ssGSEA_res_TCGA_t_lung)[1:52]  # 

# Create an empty data frame to store regression results
regression_results <- data.frame(Pathway = character(0), Coefficient = numeric(0))

# Perform linear regression for each pathway
for (pathway in pathway_columns) {
  lm_model <- lm(ssGSEA_res_TCGA_t_lung[[pathway]] ~ Age, data = ssGSEA_res_TCGA_t_lung)
  
  # Extract the coefficient for the "Age" variable
  coefficient <- coef(lm_model)["Age"]
  
  # Store the pathway name and its coefficient in the results data frame
  result <- data.frame(Pathway = pathway, Coefficient = coefficient)
  regression_results <- bind_rows(regression_results, result)
}

regression_results <- regression_results %>% arrange(desc(Coefficient))

# Print the results
print(regression_results)
#save 
write.csv(regression_results, file = "ssGSEA/TCGA/lung/regression_results_TCGA_lung.csv")




##### account for age and recurrence using linear model ##### 

####tumor subset 

# Create an empty data frame to store the regression results
regression_results <- data.frame()

# List of pathway column names
pathway_columns <- colnames(ssGSEA_res_TCGA_t_tumor)[1:52]  # 

# Loop through each pathway and perform regression
for (pathway in pathway_columns) {
  # Create a formula for the regression model
  formula <- as.formula(paste(pathway, "~ Age + DFS_STATUS"))
  
  # Fit the multiple linear regression model
  model <- lm(formula, data = ssGSEA_res_TCGA_t_tumor)
  
  # Summarize the regression results
  summary <- tidy(model)
  
  # Add the pathway name as a column in the results
  summary$pathway <- pathway
  
  # Append the results to the overall results data frame
  regression_results <- rbind(regression_results, summary)
}

#save results 
write.csv(regression_results, file = "ssGSEA/TCGA/tumor/regression_results_TCGA_with_recurrence_tumor.csv")


#plot results 
plot_data <- regression_results %>% filter(term!="(Intercept)")

#set size 
plot_data$size <- ifelse(plot_data$p.value <=0.05, 8, 4)
plot_data$size <- factor(plot_data$size)

pdf(file = "ssGSEA/TCGA/tumor/linear_regression_model_results_age_and_rec_TCGA_tumor.pdf", height = 15, width = 30)
ggplot(plot_data, aes(x=pathway, y=estimate, color=term, size=size))+
  geom_point(alpha=0.7)+
  scale_color_manual(values = c("darkblue", "red"), labels=c("Age", "Recurrence"))+
  scale_size_manual(values = c(4, 8), labels=c("ns", "â‰¤0.05")) +  # Set size range
  xlab("")+ylab("")+
  labs(
    x = "",
    y = "Effect Estimate",
    size = "p-value",
    color = "Variable") +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 22, face = "bold"))
dev.off()



####lung subset 

# Create an empty data frame to store the regression results
regression_results <- data.frame()

# List of pathway column names
pathway_columns <- colnames(ssGSEA_res_TCGA_t_lung)[1:52]  # 

# Loop through each pathway and perform regression
for (pathway in pathway_columns) {
  # Create a formula for the regression model
  formula <- as.formula(paste(pathway, "~ Age + DFS_STATUS"))
  
  # Fit the multiple linear regression model
  model <- lm(formula, data = ssGSEA_res_TCGA_t_lung)
  
  # Summarize the regression results
  summary <- tidy(model)
  
  # Add the pathway name as a column in the results
  summary$pathway <- pathway
  
  # Append the results to the overall results data frame
  regression_results <- rbind(regression_results, summary)
}

#save results 
write.csv(regression_results, file = "ssGSEA/TCGA/lung/regression_results_TCGA_with_recurrence_lung.csv")

plot_data <- regression_results %>% filter(term!="(Intercept)")

#set size 
plot_data$size <- ifelse(plot_data$p.value <=0.05, 8, 4)

pdf(file = "ssGSEA/TCGA/lung/linear_regression_model_results_age_and_rec_TCGA_lung.pdf", height = 15, width = 30)
ggplot(plot_data, aes(x=pathway, y=estimate, color=term, size=size))+
  geom_point(alpha=0.7)+
  scale_color_manual(values = c("darkblue", "red"), labels=c("Age", "Recurrence"))+
  scale_size_manual(values = c(4, 8), labels=c("ns", "â‰¤0.05")) +  # Set size range
  xlab("")+ylab("")+
  labs(
    x = "",
    y = "Effect Estimate",
    size = "p-value",
    color = "Variable") +
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 22, face = "bold"))
dev.off()










######### IPA heatmap for modified pathways ######### 

###### NYU Tumor rec vs no rec 

IPA_res <- read.csv(file = "IPA/NYU_IPA_tumor_rec_vs_no_rec_median_no_secon_prim_modified.csv")

#get max and min values 
max(IPA_res$NYU_Tumor_Old, na.rm = TRUE)
min(IPA_res$NYU_Tumor_Old, na.rm = TRUE)
max(IPA_res$NYU_Tumor_Young, na.rm = TRUE)
min(IPA_res$NYU_Tumor_Young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-0.378, 0, 4.914), c("blue", "white", "orange"))
col_fun(seq(-0.378, 0, 4.914))

#convert data to matrix 
IPA_res_mat <- IPA_res

IPA_res_mat <- IPA_res_mat %>% arrange(desc(NYU_Tumor_Old))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/NYU_IPA_tumor_rec_vs_no_rec_median_no_secon_prim_modified.pdf", height = 8, width = 14)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()


###### TCGA Tumor rec vs no rec 

IPA_res <- read.csv(file = "IPA/TCGA_IPA_tumor_rec_vs_no_Rec_age_70_modified_pathways_modified.csv")

#get max and min values 
max(IPA_res$TCGA_Tumor_Old, na.rm = TRUE)
min(IPA_res$TCGA_Tumor_Old, na.rm = TRUE)
max(IPA_res$TCGA_Tumor_Young, na.rm = TRUE)
min(IPA_res$TCGA_Tumor_Young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.064, 0, 4.123), c("blue", "white", "orange"))
col_fun(seq(-2.064, 0, 4.123))

#convert data to matrix 
IPA_res_mat <- IPA_res

IPA_res_mat <- IPA_res_mat %>% arrange(desc(TCGA_Tumor_Old))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/TCGA_IPA_tumor_rec_vs_no_Rec_age_70_modified_pathways_modified.pdf", height = 10, width = 14)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()


################# NYU lung

IPA_res <- read.csv(file = "IPA/IPA_comparison_NYU_early_lung_rec_vs_norec_age_no_second_prim_modified.csv")

#get max and min values 
max(IPA_res$NYU_Old_Lung, na.rm = TRUE)
min(IPA_res$NYU_Old_Lung, na.rm = TRUE)
max(IPA_res$NYU_Young_Lung, na.rm = TRUE)
min(IPA_res$NYU_Young_Lung, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-2.887, 0, 6.272), c("blue", "white", "orange"))
col_fun(seq(-2.887, 0, 6.272))

#convert data to matrix 
IPA_res_mat <- IPA_res

IPA_res_mat <- IPA_res_mat %>% arrange(desc(NYU_Old_Lung))

#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/IPA_comparison_NYU_early_lung_rec_vs_norec_age_no_second_prim_modified.pdf", height = 14, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()









############ repeat risk score using genes upregulated in old with recurrence tumor, no second_primary ###### 

##### geenes from tumor only 

#read counts 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)
#read upregulated genes genes list 
res <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_tumor_no_second_primary.csv")
#filter only sig ones and overalpping genes 
res <- res %>% filter(FDR<0.2, logFC>0)

#overall 524 genes 

###construct the score based on tumor samples expression levels 
#filter metadata to include recurrence events without second primary 
meta <- RNA.data %>% data.frame %>% filter(ProgType_Lab!="Secondary.Primary", Sample_Type_Involved=="Lung.Tissue.In")

counts <- mycounts[res$Gene.symbol,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in tumor subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

# Run elastic net model using 10k folds
## the inner CV regarding tuning parameters
folds.inner <- createFolds(meta$Progression, k = 10, list = FALSE)
RNA.training <- RA.tem
delta.training <- meta$Progression

library(glmnet)
tunings=NULL
for(alpha0 in (seq(0,20,1)/20)^2) {
  
  cvfit <- cv.glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family="binomial",
                     type.measure="auc", foldid=folds.inner, alpha=alpha0, keep=TRUE)
  tunings=rbind(tunings, cbind(rep(alpha0,length(cvfit$lambda)),cvfit$lambda,cvfit$cvm))
}  

colnames(tunings)=c("alpha", "lambda","cvm")
tunings=data.frame(tunings)
tunings=tunings[which.max(tunings$cvm),]

## the optimal model based on the training
fit <- glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family = "binomial",
              alpha=tunings$alpha,lambda =tunings$lambda)

#get coeficients 
lasso_selected_features <- coef(fit)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

#save results 
write.csv(selected_genes, file = "Results/RNA/genes_aging_risk_score_from_genes_DGE_in_old_rec_vs_no_rec_from_NYU_tumor_counts_no_second_prim.csv")

#calculate risk score: risk score is = Log[Coef * gene expression values (add 1 to normalization)]
gene_expression_subset <- mycounts[rownames(selected_genes),]
gene_expression_subset <- gene_expression_subset %>% select(starts_with("NYU"))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes
#transpose to calculate finall score for every patients
risk_scores_t <- t(risk_scores)
#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed) here using median as cutoff
RNA_data_tumor$risk_score_DGE_old_rec_no_rec_tumor <- final_risk_score
RNA_data_tumor$aging_signature_NYU_tumor_genes <- ifelse(RNA_data_tumor$risk_score_DGE_old_rec_no_rec_tumor > median(RNA_data_tumor$risk_score_DGE_old_rec_no_rec_tumor), "High", "Low")



# Plot 
#compare risk score among age groups 
pdf(file = "Figures/RNA/risk_score_NYU_tumor_old_DGE_rec_vs_no_rec_genes_age_3_grps_tumor.pdf", height = 8, width = 6)
ggplot(data = RNA_data_tumor, aes(x=age_3_grps, y=risk_score_DGE_old_rec_no_rec_tumor, color=age_3_grps))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "yellow2", "blue3"))+
  scale_x_discrete( labels=c("Young", "Middle", "Old"))+
  stat_compare_means(comparisons = list(c("middle", "young"), 
                                        c("middle", "old"), 
                                        c("young", "old")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()


#compare risk score between old and young according to median age 
RNA_data_tumor$age_grp <- factor(RNA_data_tumor$age_grp, levels = c("young", "old"))
pdf(file = "Figures/RNA/risk_score_NYU_tumor_old_DGE_rec_vs_no_rec_genes_age_70_tumor.pdf", height = 8, width = 6)
ggplot(data = RNA_data_tumor, aes(x=age_grp, y=risk_score_DGE_old_rec_no_rec_tumor, color=age_grp))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "blue3"))+
  scale_x_discrete( labels=c("Young", "Old"))+
  stat_compare_means(comparisons = list(c("old", "young")))+  
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()


#### repeat comparison between age_rec 

RNA_data_tumor <- RNA_data_tumor %>%
  mutate(age_rec = case_when(
    age_grp=="old" & Progression=="1" ~ "old_rec", 
    age_grp=="old" & Progression=="0" ~ "old_no_rec", 
    age_grp=="young" & Progression=="1" ~ "young_rec", 
    age_grp=="young" & Progression=="0" ~ "young_no_rec"))

#set levels 
RNA_data_tumor$age_rec <- factor(RNA_data_tumor$age_rec, levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

pdf(file = "Figures/RNA/risk_score_NYU_tumor_old_DGE_rec_vs_no_rec_genes_age_rec_tumor.pdf", height = 8, width = 10)
ggplot(data = RNA_data_tumor, aes(x=age_rec, y=risk_score_DGE_old_rec_no_rec_tumor, color=age_rec))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  stat_compare_means(comparisons = list(c("old_no_rec", "young_no_rec"), 
                                        c("old_rec", "young_rec")))+
  scale_color_manual(values = c("lightblue", "orange", "blue", "red"))+
  scale_x_discrete(breaks= c("young_no_rec", "old_no_rec", "young_rec", "old_rec"),
                   labels= c(glue("Young<br>No Recurrence"),
                             glue("Old<br>No Recurrence"),
                             glue("Young<br>Recurrence"),
                             glue("Old<br>Recurrence")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_markdown(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()




#compare progression across aging signature groups 
table_counts <- table(RNA_data_tumor$aging_signature_NYU_tumor_genes, RNA_data_tumor$Progression)

RNA_data_tumor$aging_signature_NYU_tumor_genes <- factor(RNA_data_tumor$aging_signature_NYU_tumor_genes, levels = c("Low", "High"))

pdf(file = "Figures/RNA/progression_aging_signature_risk_score_NYU_tumor_old_DGE_rec_vs_no_rec_genes_tumor.pdf", height = 8, width = 6)
ggplot(RNA_data_tumor, aes(x = aging_signature_NYU_tumor_genes, fill = Progression)) +
  geom_bar(position = "dodge")+
  scale_fill_manual(values = c("orange", "red"), labels=c("0"= "No Recurrence", "1"="Recurrence"))+
  theme_bw()+
  xlab("Aging Signature")+ylab("")+labs(fill="")+
  scale_x_discrete(labels=c("Low", "High"))+
  ggtitle("p_value of < 0.01")+
  theme(axis.text.x = element_text(size = 14, face = "bold", angle = 45, vjust = 0.5), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()

# Create a contingency table for the chi-squared test
contingency_table <- table(RNA_data_tumor$aging_signature_NYU_tumor_genes, RNA_data_tumor$Progression)

# Perform the chi-squared test
chi_squared_result <- chisq.test(contingency_table)

# Print the p-value from the chi-squared test
p_value <- chi_squared_result$p.value
cat("Chi-squared p-value:", p_value, "\n")

###### compare survival across aging signatures groups 
# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_NYU_tumor_genes, data = RNA_data_tumor)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = RNA_data_tumor,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Low", "High"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot


###### remove seondary primary and plot again 

RNA_data_analysis <- RNA_data_tumor %>% filter(ProgType_Lab!="Secondary.Primary")

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_analysis$New_TTP), event = as.numeric(RNA_data_analysis$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_NYU_tumor_genes, data = RNA_data_analysis)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = RNA_data_analysis,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Low", "High"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot


###### validate this signature in TCGA patients #########

#genes to use to develop the risk score 
selected_genes


tcga_counts_stage_I
tcga_metadata_stage_I


#calculate risk score: risk score is = Log[Coef * gene expression values (add 1 to normalization)]
gene_expression_subset <- tcga_counts_stage_I[rownames(selected_genes),]

#rermove any na
gene_expression_subset <- na.omit(gene_expression_subset)


e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes
#transpose to calculate finall score for every patients
risk_scores_t <- t(risk_scores)
#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed) here using median as cutoff
tcga_metadata_stage_I$risk_score_DGE_old_rec_no_rec_tumor <- final_risk_score
tcga_metadata_stage_I$aging_signature_NYU_tumor_genes <- ifelse(tcga_metadata_stage_I$risk_score_DGE_old_rec_no_rec_tumor > median(tcga_metadata_stage_I$risk_score_DGE_old_rec_no_rec_tumor), "High", "Low")

#remove any NA
tcga_metadata_stage_I <- tcga_metadata_stage_I %>% filter(!is.na(age_grp), !is.na(DFS_STATUS))

#filter data to include only patients 
TCGA_analysis_data <- tcga_metadata_stage_I %>% distinct(patient, .keep_all = TRUE)

# Plot 
#compare risk score among age groups 
pdf(file = "Figures/RNA/risk_score_NYU_tumor_old_DGE_rec_vs_no_rec_genes_age_3_grps_TCGA_validation.pdf", height = 8, width = 6)
ggplot(data = TCGA_analysis_data, aes(x=age_3_grps, y=risk_score_DGE_old_rec_no_rec_tumor, color=age_3_grps))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "yellow2", "blue3"))+
  scale_x_discrete( labels=c("Young", "Middle", "Old"))+
  stat_compare_means(comparisons = list(c("middle", "young"), 
                                        c("middle", "old"), 
                                        c("young", "old")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()


#compare risk score between old and young according to median age 
TCGA_analysis_data$age_grp_new <- factor(TCGA_analysis_data$age_grp_new, levels = c("less_equal_70", "greater_70"))
pdf(file = "Figures/RNA/risk_score_NYU_tumor_old_DGE_rec_vs_no_rec_genes_age_70_tumor_TCGA_valid.pdf", height = 8, width = 6)
ggplot(data = TCGA_analysis_data, aes(x=age_grp_new, y=risk_score_DGE_old_rec_no_rec_tumor, color=age_grp_new))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "blue3"))+
  scale_x_discrete( labels=c("Young", "Old"))+
  stat_compare_means(comparisons = list(c("less_equal_70", "greater_70")))+  
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()


#### repeat comparison between age_rec 

TCGA_analysis_data <- TCGA_analysis_data %>%
  mutate(age_rec = case_when(
    age_grp_new=="greater_70" & DFS_STATUS=="Recurrence" ~ "old_rec", 
    age_grp_new=="greater_70" & DFS_STATUS=="No.Recurrence" ~ "old_no_rec", 
    age_grp_new=="less_equal_70" & DFS_STATUS=="Recurrence" ~ "young_rec", 
    age_grp_new=="less_equal_70" & DFS_STATUS=="No.Recurrence" ~ "young_no_rec"))

#set levels 
TCGA_analysis_data$age_rec <- factor(TCGA_analysis_data$age_rec, levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

pdf(file = "Figures/RNA/risk_score_NYU_tumor_old_DGE_rec_vs_no_rec_genes_age_rec_tumor_TCGA_Valid.pdf", height = 8, width = 10)
ggplot(data = TCGA_analysis_data, aes(x=age_rec, y=risk_score_DGE_old_rec_no_rec_tumor, color=age_rec))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  stat_compare_means(comparisons = list(c("old_no_rec", "young_no_rec"), 
                                        c("old_rec", "young_rec")))+
  scale_color_manual(values = c("lightblue", "orange", "blue", "red"))+
  scale_x_discrete(breaks= c("young_no_rec", "old_no_rec", "young_rec", "old_rec"),
                   labels= c(glue("Young<br>No Recurrence"),
                             glue("Old<br>No Recurrence"),
                             glue("Young<br>Recurrence"),
                             glue("Old<br>Recurrence")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_markdown(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()




#compare progression across aging signature groups 
table_counts <- table(TCGA_analysis_data$aging_signature_NYU_tumor_genes, TCGA_analysis_data$DFS_STATUS)

TCGA_analysis_data$aging_signature_NYU_tumor_genes <- factor(TCGA_analysis_data$aging_signature_NYU_tumor_genes, levels = c("Low", "High"))

pdf(file = "Figures/RNA/progression_aging_signature_risk_score_NYU_tumor_old_DGE_rec_vs_no_rec_genes_tumor_TCGA_valid.pdf", height = 8, width = 6)
ggplot(TCGA_analysis_data, aes(x = aging_signature_NYU_tumor_genes, fill = DFS_STATUS)) +
  geom_bar(position = "dodge")+
  scale_fill_manual(values = c("orange", "red"), labels=c("No.Recurrence"= "No Recurrence", "Recurrence"="Recurrence"))+
  theme_bw()+
  xlab("Aging Signature")+ylab("")+labs(fill="")+
  scale_x_discrete(labels=c("Low", "High"))+
  ggtitle("p_value of 0.53")+
  theme(axis.text.x = element_text(size = 14, face = "bold", angle = 45, vjust = 0.5), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()

# Create a contingency table for the chi-squared test
contingency_table <- table(TCGA_analysis_data$aging_signature_NYU_tumor_genes, TCGA_analysis_data$DFS_STATUS)

# Perform the chi-squared test
chi_squared_result <- chisq.test(contingency_table)

# Print the p-value from the chi-squared test
p_value <- chi_squared_result$p.value
cat("Chi-squared p-value:", p_value, "\n")

###### compare survival across aging signatures groups 
# Load the necessary libraries
library(survival)
library(survminer)

TCGA_analysis_data$Progression <- ifelse(TCGA_analysis_data$DFS_STATUS =="Recurrence", "1", "0")
# Create a survival object
surv_obj <- Surv(time = as.numeric(TCGA_analysis_data$DFS_MONTHS), event = as.numeric(TCGA_analysis_data$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_NYU_tumor_genes, data = TCGA_analysis_data)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = TCGA_analysis_data,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Low", "High"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Months)",
  ylab = "Recurrence Probability",
)


survival.plot



######### repeat the above for lung tissue from NYU #############


#read counts 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)
#read upregulated genes genes list 
res <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_lung_no_second_primary.csv")
#filter only sig ones and overalpping genes 
res <- res %>% filter(FDR<0.2, logFC>0)

#overall 524 genes 

###construct the score based on lung samples expression levels 
#filter metadata to include recurrence events without second primary 
meta <- RNA.data %>% data.frame %>% filter(ProgType_Lab!="Secondary.Primary", Sample_Type_Involved=="Lung.Tissue.UnIn")

counts <- mycounts[res$Gene.symbol,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

# Run elastic net model using 10k folds
## the inner CV regarding tuning parameters
folds.inner <- createFolds(meta$Progression, k = 10, list = FALSE)
RNA.training <- RA.tem
delta.training <- meta$Progression

library(glmnet)
tunings=NULL
for(alpha0 in (seq(0,20,1)/20)^2) {
  
  cvfit <- cv.glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family="binomial",
                     type.measure="auc", foldid=folds.inner, alpha=alpha0, keep=TRUE)
  tunings=rbind(tunings, cbind(rep(alpha0,length(cvfit$lambda)),cvfit$lambda,cvfit$cvm))
}  

colnames(tunings)=c("alpha", "lambda","cvm")
tunings=data.frame(tunings)
tunings=tunings[which.max(tunings$cvm),]

## the optimal model based on the training
fit <- glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family = "binomial",
              alpha=tunings$alpha,lambda =tunings$lambda)

#get coeficients 
lasso_selected_features <- coef(fit)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

#save results 
write.csv(selected_genes, file = "Results/RNA/genes_aging_risk_score_from_genes_DGE_in_old_rec_vs_no_rec_from_NYU_lung_counts_no_second_prim.csv")

#calculate risk score: risk score is = Log[Coef * gene expression values (add 1 to normalization)]
gene_expression_subset <- mycounts[rownames(selected_genes),]
gene_expression_subset <- gene_expression_subset %>% select(-starts_with("NYU"))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes
#transpose to calculate finall score for every patients
risk_scores_t <- t(risk_scores)
#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed) here using median as cutoff
RNA_data_lung$risk_score_DGE_old_rec_no_rec_lung <- final_risk_score
RNA_data_lung$aging_signature_NYU_lung_genes <- ifelse(RNA_data_lung$risk_score_DGE_old_rec_no_rec_lung > median(RNA_data_lung$risk_score_DGE_old_rec_no_rec_lung), "High", "Low")



# Plot 
#compare risk score among age groups 
pdf(file = "Figures/RNA/risk_score_NYU_lung_old_DGE_rec_vs_no_rec_genes_age_3_grps_lung.pdf", height = 8, width = 6)
ggplot(data = RNA_data_lung, aes(x=age_3_grps, y=risk_score_DGE_old_rec_no_rec_lung, color=age_3_grps))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "yellow2", "blue3"))+
  scale_x_discrete( labels=c("Young", "Middle", "Old"))+
  stat_compare_means(comparisons = list(c("middle", "young"), 
                                        c("middle", "old"), 
                                        c("young", "old")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()


#compare risk score between old and young according to median age 
RNA_data_lung$age_grp <- factor(RNA_data_lung$age_grp, levels = c("young", "old"))
pdf(file = "Figures/RNA/risk_score_NYU_lung_old_DGE_rec_vs_no_rec_genes_age_70_lung.pdf", height = 8, width = 6)
ggplot(data = RNA_data_lung, aes(x=age_grp, y=risk_score_DGE_old_rec_no_rec_lung, color=age_grp))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "blue3"))+
  scale_x_discrete( labels=c("Young", "Old"))+
  stat_compare_means(comparisons = list(c("old", "young")))+  
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()


#### repeat comparison between age_rec 

RNA_data_lung <- RNA_data_lung %>%
  mutate(age_rec = case_when(
    age_grp=="old" & Progression=="1" ~ "old_rec", 
    age_grp=="old" & Progression=="0" ~ "old_no_rec", 
    age_grp=="young" & Progression=="1" ~ "young_rec", 
    age_grp=="young" & Progression=="0" ~ "young_no_rec"))

#set levels 
RNA_data_lung$age_rec <- factor(RNA_data_lung$age_rec, levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

pdf(file = "Figures/RNA/risk_score_NYU_lung_old_DGE_rec_vs_no_rec_genes_age_rec_lung.pdf", height = 8, width = 10)
ggplot(data = RNA_data_lung, aes(x=age_rec, y=risk_score_DGE_old_rec_no_rec_lung, color=age_rec))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  stat_compare_means(comparisons = list(c("old_no_rec", "young_no_rec"), 
                                        c("old_rec", "young_rec")))+
  scale_color_manual(values = c("lightblue", "orange", "blue", "red"))+
  scale_x_discrete(breaks= c("young_no_rec", "old_no_rec", "young_rec", "old_rec"),
                   labels= c(glue("Young<br>No Recurrence"),
                             glue("Old<br>No Recurrence"),
                             glue("Young<br>Recurrence"),
                             glue("Old<br>Recurrence")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_markdown(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()




#compare progression across aging signature groups 
table_counts <- table(RNA_data_lung$aging_signature_NYU_lung_genes, RNA_data_lung$Progression)

RNA_data_lung$aging_signature_NYU_lung_genes <- factor(RNA_data_lung$aging_signature_NYU_lung_genes, levels = c("Low", "High"))

pdf(file = "Figures/RNA/progression_aging_signature_risk_score_NYU_lung_old_DGE_rec_vs_no_rec_genes_lung.pdf", height = 8, width = 6)
ggplot(RNA_data_lung, aes(x = aging_signature_NYU_lung_genes, fill = Progression)) +
  geom_bar(position = "dodge")+
  scale_fill_manual(values = c("orange", "red"), labels=c("0"= "No Recurrence", "1"="Recurrence"))+
  theme_bw()+
  xlab("Aging Signature")+ylab("")+labs(fill="")+
  scale_x_discrete(labels=c("Low", "High"))+
  ggtitle("p_value of < 0.01")+
  theme(axis.text.x = element_text(size = 14, face = "bold", angle = 45, vjust = 0.5), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()

# Create a contingency table for the chi-squared test
contingency_table <- table(RNA_data_lung$aging_signature_NYU_lung_genes, RNA_data_lung$Progression)

# Perform the chi-squared test
chi_squared_result <- chisq.test(contingency_table)

# Print the p-value from the chi-squared test
p_value <- chi_squared_result$p.value
cat("Chi-squared p-value:", p_value, "\n")

###### compare survival across aging signatures groups 
# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_lung$New_TTP), event = as.numeric(RNA_data_lung$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_NYU_lung_genes, data = RNA_data_lung)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = RNA_data_lung,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Low", "High"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot


###### remove seondary primary and plot again 

RNA_data_analysis <- RNA_data_lung %>% filter(ProgType_Lab!="Secondary.Primary")

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_analysis$New_TTP), event = as.numeric(RNA_data_analysis$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_NYU_lung_genes, data = RNA_data_analysis)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = RNA_data_analysis,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Low", "High"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot


###### validate this signature in TCGA patients #########

#genes to use to develop the risk score 
selected_genes


tcga_counts_stage_I
tcga_metadata_stage_I


#calculate risk score: risk score is = Log[Coef * gene expression values (add 1 to normalization)]
gene_expression_subset <- tcga_counts_stage_I[rownames(selected_genes),]

#rermove any na
gene_expression_subset <- na.omit(gene_expression_subset)


e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes
#transpose to calculate finall score for every patients
risk_scores_t <- t(risk_scores)
#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed) here using median as cutoff
tcga_metadata_stage_I$risk_score_DGE_old_rec_no_rec_lung <- final_risk_score
tcga_metadata_stage_I$aging_signature_NYU_lung_genes <- ifelse(tcga_metadata_stage_I$risk_score_DGE_old_rec_no_rec_lung > median(tcga_metadata_stage_I$risk_score_DGE_old_rec_no_rec_lung), "High", "Low")

#remove any NA
TCGA_analysis_data <- tcga_metadata_stage_I %>% filter(!is.na(age_grp), !is.na(DFS_STATUS))

#filter data to include only patients 
TCGA_analysis_data <- TCGA_analysis_data %>% distinct(patient, .keep_all = TRUE)

# Plot 
#compare risk score among age groups 
pdf(file = "Figures/RNA/risk_score_NYU_lung_old_DGE_rec_vs_no_rec_genes_age_3_grps_TCGA_validation.pdf", height = 8, width = 6)
ggplot(data = TCGA_analysis_data, aes(x=age_3_grps, y=risk_score_DGE_old_rec_no_rec_lung, color=age_3_grps))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "yellow2", "blue3"))+
  scale_x_discrete( labels=c("Young", "Middle", "Old"))+
  stat_compare_means(comparisons = list(c("middle", "young"), 
                                        c("middle", "old"), 
                                        c("young", "old")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()


#compare risk score between old and young according to median age 
TCGA_analysis_data$age_grp_new <- factor(TCGA_analysis_data$age_grp_new, levels = c("less_equal_70", "greater_70"))
pdf(file = "Figures/RNA/risk_score_NYU_lung_old_DGE_rec_vs_no_rec_genes_age_70_lung_TCGA_valid.pdf", height = 8, width = 6)
ggplot(data = TCGA_analysis_data, aes(x=age_grp_new, y=risk_score_DGE_old_rec_no_rec_lung, color=age_grp_new))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  scale_color_manual(values = c("green4", "blue3"))+
  scale_x_discrete( labels=c("Young", "Old"))+
  stat_compare_means(comparisons = list(c("less_equal_70", "greater_70")))+  
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()


#### repeat comparison between age_rec 

TCGA_analysis_data <- TCGA_analysis_data %>%
  mutate(age_rec = case_when(
    age_grp_new=="greater_70" & DFS_STATUS=="Recurrence" ~ "old_rec", 
    age_grp_new=="greater_70" & DFS_STATUS=="No.Recurrence" ~ "old_no_rec", 
    age_grp_new=="less_equal_70" & DFS_STATUS=="Recurrence" ~ "young_rec", 
    age_grp_new=="less_equal_70" & DFS_STATUS=="No.Recurrence" ~ "young_no_rec"))

#set levels 
TCGA_analysis_data$age_rec <- factor(TCGA_analysis_data$age_rec, levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

pdf(file = "Figures/RNA/risk_score_NYU_lung_old_DGE_rec_vs_no_rec_genes_age_rec_lung_TCGA_Valid.pdf", height = 8, width = 10)
ggplot(data = TCGA_analysis_data, aes(x=age_rec, y=risk_score_DGE_old_rec_no_rec_lung, color=age_rec))+
  geom_boxplot()+
  geom_jitter(color="black", alpha=0.7)+
  stat_compare_means(comparisons = list(c("old_no_rec", "young_no_rec"), 
                                        c("old_rec", "young_rec")))+
  scale_color_manual(values = c("lightblue", "orange", "blue", "red"))+
  scale_x_discrete(breaks= c("young_no_rec", "old_no_rec", "young_rec", "old_rec"),
                   labels= c(glue("Young<br>No Recurrence"),
                             glue("Old<br>No Recurrence"),
                             glue("Young<br>Recurrence"),
                             glue("Old<br>Recurrence")))+
  xlab("")+
  ylab("Aging Risk Score")+
  theme_bw()+
  theme(axis.text.x = element_markdown(size = 20, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"))+
  guides(color="none")
dev.off()




#compare progression across aging signature groups 
table_counts <- table(TCGA_analysis_data$aging_signature_NYU_lung_genes, TCGA_analysis_data$DFS_STATUS)

TCGA_analysis_data$aging_signature_NYU_lung_genes <- factor(TCGA_analysis_data$aging_signature_NYU_lung_genes, levels = c("Low", "High"))

pdf(file = "Figures/RNA/progression_aging_signature_risk_score_NYU_lung_old_DGE_rec_vs_no_rec_genes_lung_TCGA_valid.pdf", height = 8, width = 6)
ggplot(TCGA_analysis_data, aes(x = aging_signature_NYU_lung_genes, fill = DFS_STATUS)) +
  geom_bar(position = "dodge")+
  scale_fill_manual(values = c("orange", "red"), labels=c("No.Recurrence"= "No Recurrence", "Recurrence"="Recurrence"))+
  theme_bw()+
  xlab("Aging Signature")+ylab("")+labs(fill="")+
  scale_x_discrete(labels=c("Low", "High"))+
  ggtitle("p_value of 0.11")+
  theme(axis.text.x = element_text(size = 14, face = "bold", angle = 45, vjust = 0.5), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        axis.title.y = element_text(size = 20, face = "bold"), 
        axis.title.x = element_text(size = 20, face = "bold"), 
        legend.position = "top")
dev.off()

# Create a contingency table for the chi-squared test
contingency_table <- table(TCGA_analysis_data$aging_signature_NYU_lung_genes, TCGA_analysis_data$DFS_STATUS)

# Perform the chi-squared test
chi_squared_result <- chisq.test(contingency_table)

# Print the p-value from the chi-squared test
p_value <- chi_squared_result$p.value
cat("Chi-squared p-value:", p_value, "\n")

###### compare survival across aging signatures groups 
# Load the necessary libraries
library(survival)
library(survminer)

TCGA_analysis_data$Progression <- ifelse(TCGA_analysis_data$DFS_STATUS =="Recurrence", "1", "0")
# Create a survival object
surv_obj <- Surv(time = as.numeric(TCGA_analysis_data$DFS_MONTHS), event = as.numeric(TCGA_analysis_data$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ aging_signature_NYU_lung_genes, data = TCGA_analysis_data)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = TCGA_analysis_data,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Low", "High"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Months)",
  ylab = "Recurrence Probability",
)


survival.plot














######### Aging score using genes upregulated in old - tumor subset #############


##### geenes from tumor only 

#read counts 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)
#read upregulated genes genes list 
res1 <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_lung_no_second_primary.csv")
res2 <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_tumor_no_second_primary.csv")
res3 <- read.csv(file = "Results/RNA/edgeR.results_age_grp_tumor_no_second_primary.csv")
res4 <- read.csv(file = "Results/RNA/edgeR.results_age_grp_lung_no_second_primary.csv")

res1 <- res1 %>% filter(FDR <= 0.05)
res2 <- res2 %>% filter(FDR <= 0.05)
res3 <- res3 %>% filter(FDR <= 0.05)
res4 <- res4 %>% filter(FDR <= 0.05)

res <- inner_join(res3, res4, by="Gene.symbol")

###construct the score based on lung samples expression levels 
#filter metadata to include recurrence events without second primary 
meta <- RNA.data %>% data.frame %>% filter(ProgType_Lab!="Secondary.Primary", Sample_Type_Involved=="Lung.Tissue.In")

counts <- mycounts[res$Gene.symbol,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

# Run elastic net model using 10k folds
## the inner CV regarding tuning parameters
folds.inner <- createFolds(meta$Progression, k = 10, list = FALSE)
RNA.training <- RA.tem
RNA.training <- na.omit(RNA.training)
delta.training <- meta$Progression

library(glmnet)
tunings=NULL
for(alpha0 in (seq(0,20,1)/20)^2) {
  
  cvfit <- cv.glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family="binomial",
                     type.measure="auc", foldid=folds.inner, alpha=alpha0, keep=TRUE)
  tunings=rbind(tunings, cbind(rep(alpha0,length(cvfit$lambda)),cvfit$lambda,cvfit$cvm))
}  

colnames(tunings)=c("alpha", "lambda","cvm")
tunings=data.frame(tunings)
tunings=tunings[which.max(tunings$cvm),]

## the optimal model based on the training
fit <- glmnet(x=as.matrix(t(RNA.training)), y=delta.training, family = "binomial",
              alpha=tunings$alpha,lambda =tunings$lambda)

#get coeficients 
lasso_selected_features <- coef(fit)
lasso_selected_features <- lasso_selected_features[-1,]
# Identify genes with non-zero coefficients
selected_genes <- lasso_selected_features[lasso_selected_features != 0]

# Now, 'selected_genes' contains the genes associated with age and progression
selected_genes <- data.frame(selected_genes)

selected_genes
write.csv(file = "selected_genes_test.csv")
#save results 
#write.csv(selected_genes, file = "Results/RNA/genes_aging_risk_score_from_genes_DGE_in_old_rec_vs_no_rec_from_NYU_lung_counts_no_second_prim.csv")

#calculate risk score: risk score is = Log[Coef * gene expression values (add 1 to normalization)]
gene_expression_subset <- mycounts[rownames(selected_genes),]
gene_expression_subset <- gene_expression_subset %>% select(starts_with("NYU"))

e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes
#transpose to calculate finall score for every patients
risk_scores_t <- t(risk_scores)
#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed) here using median as cutoff
RNA_data_tumor$risk_score_test <- final_risk_score
RNA_data_tumor$risk_group_test <- ifelse(RNA_data_tumor$risk_score_test > median(RNA_data_tumor$risk_score_test), "High", "Low")




###### compare survival across aging signatures groups 
# Load the necessary libraries
library(survival)
library(survminer)

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_tumor$New_TTP), event = as.numeric(RNA_data_tumor$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ risk_group_test, data = RNA_data_tumor)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = RNA_data_tumor,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Low", "High"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot


###### remove seondary primary and plot again 

RNA_data_analysis <- RNA_data_tumor %>% filter(ProgType_Lab!="Secondary.Primary")

# Create a survival object
surv_obj <- Surv(time = as.numeric(RNA_data_analysis$New_TTP), event = as.numeric(RNA_data_analysis$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ risk_group_test, data = RNA_data_analysis)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = RNA_data_analysis,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Low", "High"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Days)",
  ylab = "Recurrence Probability",
)


survival.plot


###### validate this signature in TCGA patients #########

#genes to use to develop the risk score 
selected_genes


#calculate risk score: risk score is = Log[Coef * gene expression values (add 1 to normalization)]
gene_expression_subset <- tcga_counts_stage_I[rownames(selected_genes),]

#rermove any na
gene_expression_subset <- na.omit(gene_expression_subset)


e <- log2(gene_expression_subset+1)

#build individual risk score for every patient and every gene 
risk_scores <- e * selected_genes$selected_genes
#transpose to calculate finall score for every patients
risk_scores_t <- t(risk_scores)
#to get fianl risk score of all genes 
final_risk_score <- rowSums(risk_scores_t, na.rm = TRUE)

# Classify patients based on the risk score (adjust the threshold as needed) here using median as cutoff
tcga_metadata_stage_I$risk_score_test <- final_risk_score
tcga_metadata_stage_I$risk_group_test <- ifelse(tcga_metadata_stage_I$risk_score_test > median(tcga_metadata_stage_I$risk_score_test), "High", "Low")

#remove any NA
TCGA_analysis_data <- tcga_metadata_stage_I %>% filter(!is.na(age_grp), !is.na(DFS_STATUS))

#filter data to include only patients 
TCGA_analysis_data <- TCGA_analysis_data %>% distinct(patient, .keep_all = TRUE)

###### compare survival across aging signatures groups 
# Load the necessary libraries
library(survival)
library(survminer)

TCGA_analysis_data$Progression <- ifelse(TCGA_analysis_data$DFS_STATUS =="Recurrence", "1", "0")
TCGA_analysis_data$DFS_days <- as.numeric(TCGA_analysis_data$DFS_MONTHS) * 30.4167
# Create a survival object
surv_obj <- Surv(time = as.numeric(TCGA_analysis_data$DFS_days), event = as.numeric(TCGA_analysis_data$Progression))  # Make sure to adjust column names accordingly

# Create a Kaplan-Meier survival curve
surv_fit <- survfit(surv_obj ~ risk_group_test, data = TCGA_analysis_data)

# Plot the Kaplan-Meier curve
survival.plot <- ggsurvplot(
  surv_fit,
  data = TCGA_analysis_data,
  conf.int=TRUE, pval=TRUE, risk.table=TRUE, 
  fun = "pct", ggtheme = theme_pubr(), 
  palette=c("dodgerblue3", "goldenrod2"), size=1,
  legend.labs=c("Low", "High"), legend.title="Aging Signature",  
  # tables.col = "strata", #color of numbers inside risk table
  tables.height = 0.15,
  fontsize = 4,
  risk.table.y.text.col = T,
  cumcensor = TRUE, 
  tables.theme = theme_cleantable(),
  # risk.table.y.text = FALSE,
  risk.table.title = "Number at risk (cumulative number of recurrence)",
  cumcensor.title = "Cumulative number of censored subjects",
  #labs
  title="Kaplan-Meier Curve for Recurrence According to Aging Signature",
  xlab = "Time (Months)",
  ylab = "Recurrence Probability",
)


survival.plot























################# data for Sunil group ##### 

#get metadata of NYU cohort without second primary, using age cutoff of 70
NYU_stage_I_meta <- RNA.data %>% data.frame() %>% select(-c(age_3_grps, aging_signature, aging_signature_elastic)) %>% filter(ProgType_Lab!="Secondary.Primary")

#export 
write.csv(NYU_stage_I_meta, file ="data_export/NYU_stage_I_LUAD_meta_no_2nd_prim.csv")

#get counts and validate they match all samples 
mycounts <-read.delim2("Data/NovaSeq_Raw_Counts_Gene_Symbols.txt", sep="\t", row.names=1)
colnames(mycounts) <- gsub("X", "", colnames(mycounts))

NYU_stage_I_counts <- mycounts %>% select(rownames(NYU_stage_I_meta))

#export 
write.table(NYU_stage_I_counts, file = "data_export/NYU_stage_I_LUAD_counts_no_2nd_prim.txt", row.names = TRUE, sep = "\t")


#TCGA cohort metadata
tcga_metadata_stage_I_for_sunil <- tcga_metadata_stage_I_no_NA %>% select(-c( primary_site, disease_type, treatments))
tcga_counts_stage_I_no_NA


write.csv(tcga_metadata_stage_I_for_sunil, file ="data_export/TCGA_meta_stage_I_LUAD.csv")
write.table(tcga_counts_stage_I_no_NA, file = "data_export/TCGA_counts_stage_I_LUAD.txt", row.names = TRUE, sep = "\t")














######### correlation of upregualteed transcripts from Greg with age and outcome ####

#read list of transcripts 
transc_list <- read.csv(file = "Trasncripts_upregualted_in_senescent_lungcells.csv")

transc_list <- transc_list %>% select(SASP_factors, Upregulated_in_senescent_cells)

SASP_factors <- transc_list$SASP_factors

transc_up_senscent <- transc_list$Upregulated_in_senescent_cells
transc_up_senscent <- transc_up_senscent[1:16]

#check in NYU cohort of patients without second primary 
temp <- RNA.data %>% data.frame() %>% filter(ProgType_Lab!="Secondary.Primary")

temp_count <- mycounts[,rownames(temp)]

transc <- temp_count[SASP_factors,]



######check correlation and association with age in tumor samples of SASP FACTORS #######

transc_tumor <- transc %>% select(starts_with("NYU")) %>% t(.) %>% data.frame()
transc_lung <- transc %>% select(-starts_with("NYU")) %>% t(.) %>% data.frame()

#get necessary data from metadata 
temp_data <- RNA.data %>% data.frame() %>% filter(Sample_Type_Involved=="Lung.Tissue.In",ProgType_Lab!="Secondary.Primary" ) %>% select(age_grp, age_3_grps, Progression, Age)

transc_tumor$Age <- temp_data$Age
transc_tumor$age_grp <- temp_data$age_grp
transc_tumor$age_3_grps <- temp_data$age_3_grps
transc_tumor$Progression <- temp_data$Progression
transc_tumor <- transc_tumor %>% mutate(age_rec = case_when(
  age_grp=="greater_70" & Progression=="1" ~ "old_rec", 
  age_grp=="greater_70" & Progression=="0" ~ "old_no_rec", 
  age_grp=="less_equal_70" & Progression=="1" ~ "young_rec", 
  age_grp=="less_equal_70" & Progression=="0" ~ "young_no_rec", 
))

#check correlation 

plot_data <- transc_tumor
#creating a variable to loop over 
genes <- colnames(plot_data)
genes <- genes[1:33]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec","young_rec", "old_no_rec",  "old_rec"))
plot_data$age_grp <- factor(plot_data$age_grp, 
                            levels = c("less_equal_70", "greater_70"))

plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$Age, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    theme_bw()+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "top")+
    facet_grid(. ~ Progression)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("greg_transc/NYU/Tumor/correlation_plots/", paste0(i, paste0("correlation"), paste0("_with_age_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/NYU/Tumor/", paste0("SASP_factors_combined", paste0("correlation"), paste0("_with_age_tumor"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 5)  # Adjust ncol based on your desired layout
dev.off()


#### boxplots of age_grp 
plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_grp, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_grp))+
    stat_compare_means(comparisons = list(c("greater_70", "less_equal_70")))+
    scale_color_manual(values = c("green4", "blue3"))+
    scale_x_discrete(labels=c("Young", "Old"))+
    theme_classic()+
    xlab("")+
    #ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/NYU/Tumor/boxplots/age_grp/", paste0(i, paste0("_boxplot"), paste0("_with_age_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/NYU/Tumor/", paste0("SASP_factors_combined", paste0("_boxplot"), paste0("_with_age_tumor"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 5)  # Adjust ncol based on your desired layout
dev.off()



####boxplots of age_rec 
plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("lightblue",  "blue","orange", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/NYU/Tumor/boxplots/age_rec/", paste0(i, paste0("_boxplot"), paste0("_with_age_rec_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/NYU/Tumor/", paste0("SASP_factors_combined", paste0("_boxplot"), paste0("_with_age_rec_tumor"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 36, width = 40)
grid.arrange(grobs = plot_list, ncol = 6)  # Adjust ncol based on your desired layout
dev.off()








#repeat for lung data 
#get necessary data from metadata 
temp_data <- RNA.data %>% data.frame() %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn", ProgType_Lab!="Secondary.Primary" ) %>% select(age_grp, age_3_grps, Progression, Age)

transc_lung$Age <- temp_data$Age
transc_lung$age_grp <- temp_data$age_grp
transc_lung$age_3_grps <- temp_data$age_3_grps
transc_lung$Progression <- temp_data$Progression
transc_lung <- transc_lung %>% mutate(age_rec = case_when(
  age_grp=="greater_70" & Progression=="1" ~ "old_rec", 
  age_grp=="greater_70" & Progression=="0" ~ "old_no_rec", 
  age_grp=="less_equal_70" & Progression=="1" ~ "young_rec", 
  age_grp=="less_equal_70" & Progression=="0" ~ "young_no_rec", 
))

#check correlation 

plot_data <- transc_lung
#creating a variable to loop over 
genes <- colnames(plot_data)
genes <- genes[1:33]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec","young_rec", "old_no_rec",  "old_rec"))
plot_data$age_grp <- factor(plot_data$age_grp, 
                            levels = c("less_equal_70", "greater_70"))

plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$Age, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    theme_bw()+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "top")+
    facet_grid(. ~ Progression)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("greg_transc/NYU/Lung/correlation_plots/", paste0(i, paste0("correlation"), paste0("_with_age_Lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/NYU/Lung/", paste0("SASP_factors_combined", paste0("correlation"), paste0("_with_age_Lung"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 5)  # Adjust ncol based on your desired layout
dev.off()



#### boxplots of age_grp 
plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_grp, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_grp))+
    stat_compare_means(comparisons = list(c("greater_70", "less_equal_70")))+
    scale_color_manual(values = c("green4", "blue3"))+
    scale_x_discrete(labels=c("Young", "Old"))+
    theme_classic()+
    #ggtitle(i)+
    xlab("")+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/NYU/Lung/boxplots/age_grp/", paste0(i, paste0("_boxplot"), paste0("_with_age_Lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()

  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/NYU/Lung/", paste0("SASP_factors_combined", paste0("_boxplot"), paste0("_with_age_Lung"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 5)  # Adjust ncol based on your desired layout
dev.off()



####boxplots of age_rec 
plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("skyblue",  "darkblue", "orangered", "darkred"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/NYU/Lung/boxplots/age_rec/", paste0(i, paste0("_boxplot"), paste0("_with_age_rec_Lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/NYU/Lung/", paste0("SASP_factors_combined", paste0("_boxplot"), paste0("_with_age_rec_Lung"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 36, width = 40)
grid.arrange(grobs = plot_list, ncol = 6)  # Adjust ncol based on your desired layout
dev.off()




########### NYU: analyiss for upregulated transcripts in senescent cells ########

#check in NYU cohort 
#check in NYU cohort of patients without second primary 
temp <- RNA.data %>% data.frame() %>% filter(ProgType_Lab!="Secondary.Primary")

temp_count <- mycounts[,rownames(temp)]

transc <- temp_count[transc_up_senscent,]

transc <- na.omit(transc)



######check correlation and association with age in tumor samples of upregulated transcripts in senescent cells #######

transc_tumor <- transc %>% select(starts_with("NYU")) %>% t(.) %>% data.frame()
transc_lung <- transc %>% select(-starts_with("NYU")) %>% t(.) %>% data.frame()

#get necessary data from metadata 
temp_data <- RNA.data %>% data.frame() %>% filter(Sample_Type_Involved=="Lung.Tissue.In", ProgType_Lab!="Secondary.Primary") %>% select(age_grp, age_3_grps, Progression, Age)

transc_tumor$Age <- temp_data$Age
transc_tumor$age_grp <- temp_data$age_grp
transc_tumor$age_3_grps <- temp_data$age_3_grps
transc_tumor$Progression <- temp_data$Progression
transc_tumor <- transc_tumor %>% mutate(age_rec = case_when(
  age_grp=="greater_70" & Progression=="1" ~ "old_rec", 
  age_grp=="greater_70" & Progression=="0" ~ "old_no_rec", 
  age_grp=="less_equal_70" & Progression=="1" ~ "young_rec", 
  age_grp=="less_equal_70" & Progression=="0" ~ "young_no_rec", 
))

#check correlation 

plot_data <- transc_tumor
#creating a variable to loop over 
genes <- colnames(plot_data)
genes <- genes[1:15]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec","young_rec", "old_no_rec",  "old_rec"))
plot_data$age_grp <- factor(plot_data$age_grp, 
                            levels = c("less_equal_70", "greater_70"))


plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$Age, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    theme_bw()+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "top")+
    facet_grid(. ~ Progression)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("greg_transc/NYU/Tumor/upreg_transc/correlation_plots/", paste0(i, paste0("correlation"), paste0("_with_age_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/NYU/Tumor/upreg_transc/", paste0("upregu_transc_combined", paste0("correlation"), paste0("_with_age_tumor"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 3)  # Adjust ncol based on your desired layout
dev.off()



#### boxplots of age_grp 
plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_grp, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_grp))+
    stat_compare_means(comparisons = list(c("greater_70", "less_equal_70")))+
    scale_color_manual(values = c("green4", "blue3"))+
    scale_x_discrete(labels=c("Young", "Old"))+
    theme_classic()+
    ggtitle(i)+
    xlab("")+ylab("")+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/NYU/Tumor/upreg_transc/age_grp/", paste0(i, paste0("_boxplot"), paste0("_with_age_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/NYU/Tumor/upreg_transc/", paste0("upregu_transc_combined", paste0("_boxplot"), paste0("_with_age_tumor"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 3)  # Adjust ncol based on your desired layout
dev.off()



####boxplots of age_rec 
plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("lightblue",  "blue","orange", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/NYU/Tumor/upreg_transc/age_rec/", paste0(i, paste0("_boxplot"), paste0("_with_age_rec_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/NYU/Tumor/upreg_transc/", paste0("upregu_transc_combined", paste0("_boxplot"), paste0("_with_age_rec_tumor"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 3)  # Adjust ncol based on your desired layout
dev.off()









#repeat for lung data 
#get necessary data from metadata 
temp_data <- RNA.data %>% data.frame() %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn", ProgType_Lab!="Secondary.Primary") %>% select(age_grp, age_3_grps, Progression, Age)

transc_lung$Age <- temp_data$Age
transc_lung$age_grp <- temp_data$age_grp
transc_lung$age_3_grps <- temp_data$age_3_grps
transc_lung$Progression <- temp_data$Progression
transc_lung <- transc_lung %>% mutate(age_rec = case_when(
  age_grp=="greater_70" & Progression=="1" ~ "old_rec", 
  age_grp=="greater_70" & Progression=="0" ~ "old_no_rec", 
  age_grp=="less_equal_70" & Progression=="1" ~ "young_rec", 
  age_grp=="less_equal_70" & Progression=="0" ~ "young_no_rec", 
))

#check correlation 

plot_data <- transc_lung
#creating a variable to loop over 
genes <- colnames(plot_data)
genes <- genes[1:15]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec","young_rec", "old_no_rec",  "old_rec"))
plot_data$age_grp <- factor(plot_data$age_grp, 
                            levels = c("less_equal_70", "greater_70"))

plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$Age, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    theme_bw()+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "top")+
    facet_grid(. ~ Progression)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("greg_transc/NYU/Lung/upreg_transc/correlation_plots/", paste0(i, paste0("correlation"), paste0("_with_age_Lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/NYU/Lung/upreg_transc/", paste0("upregu_transc_combined", paste0("correlation"), paste0("_with_age_Lung"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 3)  # Adjust ncol based on your desired layout
dev.off()




#### boxplots of age_grp 
plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_grp, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_grp))+
    stat_compare_means(comparisons = list(c("greater_70", "less_equal_70")))+
    scale_color_manual(values = c("green4", "blue3"))+
    scale_x_discrete(labels=c("Young", "Old"))+
    theme_classic()+
    ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/NYU/Lung/upreg_transc/age_grp/", paste0(i, paste0("_boxplot"), paste0("_with_age_Lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/NYU/Lung/upreg_transc/", paste0("upregu_transc_combined", paste0("_boxplot"), paste0("_with_age_Lung"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 3)  # Adjust ncol based on your desired layout
dev.off()



####boxplots of age_rec 
plot_list <- list()


for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("skyblue",  "darkblue", "orangered", "darkred"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/NYU/Lung/upreg_transc/age_rec/", paste0(i, paste0("_boxplot"), paste0("_with_age_rec_Lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/NYU/Lung/upreg_transc/", paste0("upregu_transc_combined", paste0("_boxplot"), paste0("_with_age_rec_Lung"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 3)  # Adjust ncol based on your desired layout
dev.off()







############## greg data in TCGA ###########
#check in TCGA cohort 

#counts
tcga_counts_stage_I_no_NA
#metadata
tcga_metadata_stage_I_no_NA

transc <- tcga_counts_stage_I_no_NA[SASP_factors,]

tumor_samples <- tcga_metadata_stage_I_no_NA %>% filter(shortLetterCode=="TP")
lung_samples <- tcga_metadata_stage_I_no_NA %>% filter(shortLetterCode=="NT")



######check correlation and association with age in tumor samples of SASP FACTORS #######

transc_tumor <- transc %>% select(rownames(tumor_samples)) %>% t(.) %>% data.frame()
transc_lung <- transc %>% select(rownames(lung_samples)) %>% t(.) %>% data.frame()

#get necessary data from metadata 
temp_data <- tumor_samples %>% select(age_grp_new, DFS_STATUS, age_at_index)

transc_tumor$age_at_index <- temp_data$age_at_index
transc_tumor$age_grp_new <- temp_data$age_grp_new
transc_tumor$DFS_STATUS <- temp_data$DFS_STATUS
transc_tumor <- transc_tumor %>% mutate(age_rec = case_when(
  age_grp_new=="greater_70" & DFS_STATUS=="Recurrence" ~ "old_rec", 
  age_grp_new=="greater_70" & DFS_STATUS=="No.Recurrence" ~ "old_no_rec", 
  age_grp_new=="less_equal_70" & DFS_STATUS=="Recurrence" ~ "young_rec", 
  age_grp_new=="less_equal_70" & DFS_STATUS=="No.Recurrence" ~ "young_no_rec", 
))

#check correlation 

plot_data <- transc_tumor
#creating a variable to loop over 
genes <- colnames(plot_data)
genes <- genes[1:33]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec","young_rec", "old_no_rec",  "old_rec"))
plot_data$age_grp_new <- factor(plot_data$age_grp_new, 
                            levels = c("less_equal_70", "greater_70"))


plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_at_index, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    theme_bw()+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "top")+
    facet_grid(. ~ DFS_STATUS)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("greg_transc/TCGA/Tumor/correlation_plots/", paste0(i, paste0("correlation"), paste0("_with_age_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/TCGA/Tumor/", paste0("SASP_factors_combined", paste0("_correlation"), paste0("_with_age_tumor"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 5)  # Adjust ncol based on your desired layout
dev.off()



#### boxplots of age_grp 
plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_grp_new, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_grp_new))+
    stat_compare_means(comparisons = list(c("greater_70", "less_equal_70")))+
    scale_color_manual(values = c("green4", "blue3"))+
    scale_x_discrete(labels=c("Young", "Old"))+
    theme_classic()+
    ggtitle(i)+
    xlab("")+ylab("")+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/TCGA/Tumor/boxplots/age_grp/", paste0(i, paste0("_boxplot"), paste0("_with_age_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/TCGA/Tumor/", paste0("SASP_factors_combined", paste0("_boxplot"), paste0("_with_age_tumor"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 5)  # Adjust ncol based on your desired layout
dev.off()



####boxplots of age_rec 
plot_list <- list()


for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("lightblue",  "blue","orange", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/TCGA/Tumor/boxplots/age_rec/", paste0(i, paste0("_boxplot"), paste0("_with_age_rec_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/TCGA/Tumor/", paste0("SASP_factors_combined", paste0("_boxplot"), paste0("_with_age_rec_tumor"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 40, width = 46)
grid.arrange(grobs = plot_list, ncol = 7)  # Adjust ncol based on your desired layout
dev.off()










#repeat for lung data 
#get necessary data from metadata 
temp_data <- lung_samples %>% select(age_grp_new, DFS_STATUS, age_at_index)

transc_lung$age_at_index <- temp_data$age_at_index
transc_lung$age_grp_new <- temp_data$age_grp_new
transc_lung$DFS_STATUS <- temp_data$DFS_STATUS
transc_lung <- transc_lung %>% mutate(age_rec = case_when(
  age_grp_new=="greater_70" & DFS_STATUS=="Recurrence" ~ "old_rec", 
  age_grp_new=="greater_70" & DFS_STATUS=="No.Recurrence" ~ "old_no_rec", 
  age_grp_new=="less_equal_70" & DFS_STATUS=="Recurrence" ~ "young_rec", 
  age_grp_new=="less_equal_70" & DFS_STATUS=="No.Recurrence" ~ "young_no_rec", 
))

#check correlation 

plot_data <- transc_lung
#creating a variable to loop over 
genes <- colnames(plot_data)
genes <- genes[1:33]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec","young_rec", "old_no_rec",  "old_rec"))
plot_data$age_grp_new <- factor(plot_data$age_grp_new, 
                            levels = c("less_equal_70", "greater_70"))

plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_at_index, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    theme_bw()+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "top")+
    facet_grid(. ~ DFS_STATUS)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("greg_transc/TCGA/Lung/correlation_plots/", paste0(i, paste0("correlation"), paste0("_with_age_Lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/TCGA/Lung/", paste0("SASP_factors_combined", paste0("_correlation"), paste0("_with_age_Lung"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 5)  # Adjust ncol based on your desired layout
dev.off()



#### boxplots of age_grp_new 
plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_grp_new, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_grp_new))+
    stat_compare_means(comparisons = list(c("greater_70", "less_equal_70")))+
    scale_color_manual(values = c("green4", "blue3"))+
    scale_x_discrete(labels=c("Young", "Old"))+
    theme_classic()+
    ggtitle(i)+
    xlab("")+ylab("")+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/TCGA/Lung/boxplots/age_grp/", paste0(i, paste0("_boxplot"), paste0("_with_age_Lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/TCGA/Lung/", paste0("SASP_factors_combined", paste0("_boxplot"), paste0("_with_age_Lung"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 5)  # Adjust ncol based on your desired layout
dev.off()



####boxplots of age_rec 
plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("skyblue",  "darkblue", "orangered", "darkred"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/TCGA/Lung/boxplots/age_rec/", paste0(i, paste0("_boxplot"), paste0("_with_age_rec_Lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/TCGA/Lung/", paste0("SASP_factors_combined", paste0("_boxplot"), paste0("_with_age_rec_Lung"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 40, width = 44)
grid.arrange(grobs = plot_list, ncol = 7)  # Adjust ncol based on your desired layout
dev.off()




########### TCGA: analyiss for upregulated transcripts in senescent cells ########

#check in TCGA cohort 

#counts
tcga_counts_stage_I_no_NA
#metadata
tcga_metadata_stage_I_no_NA

transc <- tcga_counts_stage_I_no_NA[transc_up_senscent,]

transc <- na.omit(transc)

tumor_samples <- tcga_metadata_stage_I_no_NA %>% filter(shortLetterCode=="TP")
lung_samples <- tcga_metadata_stage_I_no_NA %>% filter(shortLetterCode=="NT")



######check correlation and association with age in tumor samples of SASP FACTORS #######

transc_tumor <- transc %>% select(rownames(tumor_samples)) %>% t(.) %>% data.frame()
transc_lung <- transc %>% select(rownames(lung_samples)) %>% t(.) %>% data.frame()

#get necessary data from metadata 
temp_data <- tumor_samples %>% select(age_grp_new, DFS_STATUS, age_at_index)

transc_tumor$age_at_index <- temp_data$age_at_index
transc_tumor$age_grp_new <- temp_data$age_grp_new
transc_tumor$DFS_STATUS <- temp_data$DFS_STATUS
transc_tumor <- transc_tumor %>% mutate(age_rec = case_when(
  age_grp_new=="greater_70" & DFS_STATUS=="Recurrence" ~ "old_rec", 
  age_grp_new=="greater_70" & DFS_STATUS=="No.Recurrence" ~ "old_no_rec", 
  age_grp_new=="less_equal_70" & DFS_STATUS=="Recurrence" ~ "young_rec", 
  age_grp_new=="less_equal_70" & DFS_STATUS=="No.Recurrence" ~ "young_no_rec", 
))

#check correlation 

plot_data <- transc_tumor
#creating a variable to loop over 
genes <- colnames(plot_data)
genes <- genes[1:15]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec","young_rec", "old_no_rec",  "old_rec"))
plot_data$age_grp_new <- factor(plot_data$age_grp_new, 
                            levels = c("less_equal_70", "greater_70"))

plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_at_index, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    theme_bw()+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "top")+
    facet_grid(. ~ DFS_STATUS)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("greg_transc/TCGA/Tumor/upreg_transc/correlation_plots/", paste0(i, paste0("correlation"), paste0("_with_age_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/TCGA/Tumor/upreg_transc/", paste0("upreg_transc_combined", paste0("_correlation"), paste0("_with_age_tumor"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 3)  # Adjust ncol based on your desired layout
dev.off()



#### boxplots of age_grp_new 
plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_grp_new, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_grp_new))+
    stat_compare_means(comparisons = list(c("greater_70", "less_equal_70")))+
    scale_color_manual(values = c("green4", "blue3"))+
    scale_x_discrete(labels=c("Young", "Old"))+
    theme_classic()+
    ggtitle(i)+xlab("")+ylab("")+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/TCGA/Tumor/upreg_transc/age_grp/", paste0(i, paste0("_boxplot"), paste0("_with_age_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/TCGA/Tumor/upreg_transc/", paste0("upreg_transc_combined", paste0("_boxplot"), paste0("_with_age_tumor"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 3)  # Adjust ncol based on your desired layout
dev.off()



####boxplots of age_rec 
plot_list <- list()


for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("lightblue",  "blue","orange", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/TCGA/Tumor/upreg_transc/age_rec/", paste0(i, paste0("_boxplot"), paste0("_with_age_rec_tumor"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/TCGA/Tumor/upreg_transc/", paste0("upreg_transc_combined", paste0("_boxplot"), paste0("_with_age_rec_tumor"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 32)
grid.arrange(grobs = plot_list, ncol = 4)  # Adjust ncol based on your desired layout
dev.off()









#repeat for lung data 
#get necessary data from metadata 
temp_data <- lung_samples %>% select(age_grp_new, DFS_STATUS, age_at_index)

transc_lung$age_at_index <- temp_data$age_at_index
transc_lung$age_grp_new <- temp_data$age_grp_new
transc_lung$DFS_STATUS <- temp_data$DFS_STATUS
transc_lung <- transc_lung %>% mutate(age_rec = case_when(
  age_grp_new=="greater_70" & DFS_STATUS=="Recurrence" ~ "old_rec", 
  age_grp_new=="greater_70" & DFS_STATUS=="No.Recurrence" ~ "old_no_rec", 
  age_grp_new=="less_equal_70" & DFS_STATUS=="Recurrence" ~ "young_rec", 
  age_grp_new=="less_equal_70" & DFS_STATUS=="No.Recurrence" ~ "young_no_rec", 
))

#check correlation 

plot_data <- transc_lung
#creating a variable to loop over 
genes <- colnames(plot_data)
genes <- genes[1:15]

plot_data$age_rec <- factor(plot_data$age_rec, 
                            levels = c("young_no_rec","young_rec", "old_no_rec",  "old_rec"))
plot_data$age_grp_new <- factor(plot_data$age_grp_new, 
                            levels = c("less_equal_70", "greater_70"))

plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_at_index, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    theme_bw()+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "top")+
    facet_grid(. ~ DFS_STATUS)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("greg_transc/TCGA/Lung/upreg_transc/correlation_plots/", paste0(i, paste0("correlation"), paste0("_with_age_Lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/TCGA/Lung/upreg_transc/", paste0("upreg_transc_combined", paste0("_correlation"), paste0("_with_age_Lung"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 3)  # Adjust ncol based on your desired layout
dev.off()



#### boxplots of age_grp_new 
plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_grp_new, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_grp_new))+
    stat_compare_means(comparisons = list(c("greater_70", "less_equal_70")))+
    scale_color_manual(values = c("green4", "blue3"))+
    scale_x_discrete(labels=c("Young", "Old"))+
    theme_classic()+
    ggtitle(i)+xlab("")+ylab("")+
    theme(axis.text.x = element_text(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/TCGA/Lung/upreg_transc/age_grp/", paste0(i, paste0("_boxplot"), paste0("_with_age_Lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/TCGA/Lung/upreg_transc/", paste0("upreg_transc_combined", paste0("_boxplot"), paste0("_with_age_Lung"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 22)
grid.arrange(grobs = plot_list, ncol = 3)  # Adjust ncol based on your desired layout
dev.off()



####boxplots of age_rec 
plot_list <- list()

for (i in genes){
  p <- ggplot(plot_data, aes_string(x= plot_data$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("skyblue",  "darkblue", "orangered", "darkred"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("greg_transc/TCGA/Lung/upreg_transc/age_rec/", paste0(i, paste0("_boxplot"), paste0("_with_age_rec_Lung"),paste0(".pdf")))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("greg_transc/TCGA/Lung/upreg_transc/", paste0("upreg_transc_combined", paste0("_boxplot"), paste0("_with_age_rec_Lung"),paste0(".pdf")))

pdf(file = combined_pdf_output, height = 30, width = 32)
grid.arrange(grobs = plot_list, ncol = 4)  # Adjust ncol based on your desired layout
dev.off()










































##########  overlap of SASP factors  with edgeR results ################

####### NYU cohrot SASP factors 

SASP_factors

#tumor samples 

#read edgeR results of rec vs no rec in old 
res <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_tumor_no_second_primary.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% SASP_factors)
# export as a list 
write.csv(overlap, file = "greg_transc/NYU/Tumor/overlap/NYU_tumor_overlap_SASP_factors_with_age_rec_old.csv")

#read edgeR results of rec vs no rec in young 
res <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_tumor_no_second_primary.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% SASP_factors)
# export as a list 
write.csv(overlap, file = "greg_transc/NYU/Tumor/overlap/NYU_tumor_overlap_SASP_factors_with_age_rec_young.csv")


#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_age_grp_tumor_no_second_primary.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% SASP_factors)
# export as a list 
write.csv(overlap, file = "greg_transc/NYU/Tumor/overlap/NYU_tumor_overlap_SASP_factors_with_age.csv")


#lung samples old rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_lung_no_second_primary.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% SASP_factors)
# export as a list 
write.csv(overlap, file = "greg_transc/NYU/Lung/overlap/NYU_lung_overlap_SASP_factors_with_age_rec_old.csv")

#young rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_lung_no_second_primary.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% SASP_factors)
# export as a list 
write.csv(overlap, file = "greg_transc/NYU/Lung/overlap/NYU_lung_overlap_SASP_factors_with_age_rec_young.csv")


#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_age_grp_lung_no_second_primary.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% SASP_factors)
# export as a list 
write.csv(overlap, file = "greg_transc/NYU/Lung/overlap/NYU_lung_overlap_SASP_factors_with_age.csv")



####### NYU cohrot transc_up_senscent
 
transc_up_senscent

#tumor samples 

#read edgeR results of rec vs no rec old
res <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_tumor_no_second_primary.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% transc_up_senscent)
# export as a list 
write.csv(overlap, file = "greg_transc/NYU/Tumor/overlap/NYU_tumor_overlap_transc_up_senescent_with_age_rec_old.csv")


#read edgeR results of rec vs no rec young
res <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_tumor_no_second_primary.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% transc_up_senscent)
# export as a list 
write.csv(overlap, file = "greg_transc/NYU/Tumor/overlap/NYU_tumor_overlap_transc_up_senescent_with_age_rec_young.csv")


#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_age_grp_tumor_no_second_primary.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% transc_up_senscent)
# export as a list 
write.csv(overlap, file = "greg_transc/NYU/Tumor/overlap/NYU_tumor_overlap_transc_up_senescent_with_age.csv")


#lung samples 
#old rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_lung_no_second_primary.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% transc_up_senscent)
# export as a list 
write.csv(overlap, file = "greg_transc/NYU/Lung/overlap/NYU_lung_overlap_transc_up_senescent_with_age_rec_old.csv")

#young rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_lung_no_second_primary.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% transc_up_senscent)
# export as a list 
write.csv(overlap, file = "greg_transc/NYU/Lung/overlap/NYU_lung_overlap_transc_up_senescent_with_age_rec_young.csv")


#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_age_grp_lung_no_second_primary.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% transc_up_senscent)
# export as a list 
write.csv(overlap, file = "greg_transc/NYU/Lung/overlap/NYU_lung_overlap_transc_up_senescent_with_age.csv")







##### TCGA cohort

SASP_factors

#tumor samples 

#read edgeR results of rec vs no rec in old 
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% SASP_factors)
# export as a list 
write.csv(overlap, file = "greg_transc/TCGA/Tumor/overlap/TCGA_tumor_overlap_SASP_factors_with_age_rec_old.csv")

#read edgeR results of rec vs no rec in young 
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% SASP_factors)
# export as a list 
write.csv(overlap, file = "greg_transc/TCGA/Tumor/overlap/TCGA_tumor_overlap_SASP_factors_with_age_rec_young.csv")


#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_age_grp_new.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% SASP_factors)
# export as a list 
write.csv(overlap, file = "greg_transc/TCGA/Tumor/overlap/TCGA_tumor_overlap_SASP_factors_with_age.csv")


#lung samples old rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_lung_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% SASP_factors)
# export as a list 
write.csv(overlap, file = "greg_transc/TCGA/Lung/overlap/TCGA_lung_overlap_SASP_factors_with_age_rec_old.csv")

#young rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_lung_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% SASP_factors)
# export as a list 
write.csv(overlap, file = "greg_transc/TCGA/Lung/overlap/TCGA_lung_overlap_SASP_factors_with_age_rec_young.csv")


#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_lung_stage_I_TCGA_age_grp_new.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% SASP_factors)
# export as a list 
write.csv(overlap, file = "greg_transc/TCGA/Lung/overlap/TCGA_lung_overlap_SASP_factors_with_age.csv")





####### TCGA cohrot transc_up_senscent

transc_up_senscent

#tumor samples 

#read edgeR results of rec vs no rec old
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% transc_up_senscent)
# export as a list 
write.csv(overlap, file = "greg_transc/TCGA/Tumor/overlap/TCGA_tumor_overlap_transc_up_senescent_with_age_rec_old.csv")


#read edgeR results of rec vs no rec young
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% transc_up_senscent)
# export as a list 
write.csv(overlap, file = "greg_transc/TCGA/Tumor/overlap/TCGA_tumor_overlap_transc_up_senescent_with_age_rec_young.csv")


#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_age_grp_new.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% transc_up_senscent)
# export as a list 
write.csv(overlap, file = "greg_transc/TCGA/Tumor/overlap/TCGA_tumor_overlap_transc_up_senescent_with_age.csv")


#lung samples 
#old rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% transc_up_senscent)
# export as a list 
write.csv(overlap, file = "greg_transc/TCGA/Lung/overlap/TCGA_lung_overlap_transc_up_senescent_with_age_rec_old.csv")

#young rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% transc_up_senscent)
# export as a list 
write.csv(overlap, file = "greg_transc/TCGA/Lung/overlap/TCGA_lung_overlap_transc_up_senescent_with_age_rec_young.csv")


#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_lung_stage_I_TCGA_age_grp_new.csv")
#find overlap
overlap <- res %>% filter(Gene.symbol %in% transc_up_senscent)
# export as a list 
write.csv(overlap, file = "greg_transc/TCGA/Lung/overlap/TCGA_lung_overlap_transc_up_senescent_with_age.csv")














##### heatmap of genes expression with age and recurrence variables NYU#####
transc <- c(SASP_factors, transc_up_senscent)

temp <- RNA.data %>% data.frame() %>% filter(ProgType_Lab!="Secondary.Primary")

temp_count <- mycounts[,rownames(temp)]

transc_NYU <- temp_count[transc,]

transc_NYU <- na.omit(transc_NYU)

transc_NYU <-transc_NYU %>% t() %>% data.frame()

#get necessary data from metadata 
temp_data <- RNA.data %>% data.frame() %>% filter(ProgType_Lab!="Secondary.Primary") %>%  select(age_grp, Progression_Lab, Age, Sample_Type_Involved)

transc_NYU <- transc_NYU[rownames(temp_data),]

transc_NYU$Age <- temp_data$Age
transc_NYU$age_grp <- temp_data$age_grp
transc_NYU$Progression_Lab <- temp_data$Progression_Lab
transc_NYU$Sample_Type_Involved <- temp_data$Sample_Type_Involved
transc_NYU <- transc_NYU %>% mutate(age_rec=case_when(
  age_grp=="less_equal_70" & Progression_Lab=="No.Recurrence" ~ "young_no_rec", 
  age_grp=="less_equal_70" & Progression_Lab=="Recurrence" ~ "young_rec", 
  age_grp=="greater_70" & Progression_Lab=="No.Recurrence" ~ "old_no_rec", 
  age_grp=="greater_70" & Progression_Lab=="Recurrence" ~ "old_rec"))
transc_NYU <- transc_NYU %>% select(-CXCL1.1)

transc_NYU_tumor <- transc_NYU %>% filter(Sample_Type_Involved=="Lung.Tissue.In")
transc_NYU_lung <- transc_NYU %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")


#generate one boxplot for all factors for tumor and lung seperately 
#tumor tissue 

#long format data 

transc_NYU_tumor_long <- transc_NYU_tumor %>%
  select(-c(Sample_Type_Involved, Progression_Lab, Age, age_rec)) %>%
  gather(key = "Factor", value = "value", -age_grp)
transc_NYU_tumor_long$value <- as.numeric(transc_NYU_tumor_long$value)
transc_NYU_tumor_long$age_grp <- factor(transc_NYU_tumor_long$age_grp, levels = c("less_equal_70", "greater_70"))

# Create a plot
pdf(file = "greg_transc/NYU/NYU_all_transc_age_grp_no_second_prim_tumor.pdf", width = 14, height = 8)
ggplot(transc_NYU_tumor_long, aes(x = fct_reorder(Factor,-value, .fun = median), y = value, fill = age_grp)) +
  #geom_violin() +
  geom_boxplot(color = "black", alpha=0.7) +
  labs(x = "", y = "", fill="Age") +
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  ylim(c(0,100000))+
  scale_fill_manual(values = c("green4", "blue3"), labels=c("â‰¤70", ">70"))  # Change the palette as needed
dev.off()


#### repeat for age and recurrence 

#prepare data in long format 
transc_NYU_tumor_long <- transc_NYU_tumor %>%
  select(-c(Sample_Type_Involved, Progression_Lab, Age, age_grp)) %>%
  gather(key = "Factor", value = "value", -age_rec)
transc_NYU_tumor_long$value <- as.numeric(transc_NYU_tumor_long$value)
transc_NYU_tumor_long$age_rec <- factor(transc_NYU_tumor_long$age_rec, levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

#plot 
pdf(file = "greg_transc/NYU/NYU_all_transc_age_rec_no_second_prim_tumor.pdf", width = 18, height = 10)
ggplot(transc_NYU_tumor_long, aes(x = fct_reorder(Factor,-value, .fun = median), y = value, fill=age_rec)) +
  geom_boxplot(color = "black", alpha=0.7)+
  labs(x = "", y = "", fill="Age, Recurrence") +
  ylim(c(0,100000))+
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("lightblue", "orange", "blue", "red"), 
                    labels=c("â‰¤70 No Recu", ">70 No Recu", "â‰¤70 Recu", ">70 Recu"))  # Change the palette as needed
dev.off()

######## repeat for lung 

#long format data 

transc_NYU_lung_long <- transc_NYU_lung %>%
  select(-c(Sample_Type_Involved, Progression_Lab, Age, age_rec)) %>%
  gather(key = "Factor", value = "value", -age_grp)
transc_NYU_lung_long$value <- as.numeric(transc_NYU_lung_long$value)
transc_NYU_lung_long$age_grp <- factor(transc_NYU_lung_long$age_grp, levels = c("less_equal_70", "greater_70"))

# Create a plot
pdf(file = "greg_transc/NYU/NYU_all_transc_age_grp_no_second_prim_lung.pdf", width = 14, height = 8)
ggplot(transc_NYU_lung_long, aes(x = fct_reorder(Factor,-value, .fun = median), y = value, fill = age_grp)) +
  #geom_violin() +
  geom_boxplot(color = "black", alpha=0.7) +
  labs(x = "", y = "", fill="Age") +
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("green4", "blue3"), labels=c("â‰¤70", ">70"))  # Change the palette as needed
dev.off()


#### repeat for age and recurrence 

#prepare data in long format 
transc_NYU_lung_long <- transc_NYU_lung %>%
  select(-c(Sample_Type_Involved, Progression_Lab, Age, age_grp)) %>%
  gather(key = "Factor", value = "value", -age_rec)
transc_NYU_lung_long$value <- as.numeric(transc_NYU_lung_long$value)
transc_NYU_lung_long$age_rec <- factor(transc_NYU_lung_long$age_rec, levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

#plot 
pdf(file = "greg_transc/NYU/NYU_all_transc_age_rec_no_second_prim_lung.pdf", width = 18, height = 10)
ggplot(transc_NYU_lung_long, aes(x = fct_reorder(Factor,-value, .fun = median), y = value, fill=age_rec)) +
  geom_boxplot(color = "black", alpha=0.7)+
  labs(x = "", y = "", fill="Age, Recurrence") +
  #ylim(c(0,100000))+
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("skyblue", "orangered", "darkblue", "darkred"), 
                    labels=c("â‰¤70 No Recu", ">70 No Recu", "â‰¤70 Recu", ">70 Recu"))  # Change the palette as needed
dev.off()




##### heatmap of overall factors 
#set colors 
library(circlize)

#get matrix for heatmap  
heatmap_mat <- transc_NYU %>% select(-c(age_grp, Progression_Lab, Age, Sample_Type_Involved, age_rec))

#get maximal calues 
# Get the maximal enrichment score for each column (pathway)
max_scores <- apply(heatmap_mat, 2, max)

# Get the minimal enrichment score for each column (pathway)
min_scores <- apply(heatmap_mat, 2, min)

# Print the maximal and minimal scores for each pathway
max_min_scores <- data.frame(gene = colnames(heatmap_mat), Max_Score = max_scores, Min_Score = min_scores)
print(max_min_scores)


#get maximal and minimal scores 
max(max_min_scores$Max_Score)
min(max_min_scores$Max_Score)
max(max_min_scores$Min_Score)
min(max_min_scores$Min_Score)


col_fun = colorRamp2(c(0, 289043), c("white", "red"))
col_fun(seq(0, 289043))

#transplse so you get pathways as rows 
heatmap_mat_t <- as.data.frame(t(heatmap_mat))

#convert to matrix 
heatmap_mat_t <- as.matrix(heatmap_mat_t)

#plot heatmap using complex heatmaps 

set.seed(1234)

# Define colors for each levels of qualitative variables

col = list(age_grp = c("greater_70" = "blue3", "less_equal_70" = "green4"), 
           Progression_Lab=c("Recurrence" = "darkred", "No.Recurrence" = "dodgerblue"), 
           Sample_Type_Involved=c("Lung.Tissue.In"="red", "Lung.Tissue.UnIn"="blue"))

# Create the heatmap annotation
library(ComplexHeatmap)

ha <- HeatmapAnnotation(
  age_grp = transc_NYU$age_grp,
  Progression_Lab = transc_NYU$Progression_Lab,
  Sample_Type_Involved=transc_NYU$Sample_Type_Involved,
  col = col)

#plot
pdf(file = "greg_transc/NYU_greg_gene_expression_heatmap.pdf", height = 15, width = 36)
ComplexHeatmap::Heatmap(heatmap_mat_t, 
                        #rect_gp = gpar(col = "black", lwd = 2),
                        col = col_fun, 
                        row_title_side = "left", 
                        column_title_side = "bottom",
                        cluster_rows = TRUE, 
                        cluster_columns = TRUE,
                        row_names_gp = gpar(fontsface="bold", fontsize= 18),
                        row_names_side = "left", 
                        column_title = "", row_title = "", 
                        row_labels =rownames(heatmap_mat_t),
                        top_annotation = ha)
dev.off()


########### TCGA heatmap 
##### heatmap of genes expression with age and recurrence variables TCGA#####
transc <- c(SASP_factors, transc_up_senscent)

transc_TCGA <- tcga_counts_stage_I_no_NA[transc,]

transc_TCGA <- na.omit(transc_TCGA)

transc_TCGA <-transc_TCGA %>% t() %>% data.frame()

#get necessary data from metadata 
temp_data <- tcga_metadata_stage_I_no_NA %>%  select(age_grp_new, DFS_STATUS, definition)

transc_TCGA <- transc_TCGA[rownames(temp_data),]

transc_TCGA$age_grp_new <- temp_data$age_grp_new
transc_TCGA$DFS_STATUS <- temp_data$DFS_STATUS
transc_TCGA$definition <- temp_data$definition
transc_TCGA <- transc_TCGA %>% mutate(age_rec=case_when(
  age_grp_new=="less_equal_70" & DFS_STATUS=="No.Recurrence" ~ "young_no_rec", 
  age_grp_new=="less_equal_70" & DFS_STATUS=="Recurrence" ~ "young_rec", 
  age_grp_new=="greater_70" & DFS_STATUS=="No.Recurrence" ~ "old_no_rec", 
  age_grp_new=="greater_70" & DFS_STATUS=="Recurrence" ~ "old_rec"))
transc_TCGA <- transc_TCGA %>% select(-CXCL1.1)

transc_TCGA_tumor <- transc_TCGA %>% filter(definition=="Primary solid Tumor")
transc_TCGA_lung <- transc_TCGA %>% filter(definition=="Solid Tissue Normal")


#generate one boxplot for all factors for tumor and lung seperately 
#tumor tissue 

#long format data 

transc_TCGA_tumor_long <- transc_TCGA_tumor %>%
  select(-c(definition, DFS_STATUS, age_rec)) %>%
  gather(key = "Factor", value = "value", -age_grp_new)
transc_TCGA_tumor_long$value <- as.numeric(transc_TCGA_tumor_long$value)
transc_TCGA_tumor_long$age_grp <- factor(transc_TCGA_tumor_long$age_grp, levels = c("less_equal_70", "greater_70"))

# Create a plot
pdf(file = "greg_transc/TCGA/TCGA_all_transc_age_grp_no_second_prim_tumor.pdf", width = 14, height = 8)
ggplot(transc_TCGA_tumor_long, aes(x = fct_reorder(Factor,-value, .fun = median), y = value, fill = age_grp)) +
  #geom_violin() +
  geom_boxplot(color = "black", alpha=0.7) +
  labs(x = "", y = "", fill="Age") +
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  ylim(c(0,200000))+
  scale_fill_manual(values = c("green4", "blue3"), labels=c("â‰¤70", ">70"))  # Change the palette as needed
dev.off()


#### repeat for age and recurrence 

#prepare data in long format 
transc_TCGA_tumor_long <- transc_TCGA_tumor %>%
  select(-c(definition, DFS_STATUS, age_grp_new)) %>%
  gather(key = "Factor", value = "value", -age_rec)
transc_TCGA_tumor_long$value <- as.numeric(transc_TCGA_tumor_long$value)
transc_TCGA_tumor_long$age_rec <- factor(transc_TCGA_tumor_long$age_rec, levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

#plot 
pdf(file = "greg_transc/TCGA/TCGA_all_transc_age_rec_no_second_prim_tumor.pdf", width = 18, height = 10)
ggplot(transc_TCGA_tumor_long, aes(x = fct_reorder(Factor,-value, .fun = median), y = value, fill=age_rec)) +
  geom_boxplot(color = "black", alpha=0.7)+
  labs(x = "", y = "", fill="Age, Recurrence") +
  ylim(c(0,200000))+
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("lightblue", "orange", "blue", "red"), 
                    labels=c("â‰¤70 No Recu", ">70 No Recu", "â‰¤70 Recu", ">70 Recu"))  # Change the palette as needed
dev.off()

######## repeat for lung 

#long format data 

transc_TCGA_lung_long <- transc_TCGA_lung %>%
  select(-c(definition, DFS_STATUS, age_rec)) %>%
  gather(key = "Factor", value = "value", -age_grp_new)
transc_TCGA_lung_long$value <- as.numeric(transc_TCGA_lung_long$value)
transc_TCGA_lung_long$age_grp <- factor(transc_TCGA_lung_long$age_grp, levels = c("less_equal_70", "greater_70"))

# Create a plot
pdf(file = "greg_transc/TCGA/TCGA_all_transc_age_grp_no_second_prim_lung.pdf", width = 14, height = 8)
ggplot(transc_TCGA_lung_long, aes(x = fct_reorder(Factor,-value, .fun = median), y = value, fill = age_grp)) +
  #geom_violin() +
  geom_boxplot(color = "black", alpha=0.7) +
  labs(x = "", y = "", fill="Age") +
  theme_bw()+  
  ylim(c(0,100000))+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("green4", "blue3"), labels=c("â‰¤70", ">70"))  # Change the palette as needed
dev.off()


#### repeat for age and recurrence 

#prepare data in long format 
transc_TCGA_lung_long <- transc_TCGA_lung %>%
  select(-c(definition, DFS_STATUS, age_grp_new)) %>%
  gather(key = "Factor", value = "value", -age_rec)
transc_TCGA_lung_long$value <- as.numeric(transc_TCGA_lung_long$value)
transc_TCGA_lung_long$age_rec <- factor(transc_TCGA_lung_long$age_rec, levels = c("young_no_rec", "old_no_rec", "young_rec", "old_rec"))

#plot 
pdf(file = "greg_transc/TCGA/TCGA_all_transc_age_rec_no_second_prim_lung.pdf", width = 18, height = 10)
ggplot(transc_TCGA_lung_long, aes(x = fct_reorder(Factor,-value, .fun = median), y = value, fill=age_rec)) +
  geom_boxplot(color = "black", alpha=0.7)+
  labs(x = "", y = "", fill="Age, Recurrence") +
  ylim(c(0,100000))+
  theme_bw()+  
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 14, face = "bold"), 
        axis.text.y = element_text(size = 20, face = "bold"), 
        legend.position = "top")+
  scale_fill_manual(values = c("skyblue", "orangered", "darkblue", "darkred"), 
                    labels=c("â‰¤70 No Recu", ">70 No Recu", "â‰¤70 Recu", ">70 Recu"))  # Change the palette as needed
dev.off()














#set colors 
library(circlize)

#get matrix for heatmap  
heatmap_mat_tcga <- transc_TCGA %>% select(-c(age_grp_new, DFS_STATUS, definition, age_rec))

#get maximal calues 
# Get the maximal enrichment score for each column (pathway)
max_scores <- apply(heatmap_mat_tcga, 2, max)

# Get the minimal enrichment score for each column (pathway)
min_scores <- apply(heatmap_mat_tcga, 2, min)

# Print the maximal and minimal scores for each pathway
max_min_scores_tcga <- data.frame(gene = colnames(heatmap_mat_tcga), Max_Score = max_scores, Min_Score = min_scores)
print(max_min_scores)


#get maximal and minimal scores 
max(max_min_scores_tcga$Max_Score)
min(max_min_scores_tcga$Max_Score)
max(max_min_scores_tcga$Min_Score)
min(max_min_scores_tcga$Min_Score)


col_fun = colorRamp2(c(0, 362728), c("white", "red"))
col_fun(seq(0, 362728))

#transplse so you get pathways as rows 
heatmap_mat_tcga_t <- as.data.frame(t(heatmap_mat_tcga))

#convert to matrix 
heatmap_mat_tcga_t <- as.matrix(heatmap_mat_tcga_t)


combined_data <- cbind(heatmap_mat_t, heatmap_mat_tcga_t)
color_limits <- range(combined_data)
#plot heatmap using complex heatmaps 

set.seed(1234)

# Define colors for each levels of qualitative variables

col = list(age_grp_new = c("greater_70" = "blue3", "less_equal_70" = "green4"), 
           DFS_STATUS=c("Recurrence" = "darkred", "No.Recurrence" = "dodgerblue"), 
           definition=c("Primary solid Tumor"="red", "Solid Tissue Normal"="blue"))

# Create the heatmap annotation
library(ComplexHeatmap)

ha <- HeatmapAnnotation(
  age_grp_new = transc_TCGA$age_grp_new,
  DFS_STATUS = transc_TCGA$DFS_STATUS,
  definition=transc_TCGA$definition,
  col = col)

#plot
pdf(file = "greg_transc/TCGA_greg_gene_expression_heatmap.pdf", height = 15, width = 30)
ComplexHeatmap::Heatmap(heatmap_mat_tcga_t, 
                        #rect_gp = gpar(col = "black", lwd = 2),
                        col = colorRamp2(c(color_limits[1], color_limits[2]), colors = c("white", "red")), 
                        row_title_side = "left", 
                        column_title_side = "bottom",
                        cluster_rows = TRUE, 
                        cluster_columns = TRUE,
                        row_names_gp = gpar(fontsface="bold", fontsize= 18),
                        row_names_side = "left", 
                        column_title = "", row_title = "", 
                        row_labels =rownames(heatmap_mat_t),
                        top_annotation = ha)
dev.off()

#repeat here the NYU to make figure with same scale 

#get matrix for heatmap  
heatmap_mat <- transc_NYU %>% select(-c(age_grp, Progression_Lab, Age, Sample_Type_Involved, age_rec))

#get maximal calues 
# Get the maximal enrichment score for each column (pathway)
max_scores <- apply(heatmap_mat, 2, max)

# Get the minimal enrichment score for each column (pathway)
min_scores <- apply(heatmap_mat, 2, min)

# Print the maximal and minimal scores for each pathway
max_min_scores <- data.frame(gene = colnames(heatmap_mat), Max_Score = max_scores, Min_Score = min_scores)
print(max_min_scores)


#get maximal and minimal scores 
max(max_min_scores$Max_Score)
min(max_min_scores$Max_Score)
max(max_min_scores$Min_Score)
min(max_min_scores$Min_Score)


col_fun = colorRamp2(c(0, 289043), c("white", "red"))
col_fun(seq(0, 289043))

#transplse so you get pathways as rows 
heatmap_mat_t <- as.data.frame(t(heatmap_mat))

#convert to matrix 
heatmap_mat_t <- as.matrix(heatmap_mat_t)

#plot heatmap using complex heatmaps 

set.seed(1234)

# Define colors for each levels of qualitative variables

col = list(age_grp = c("greater_70" = "blue3", "less_equal_70" = "green4"), 
           Progression_Lab=c("Recurrence" = "darkred", "No.Recurrence" = "dodgerblue"), 
           Sample_Type_Involved=c("Lung.Tissue.In"="red", "Lung.Tissue.UnIn"="blue"))

# Create the heatmap annotation
library(ComplexHeatmap)

ha <- HeatmapAnnotation(
  age_grp = transc_NYU$age_grp,
  Progression_Lab = transc_NYU$Progression_Lab,
  Sample_Type_Involved=transc_NYU$Sample_Type_Involved,
  col = col)

#plot
pdf(file = "greg_transc/NYU_greg_gene_expression_heatmap.pdf", height = 15, width = 36)
ComplexHeatmap::Heatmap(heatmap_mat_t, 
                        #rect_gp = gpar(col = "black", lwd = 2),
                        col = colorRamp2(c(color_limits[1], color_limits[2]), colors = c("white", "red")), 
                        row_title_side = "left", 
                        column_title_side = "bottom",
                        cluster_rows = TRUE, 
                        cluster_columns = TRUE,
                        row_names_gp = gpar(fontsface="bold", fontsize= 18),
                        row_names_side = "left", 
                        column_title = "", row_title = "", 
                        row_labels =rownames(heatmap_mat_t),
                        top_annotation = ha)
dev.off()




##### venn diagram of overlap between edgeR results and greg SASP 




transc_up_senscent

#tumor samples 

#read edgeR results of rec vs no rec old
res <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_tumor_no_second_primary.csv")

res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, transc_up_senscent)



#read edgeR results of rec vs no rec young
res <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_tumor_no_second_primary.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, transc_up_senscent)


#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_age_grp_tumor_no_second_primary.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, transc_up_senscent)


#lung samples 
#old rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_lung_no_second_primary.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, transc_up_senscent)

#### plot venn diagram

# build a list 
x <- list(edgeR=names, Transcripts=transc_up_senscent)
#
library(ggvenn)
pdf(file = "greg_transc/NYU/Lung/overlap/venn_NYU_lung_old_Rec_norec_transc_upreg.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()

#young rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_lung_no_second_primary.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, transc_up_senscent)


# build a list 
x <- list(edgeR=names, Transcripts=transc_up_senscent)
#
library(ggvenn)
pdf(file = "greg_transc/NYU/Lung/overlap/venn_NYU_lung_young_Rec_norec_transc_upreg.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()


#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_age_grp_lung_no_second_primary.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, transc_up_senscent)


# build a list 
x <- list(edgeR=names, Transcripts=transc_up_senscent)
#
library(ggvenn)
pdf(file = "greg_transc/NYU/Lung/overlap/venn_NYU_lung_old_vs_young_and_transc_upreg.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()




################## SASP in NYU cohrot 

####### NYU cohrot SASP factors 

SASP_factors

#tumor samples 

#read edgeR results of rec vs no rec in old 
res <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_tumor_no_second_primary.csv")

#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, SASP_factors)


# build a list 
x <- list(edgeR=names, Transcripts=SASP_factors)
#
library(ggvenn)
pdf(file = "greg_transc/NYU/Lung/overlap/venn_NYU_tumor_old_Rec_no_rec_SASP_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()



#read edgeR results of rec vs no rec in young 
res <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_tumor_no_second_primary.csv")

#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, SASP_factors)

data
# build a list 
x <- list(edgeR=names, Transcripts=SASP_factors)
#
library(ggvenn)
pdf(file = "greg_transc/NYU/Lung/overlap/venn_NYU_tumor_young_Rec_no_rec_SASP_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()




#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_age_grp_tumor_no_second_primary.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, SASP_factors)

data
# build a list 
x <- list(edgeR=names, Transcripts=SASP_factors)
#
library(ggvenn)
pdf(file = "greg_transc/NYU/Lung/overlap/venn_NYU_tumor_old_vs_young_SASP_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()


#lung samples old rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_lung_no_second_primary.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, SASP_factors)

data
# build a list 
x <- list(edgeR=names, Transcripts=SASP_factors)
#
library(ggvenn)
pdf(file = "greg_transc/NYU/Lung/overlap/venn_NYU_lung_old_rec_vs_norec_SASP_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()


#young rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_lung_no_second_primary.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, SASP_factors)

data

#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_age_grp_lung_no_second_primary.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, SASP_factors)

data
# build a list 
x <- list(edgeR=names, Transcripts=SASP_factors)
#
library(ggvenn)
pdf(file = "greg_transc/NYU/Lung/overlap/venn_NYU_lung_old_vs_young_SASP_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()






#### repeat for TCGA 

#SASP 



SASP_factors

#tumor samples 

#read edgeR results of rec vs no rec in old 
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, SASP_factors)

data
# build a list 
x <- list(edgeR=names, Transcripts=SASP_factors)
#
library(ggvenn)
pdf(file = "greg_transc/TCGA/Lung/overlap/venn_TCGA_tumor_old_rec_vs_no_rec_SASP_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()


#read edgeR results of rec vs no rec in young 
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, SASP_factors)

data
# build a list 
x <- list(edgeR=names, Transcripts=SASP_factors)
#
library(ggvenn)
pdf(file = "greg_transc/TCGA/Lung/overlap/venn_TCGA_tumor_young_rec_vs_no_rec_SASP_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()



#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_age_grp_new.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, SASP_factors)

data
# build a list 
x <- list(edgeR=names, Transcripts=SASP_factors)
#
library(ggvenn)
pdf(file = "greg_transc/TCGA/Lung/overlap/venn_TCGA_tumor_old_vs_young_SASP_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()







#lung samples old rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_lung_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, SASP_factors)

data
# build a list 
x <- list(edgeR=names, Transcripts=SASP_factors)
#
library(ggvenn)
pdf(file = "greg_transc/TCGA/Lung/overlap/venn_TCGA_lung_old_rec_vs_no_rec_SASP_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()


#young rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_lung_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")

#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, SASP_factors)

data

#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_lung_stage_I_TCGA_age_grp_new.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, SASP_factors)

data




#Transc upreg in senecsence 


transc_up_senscent

#tumor samples 

#read edgeR results of rec vs no rec old
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, transc_up_senscent)

data
# build a list 
x <- list(edgeR=names, Transcripts=transc_up_senscent)
#
library(ggvenn)
pdf(file = "greg_transc/TCGA/Lung/overlap/venn_TCGA_tumor_old_rec_vs_no_rec_transc_up_senscent_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()



#read edgeR results of rec vs no rec young
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, transc_up_senscent)

data
# build a list 
x <- list(edgeR=names, Transcripts=transc_up_senscent)
#
library(ggvenn)
pdf(file = "greg_transc/TCGA/Lung/overlap/venn_TCGA_tumor_young_rec_vs_no_rec_transc_up_senscent_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()


#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_age_grp_new.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, transc_up_senscent)

data
# build a list 
x <- list(edgeR=names, Transcripts=transc_up_senscent)
#
library(ggvenn)
pdf(file = "greg_transc/TCGA/Lung/overlap/venn_TCGA_tumor_old_vs_young_transc_up_senscent_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()





#lung samples 
#old rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, transc_up_senscent)

data
# build a list 
x <- list(edgeR=names, Transcripts=transc_up_senscent)
#
library(ggvenn)
pdf(file = "greg_transc/TCGA/Lung/overlap/venn_TCGA_lung_old_rec_vs_no_rec_transc_up_senscent_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()



#young rec vs no rec
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, transc_up_senscent)

data
# build a list 
x <- list(edgeR=names, Transcripts=transc_up_senscent)
#
library(ggvenn)
pdf(file = "greg_transc/TCGA/Lung/overlap/venn_TCGA_lung_young_rec_vs_no_rec_transc_up_senscent_overlap.pdf", height = 6, width = 10)
ggvenn(x, fill_color = c("#0073C2FF", "#CD534CFF"), stroke_size = 1, set_name_size = 4)
dev.off()


#read edgR results of old vs young 
res <- read.csv(file = "Results/RNA/edgeR.results_lung_stage_I_TCGA_age_grp_new.csv")
#find overlap
res <- res %>% filter(FDR <=0.2, logFC>0)

names <- res$Gene.symbol

data <- intersect(names, transc_up_senscent)

data









###### greg data machine learning, NYU #### 
meta <- RNA.data %>% data.frame %>% filter(ProgType_Lab!="Secondary.Primary", Sample_Type_Involved=="Lung.Tissue.In")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- mycounts[genes_list,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

# Run elastic net model using 10k folds
## the inner CV regarding tuning parameters
folds <- createFolds(meta$Progression, k = 10, list = FALSE)


library(glmnet)
tunings=NULL
All.auc=NULL
predicted.pro=NULL

for (i in 1:10){
  train_index <- c(sample(which(meta$Progression==0), round(length(which(meta$Progression==0))*0.8)),
                   sample(which(meta$Progression!=0), round(length(which(meta$Progression!=0))*0.8)))
  train_data <- RA.tem[,train_index]
  meta.training <- meta[train_index,]
  
  for(alpha0 in (seq(0,20,1)/20)^2) {
    
    cvfit <- cv.glmnet(x=as.matrix(t(train_data)), y=meta.training$Progression, family="binomial",alpha=alpha0, keep=TRUE)
    tunings=rbind(tunings, c(alpha0, cvfit$cvm[cvfit$lambda==cvfit$lambda.min]))
  }  
  colnames(tunings)=c("alpha","cvm")
  tunings=data.frame(tunings)
  tunings=tunings[which.min(tunings$cvm),]
  
  ## the optimal model based on the training
  fit <- cv.glmnet(x=as.matrix(t(train_data)), y=meta.training$Progression, family = "binomial",
                   alpha=tunings$alpha)
  
  ## the predicted probabilities for the test
  ss=predict(fit, newx = as.matrix(t(RA.tem[,-train_index])), s = "lambda.min",
             type = "response") %>% as.data.frame()
  
  predicted.pro=rbind(predicted.pro,ss)
  
}
  
### ROC analysis based on all predicted values
roc.es=roc(meta$Progression~as.numeric(predicted.pro[rownames(meta),]))

### AUC and CIs
All.auc=rbind(All.auc,ci(roc.es)[c(2,1,3)])

colnames(All.auc)=c("AUC", "LowerCI", "UpperCI")












meta <- RNA.data %>% data.frame %>% filter(ProgType_Lab!="Secondary.Primary", Sample_Type_Involved=="Lung.Tissue.In")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- mycounts[genes_list,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)


library(glmnet)
tunings=NULL
All.auc=NULL
ROC_dat = NULL

for (i in 1:10) {
  
train_index <- c(sample(which(meta$Progression==0), round(length(which(meta$Progression==0))*0.8)),
                   sample(which(meta$Progression!=0), round(length(which(meta$Progression!=0))*0.8)))
train_data <- RA.tem[,train_index]
meta.training <- meta[train_index,]
  
for(alpha0 in (seq(0,20,1)/20)^2) {
    
    cvfit <- cv.glmnet(x=as.matrix(t(train_data)), y=meta.training$Progression, family="binomial",alpha=alpha0, keep=TRUE)
    tunings=rbind(tunings, c(alpha0, cvfit$cvm[cvfit$lambda==cvfit$lambda.min]))
    }  
colnames(tunings)=c("alpha","cvm")
tunings=data.frame(tunings)
tunings=tunings[which.min(tunings$cvm),]
  
## the optimal model based on the training
fit <- cv.glmnet(x=as.matrix(t(train_data)), y=meta.training$Progression, family = "binomial",
                   alpha=tunings$alpha)
  
## the predicted probabilities for the test
ss=predict(fit, newx = as.matrix(t(RA.tem[,-train_index])), s = "lambda.min",
             type = "response") %>% as.data.frame()


roc_data <- roc(meta[-train_index,]$Progression, as.numeric(unlist(ss)))
auc_value <- auc(roc_data)


### AUC and CIs
All.auc=c(All.auc, roc_data$auc)
ROC_dat=c(ROC_dat, roc_data[c(2,3,4)])

}











meta <- RNA.data %>% data.frame %>% filter(ProgType_Lab!="Secondary.Primary", Sample_Type_Involved=="Lung.Tissue.In")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- mycounts[genes_list,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)


obstime <- as.numeric(meta$New_time_followup.or.death)
delta <- as.numeric(meta$Progression)

model_data <- data.frame(obstime, delta, meta$Age)

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . + meta.Age, data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="greg_cox_test.csv")



#repeat in young patients only 

meta <- RNA.data %>% data.frame %>% filter(ProgType_Lab!="Secondary.Primary", Sample_Type_Involved=="Lung.Tissue.In", age_grp=="less_equal_70")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- mycounts[genes_list,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)


obstime <- as.numeric(meta$New_time_followup.or.death)
delta <- as.numeric(meta$Progression)

model_data <- data.frame(obstime, delta)

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . , data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="greg_cox_test_young_tumor.csv")




#repeat in old 


meta <- RNA.data %>% data.frame %>% filter(ProgType_Lab!="Secondary.Primary", Sample_Type_Involved=="Lung.Tissue.In", age_grp=="greater_70")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- mycounts[genes_list,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)


obstime <- as.numeric(meta$New_time_followup.or.death)
delta <- as.numeric(meta$Progression)

model_data <- data.frame(obstime, delta)

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . , data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="greg_cox_test_old_tumor.csv")



#repeat for lung

meta <- RNA.data %>% data.frame %>% filter(ProgType_Lab!="Secondary.Primary", Sample_Type_Involved=="Lung.Tissue.UnIn")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- mycounts[genes_list,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)


obstime <- as.numeric(meta$New_time_followup.or.death)
delta <- as.numeric(meta$Progression)

model_data <- data.frame(obstime, delta, meta$Age)

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . , data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

?coxph
# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="greg_cox_test_lung.csv")



#repeat in young patients only 

meta <- RNA.data %>% data.frame %>% filter(ProgType_Lab!="Secondary.Primary", Sample_Type_Involved=="Lung.Tissue.UnIn", age_grp=="less_equal_70")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- mycounts[genes_list,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)


obstime <- as.numeric(meta$New_time_followup.or.death)
delta <- as.numeric(meta$Progression)

model_data <- data.frame(obstime, delta)

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . , data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="greg_cox_test_young_lung.csv")




#repeat in old 


meta <- RNA.data %>% data.frame %>% filter(ProgType_Lab!="Secondary.Primary", Sample_Type_Involved=="Lung.Tissue.UnIn", age_grp=="greater_70")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- mycounts[genes_list,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)


obstime <- as.numeric(meta$New_time_followup.or.death)
delta <- as.numeric(meta$Progression)

model_data <- data.frame(obstime, delta)

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . , data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="greg_cox_test_old_lung.csv")






















meta <- RNA.data %>% data.frame %>% filter(ProgType_Lab!="Secondary.Primary")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- mycounts[genes_list,]
RA.com <- counts
colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)


obstime <- as.numeric(meta$New_time_followup.or.death)
delta <- as.numeric(meta$Progression)

model_data <- data.frame(obstime, delta, meta$Age, meta$Sample_Type_Involved)

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . +meta.Age+meta.Sample_Type_Involved, data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="greg_cox_test_overall_adjusted.csv")









############# greg data cox repeat in TCGA ################


meta <- tcga_metadata_stage_I_no_NA %>% data.frame %>% filter( shortLetterCode=="TP")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- tcga_counts_stage_I_no_NA[genes_list,]
RA.com <- counts
#colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

meta$DFS_STATUS_num <- ifelse(meta$DFS_STATUS=="Recurrence", "1", "0")
obstime <- as.numeric(meta$DFS_MONTHS) * 30.4167
delta <- as.numeric(meta$DFS_STATUS_num)

model_data <- data.frame(obstime, delta)

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . + meta$age_at_index, data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="TCGA_greg_cox_test.csv")



#repeat in young patients only 

meta <- tcga_metadata_stage_I_no_NA %>% data.frame %>% filter( shortLetterCode=="TP", age_grp_new=="less_equal_70")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- tcga_counts_stage_I_no_NA[genes_list,]
RA.com <- counts
#colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

meta$DFS_STATUS_num <- ifelse(meta$DFS_STATUS=="Recurrence", "1", "0")
obstime <- as.numeric(meta$DFS_MONTHS) * 30.4167
delta <- as.numeric(meta$DFS_STATUS_num)

model_data <- data.frame(obstime, delta)

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . + meta$age_at_index, data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="TCGA_greg_cox_test_young_tumor.csv")




#repeat in old 

meta <- tcga_metadata_stage_I_no_NA %>% data.frame %>% filter( shortLetterCode=="TP", age_grp_new=="greater_70")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- tcga_counts_stage_I_no_NA[genes_list,]
RA.com <- counts
#colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

meta$DFS_STATUS_num <- ifelse(meta$DFS_STATUS=="Recurrence", "1", "0")
obstime <- as.numeric(meta$DFS_MONTHS) * 30.4167
delta <- as.numeric(meta$DFS_STATUS_num)

model_data <- data.frame(obstime, delta)

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . + meta$age_at_index, data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="TCGA_greg_cox_test_old_tumor.csv")





#repeat for lung TCGA

meta <- tcga_metadata_stage_I_no_NA %>% data.frame %>% filter( shortLetterCode=="NT")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- tcga_counts_stage_I_no_NA[genes_list,]
RA.com <- counts
#colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

meta$DFS_STATUS_num <- ifelse(meta$DFS_STATUS=="Recurrence", "1", "0")
obstime <- as.numeric(meta$DFS_MONTHS) * 30.4167
delta <- as.numeric(meta$DFS_STATUS_num)

model_data <- data.frame(obstime, delta)

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . + meta$age_at_index, data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="TCGA_greg_cox_test_LUNG.csv")



#repeat in young patients only 

meta <- tcga_metadata_stage_I_no_NA %>% data.frame %>% filter( shortLetterCode=="NT", age_grp_new=="less_equal_70")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- tcga_counts_stage_I_no_NA[genes_list,]
RA.com <- counts
#colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

meta$DFS_STATUS_num <- ifelse(meta$DFS_STATUS=="Recurrence", "1", "0")
obstime <- as.numeric(meta$DFS_MONTHS) * 30.4167
delta <- as.numeric(meta$DFS_STATUS_num)

model_data <- data.frame(obstime, delta)

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . + meta$age_at_index, data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="TCGA_greg_cox_test_young_lung.csv")




#repeat in old 

meta <- tcga_metadata_stage_I_no_NA %>% data.frame %>% filter( shortLetterCode=="NT", age_grp_new=="greater_70")

genes_list <- c(SASP_factors, transc_up_senscent)

counts <- tcga_counts_stage_I_no_NA[genes_list,]
RA.com <- counts
#colnames(RA.com) <- gsub("X", "", colnames(RA.com))

#get model from expression in lung subset counts 
RA.tem <- RA.com[,rownames(meta)]
RA.tem <- na.omit(RA.tem)

meta$DFS_STATUS_num <- ifelse(meta$DFS_STATUS=="Recurrence", "1", "0")
obstime <- as.numeric(meta$DFS_MONTHS) * 30.4167
delta <- as.numeric(meta$DFS_STATUS_num)

model_data <- data.frame(obstime, delta)

cox.results <- NULL

for(i in 1:nrow(RA.tem)){
  # Create a data frame with selected columns
  genes_data <- t(RA.tem)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ . + meta$age_at_index, data = cbind(model_data, genes_data))
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")

write.csv(cox.results, file="TCGA_greg_cox_test_old_lung.csv")





##########forest plot for cox resutls #######
#NYU tumor 
res <- read.csv(file = "greg_cox_test_tumor.csv")

res <- res %>% filter(X!="CXCL1.1")
res <- res %>% filter(X!="meta.Age")


res$adj.p <- as.numeric(res$adj.p)

#arrange 
res <- res %>% 
  mutate(upper_ci= as.numeric(upper_ci)) %>% 
  mutate(lower_ci= as.numeric(lower_ci)) %>% 
  mutate(hr= as.numeric(hr)) %>% 
  mutate(color=ifelse(adj.p <= 0.2, "purple", "black")) %>% 
  arrange(., desc(hr))


#plot 
cox_plot <- ggplot(data=res, aes(x=hr, y=fct_reorder(X, hr), xmin=lower_ci, xmax=upper_ci))+
  geom_point(size=3)+
  geom_errorbarh(height=1)+
  geom_vline(xintercept = 1, color="red", linetype="dashed", alpha=0.5)+
  ylab("")+xlab("Hazard Ratio")+
  #xlim(0,2.5)+
  theme_classic()+
  theme(axis.text.y= element_text(face = ifelse(res$adj.p<= fdr_cutoff, "bold", "plain"), size = 20), 
        axis.text.x = element_text(face = "bold",size = 20, ), 
        axis.title.x=element_text(face = "bold", size = 24))




#save 
pdf(file = "Figures/RNA/forest_plot_NYU_tumor_Greg_data.pdf", height = 12, width = 8)
cox_plot
dev.off()




#TCGA tumor 
res <- read.csv(file = "TCGA_greg_cox_test_tumor.csv")

res <- res %>% filter(X!="CXCL1.1")


res$adj.p <- as.numeric(res$adj.p)

#arrange 
res <- res %>% 
  filter(adj.p<=0.2) %>% 
  mutate(upper_ci= as.numeric(upper_ci)) %>% 
  mutate(lower_ci= as.numeric(lower_ci)) %>% 
  mutate(hr= as.numeric(hr)) %>% 
  mutate(color=ifelse(adj.p <= 0.2, "purple", "black")) %>% 
  arrange(., desc(hr))

#plot 
cox_plot <- ggplot(data=res, aes(x=hr, y=fct_reorder(X, hr), xmin=lower_ci, xmax=upper_ci))+
  geom_point(size=3)+
  geom_errorbarh(height=1)+
  geom_vline(xintercept = 1, color="black", linetype="dashed", alpha=0.5)+
  ylab("")+xlab("Hazard Ratio")+
  xlim(0,3.5)+
  theme_classic()+
  theme(axis.text.y= element_text(face = "bold", size = 20), 
        axis.text.x = element_text(face = "bold", size = 20), 
        axis.title.x=element_text(face = "bold", size = 24))


#save 
pdf(file = "Figures/RNA/forest_plot_TCGA_tumor_Greg_data.pdf", height = 12, width = 8)
cox_plot
dev.off()



#TRACER tumor 
res <- read.csv(file = "greg_data_cox_tracer.csv")

res <- res %>% filter(X!="CXCL1.1")


res$adj.p <- as.numeric(res$adj.p)

#arrange 
res <- res %>% 
  filter(adj.p<=0.2) %>% 
  mutate(upper_ci= as.numeric(upper_ci)) %>% 
  mutate(lower_ci= as.numeric(lower_ci)) %>% 
  mutate(hr= as.numeric(hr)) %>% 
  mutate(color=ifelse(adj.p <= 0.2, "purple", "black")) %>% 
  arrange(., desc(hr))

#plot 
cox_plot <- ggplot(data=res, aes(x=hr, y=fct_reorder(X, hr), xmin=lower_ci, xmax=upper_ci))+
  geom_point(size=3)+
  geom_errorbarh(height=1)+
  geom_vline(xintercept = 1, color="black", linetype="dashed", alpha=0.5)+
  ylab("")+xlab("Hazard Ratio")+
  xlim(0,2.)+
  theme_classic()+
  theme(axis.text.y= element_text(face = "bold", size = 20), 
        axis.text.x = element_text(face = "bold", size = 20), 
        axis.title.x=element_text(face = "bold", size = 24))


#save 
pdf(file = "Figures/RNA/forest_plot_TRACER_tumor_Greg_data.pdf", height = 12, width = 8)
cox_plot
dev.off()



#######combined figure 
#read all results 

# install.packages("devtools")
devtools::install_github("NightingaleHealth/ggforestplot")


NYU_res <- read.csv(file = "greg_cox_test_tumor.csv")
TCGA_res <- read.csv(file = "TCGA_greg_cox_test_tumor.csv")
TRACER_res <- read.csv(file = "greg_data_cox_tracer.csv")

combined_data <- bind_rows(
  mutate(NYU_res, cohort = "NYU"),
  mutate(TCGA_res, cohort = "TCGA"),
  mutate(TRACER_res, cohort = "TRACER"))


combined_data <- combined_data %>% filter(X!=c("meta.Age", "meta$age_at_index","CXCL1.1"))
combined_data <- na.omit(combined_data)


# Define colors and shapes for each cohort
color_scale <- c("NYU" = "blue", "TCGA" = "goldenrod", "TRACER" = "purple3")
shape_scale <- c("NYU" = 16, "TCGA" = 15, "TRACER" = 18)
size_scale <- c("NYU" = 5, "TCGA" = 5, "TRACER" = 5)

# Define a significance cutoff
significance_cutoff <- 0.2

# Add a column to indicate significance
combined_data$significant <- ifelse(combined_data$adj.p < significance_cutoff, "Significant", "Not_Significant")


# Create a forest plot
forest_plot <- ggplot(combined_data, aes(x = hr, y = fct_reorder(X, hr), color = cohort, shape = cohort)) +
  geom_point(size = 4) +
  geom_errorbarh(aes(xmin = lower_ci, xmax = upper_ci), height = 2) +
  geom_vline(xintercept = 1, color = "red", linetype = "dashed") +
  scale_color_manual(values = color_scale) +
  scale_shape_manual(values = shape_scale) +
  xlim(c(0,3))+
  labs(x = "Hazard Ratio", y = "")+
  theme_classic()+
  theme(axis.text.y= element_text(face = "bold", size = 20),
        axis.text.x = element_text(face = "bold", size = 20), 
        axis.title.x=element_text(face = "bold", size = 24))

pdf(file = "forest_test.pdf", height = 20, width = 28)
forest_plot
dev.off()


#plot all thenm together using forest plot function 
#order by hr 

combined_data <- combined_data %>% filter(X!=c("meta.Age", "meta$age_at_index","CXCL1.1"))
combined_data <- na.omit(combined_data)
combined_data <- combined_data %>% 
  mutate(upper_ci= as.numeric(upper_ci)) %>% 
  mutate(lower_ci= as.numeric(lower_ci)) %>% 
  mutate(hr= as.numeric(hr)) %>% 
  arrange(., desc(hr))
combined_data$se <- (combined_data$upper_ci - combined_data$lower_ci) / (2 * 1.96)
combined_data$cohort <- factor(combined_data$cohort, levels = c("NYU", "TCGA", "TRACER"))
library(ggforestplot)


# Create the forest plot without error bars
forest_plot <- ggforestplot::forestplot(df = combined_data,
                                        name = X,
                                        estimate = hr,
                                        pvalue = adj.p,
                                        colour = cohort,
                                        shape = cohort,
                                        logodds = FALSE,
                                        psignif = 0.2,
                                        ci = 0.95)


forest_plot <- forest_plot +
  xlim(c(0, 2.6)) +
  geom_effect(ggplot2::aes(xmin=lower_ci, xmax=upper_ci, color=cohort, shape=cohort))+
  labs(x = "Hazard Ratio 95% CI", y = "") +
  theme_forest() +
  theme(legend.position = "top")

  
pdf(file = "all_cohorts_tumor_forest_plot_greg.pdf", height = 13, width = 8)
forest_plot
dev.off()



#wrap figures 
pdf(file = "all_cohorts_tumor_forest_greg_Data_wrap.pdf", height = 13, width = 18)
ggplot(combined_data, aes(x = hr, y = fct_reorder(X, hr))) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = lower_ci, xmax = upper_ci), height = 0.5) +
  geom_vline(xintercept = 1, color = "red", linetype = "dashed") +
  xlim(c(0,2.6))+
  labs(x = "Hazard Ratio 95% CI", y = "")+
  facet_wrap(~cohort)+
  theme_bw()+
  theme(axis.text.y= element_text(face = "bold", size = 16),
        axis.text.x = element_text(face = "bold", size = 16), 
        axis.title.x=element_text(face = "bold", size = 18))
dev.off()


######## forest plot repeat in tumor old 


NYU_res <- read.csv(file = "greg_cox_test_old_tumor.csv")
TCGA_res <- read.csv(file = "TCGA_greg_cox_test_old_tumor.csv")
TRACER_res <- read.csv(file = "greg_data_cox_tracer_old.csv")

combined_data <- bind_rows(
  mutate(NYU_res, cohort = "NYU"),
  mutate(TCGA_res, cohort = "TCGA"),
  mutate(TRACER_res, cohort = "TRACER"))

combined_data <- combined_data %>% filter(X!="CXCL1.1")
combined_data <- combined_data %>% filter(X!=c("meta$age_at_index"))
combined_data <- na.omit(combined_data)


# Define colors and shapes for each cohort
color_scale <- c("NYU" = "blue", "TCGA" = "goldenrod", "TRACER" = "purple3")
shape_scale <- c("NYU" = 16, "TCGA" = 15, "TRACER" = 18)
size_scale <- c("NYU" = 5, "TCGA" = 5, "TRACER" = 5)

# Define a significance cutoff
significance_cutoff <- 0.2

# Add a column to indicate significance
combined_data$significant <- ifelse(combined_data$adj.p < significance_cutoff, "Significant", "Not_Significant")




#plot all thenm together using forest plot function 
#order by hr 

combined_data <- combined_data %>% 
  mutate(upper_ci= as.numeric(upper_ci)) %>% 
  mutate(lower_ci= as.numeric(lower_ci)) %>% 
  mutate(hr= as.numeric(hr)) %>% 
  arrange(., desc(hr))
combined_data$se <- (combined_data$upper_ci - combined_data$lower_ci) / (2 * 1.96)
combined_data$cohort <- factor(combined_data$cohort, levels = c("NYU", "TCGA", "TRACER"))
library(ggforestplot)


# Create the forest plot without error bars
forest_plot <- ggforestplot::forestplot(df = combined_data,
                                        name = X,
                                        estimate = hr,
                                        pvalue = adj.p,
                                        colour = cohort,
                                        shape = cohort,
                                        logodds = FALSE,
                                        psignif = 0.2,
                                        ci = 0.95)


forest_plot <- forest_plot +
  xlim(c(0, 2.6)) +
  geom_effect(ggplot2::aes(xmin=lower_ci, xmax=upper_ci, color=cohort, shape=cohort))+
  labs(x = "Hazard Ratio 95% CI", y = "") +
  theme_forest() +
  theme(legend.position = "top")


pdf(file = "all_cohorts_tumor_forest_plot_greg_old.pdf", height = 13, width = 8)
forest_plot
dev.off()



#wrap figures 
pdf(file = "all_cohorts_tumor_forest_greg_Data_wrap_old.pdf", height = 13, width = 18)
ggplot(combined_data, aes(x = hr, y = fct_reorder(X, hr))) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = lower_ci, xmax = upper_ci), height = 0.5) +
  geom_vline(xintercept = 1, color = "red", linetype = "dashed") +
  xlim(c(0,6.5))+
  labs(x = "Hazard Ratio 95% CI", y = "")+
  facet_wrap(~cohort)+
  theme_bw()+
  theme(axis.text.y= element_text(face = "bold", size = 16),
        axis.text.x = element_text(face = "bold", size = 16), 
        axis.title.x=element_text(face = "bold", size = 18))
dev.off()






#repeat in tumor young 


NYU_res <- read.csv(file = "greg_cox_test_young_tumor.csv")
TCGA_res <- read.csv(file = "TCGA_greg_cox_test_young_tumor.csv")
TRACER_res <- read.csv(file = "greg_data_cox_tracer_young.csv")

combined_data <- bind_rows(
  mutate(NYU_res, cohort = "NYU"),
  mutate(TCGA_res, cohort = "TCGA"),
  mutate(TRACER_res, cohort = "TRACER"))

combined_data <- combined_data %>% filter(X!="CXCL1.1")
combined_data <- combined_data %>% filter(X!=c("meta$age_at_index"))
combined_data <- na.omit(combined_data)


# Define colors and shapes for each cohort
color_scale <- c("NYU" = "blue", "TCGA" = "gyoungenrod", "TRACER" = "purple3")
shape_scale <- c("NYU" = 16, "TCGA" = 15, "TRACER" = 18)
size_scale <- c("NYU" = 5, "TCGA" = 5, "TRACER" = 5)

# Define a significance cutoff
significance_cutoff <- 0.2

# Add a column to indicate significance
combined_data$significant <- ifelse(combined_data$adj.p < significance_cutoff, "Significant", "Not_Significant")




#plot all thenm together using forest plot function 
#order by hr 

combined_data <- combined_data %>% 
  mutate(upper_ci= as.numeric(upper_ci)) %>% 
  mutate(lower_ci= as.numeric(lower_ci)) %>% 
  mutate(hr= as.numeric(hr)) %>% 
  arrange(., desc(hr))
combined_data$se <- (combined_data$upper_ci - combined_data$lower_ci) / (2 * 1.96)
combined_data$cohort <- factor(combined_data$cohort, levels = c("NYU", "TCGA", "TRACER"))
library(ggforestplot)


# Create the forest plot without error bars
forest_plot <- ggforestplot::forestplot(df = combined_data,
                                        name = X,
                                        estimate = hr,
                                        pvalue = adj.p,
                                        colour = cohort,
                                        shape = cohort,
                                        logodds = FALSE,
                                        psignif = 0.2,
                                        ci = 0.95)


forest_plot <- forest_plot +
  xlim(c(0, 2.6)) +
  geom_effect(ggplot2::aes(xmin=lower_ci, xmax=upper_ci, color=cohort, shape=cohort))+
  labs(x = "Hazard Ratio 95% CI", y = "") +
  theme_forest() +
  theme(legend.position = "top")


pdf(file = "all_cohorts_tumor_forest_plot_greg_young.pdf", height = 13, width = 8)
forest_plot
dev.off()



#wrap figures 
pdf(file = "all_cohorts_tumor_forest_greg_Data_wrap_young.pdf", height = 13, width = 18)
ggplot(combined_data, aes(x = hr, y = fct_reorder(X, hr))) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = lower_ci, xmax = upper_ci), height = 0.5) +
  geom_vline(xintercept = 1, color = "red", linetype = "dashed") +
  xlim(c(0,6.5))+
  labs(x = "Hazard Ratio 95% CI", y = "")+
  facet_wrap(~cohort)+
  theme_bw()+
  theme(axis.text.y= element_text(face = "bold", size = 16),
        axis.text.x = element_text(face = "bold", size = 16), 
        axis.title.x=element_text(face = "bold", size = 18))
dev.off()












###### forest plot of greg data for lung data ########
#NYU lung 
fdr_cutoff=0.2
res <- read.csv(file = "greg_cox_test_lung.csv")

res <- res %>% filter(X!="CXCL1.1")
res <- res %>% filter(X!="meta.Age")


res$adj.p <- as.numeric(res$adj.p)

#arrange 
res <- res %>% 
  mutate(upper_ci= as.numeric(upper_ci)) %>% 
  mutate(lower_ci= as.numeric(lower_ci)) %>% 
  mutate(hr= as.numeric(hr)) %>% 
  mutate(color=ifelse(adj.p <= 0.2, "purple", "black")) %>% 
  arrange(., desc(hr))


#plot 
cox_plot <- ggplot(data=res, aes(x=hr, y=fct_reorder(X, hr), xmin=lower_ci, xmax=upper_ci))+
  geom_point(size=3)+
  geom_errorbarh(height=1)+
  geom_vline(xintercept = 1, color="red", linetype="dashed", alpha=0.5)+
  ylab("")+xlab("Hazard Ratio")+
  #xlim(0,2.5)+
  theme_classic()+
  theme(axis.text.y= element_text(face = ifelse(res$adj.p<= fdr_cutoff, "bold", "plain"), size = 20), 
        axis.text.x = element_text(face = "bold",size = 20, ), 
        axis.title.x=element_text(face = "bold", size = 24))




#save 
pdf(file = "Figures/RNA/forest_plot_NYU_lung_Greg_data.pdf", height = 12, width = 8)
cox_plot
dev.off()




#TCGA lung 
res <- read.csv(file = "TCGA_greg_cox_test_lung.csv")

res <- res %>% filter(X!="CXCL1.1")


res$adj.p <- as.numeric(res$adj.p)

#arrange 
res <- res %>% 
  #filter(adj.p<=0.2) %>% 
  mutate(upper_ci= as.numeric(upper_ci)) %>% 
  mutate(lower_ci= as.numeric(lower_ci)) %>% 
  mutate(hr= as.numeric(hr)) %>% 
  mutate(color=ifelse(adj.p <= 0.2, "purple", "black")) %>% 
  arrange(., desc(hr))

#plot 
cox_plot <- ggplot(data=res, aes(x=hr, y=fct_reorder(X, hr), xmin=lower_ci, xmax=upper_ci))+
  geom_point(size=3)+
  geom_errorbarh(height=1)+
  geom_vline(xintercept = 1, color="black", linetype="dashed", alpha=0.5)+
  ylab("")+xlab("Hazard Ratio")+
  xlim(0,3.5)+
  theme_classic()+
  theme(axis.text.y= element_text(face = "bold", size = 20), 
        axis.text.x = element_text(face = "bold", size = 20), 
        axis.title.x=element_text(face = "bold", size = 24))


#save 
pdf(file = "Figures/RNA/forest_plot_TCGA_lung_Greg_data.pdf", height = 12, width = 8)
cox_plot
dev.off()






#######combined figure 
#read all results 

# install.packages("devtools")
devtools::install_github("NightingaleHealth/ggforestplot")


NYU_res <- read.csv(file = "greg_cox_test_lung.csv")
TCGA_res <- read.csv(file = "TCGA_greg_cox_test_lung.csv")

combined_data <- bind_rows(
  mutate(NYU_res, cohort = "NYU"),
  mutate(TCGA_res, cohort = "TCGA"))


combined_data <- combined_data %>% filter(X!=c("meta.Age", "meta$age_at_index","CXCL1.1"))
combined_data <- na.omit(combined_data)


# Define colors and shapes for each cohort
color_scale <- c("NYU" = "blue", "TCGA" = "goldenrod")
shape_scale <- c("NYU" = 16, "TCGA" = 15)
size_scale <- c("NYU" = 5, "TCGA" = 5)

# Define a significance cutoff
significance_cutoff <- 0.2

# Add a column to indicate significance
combined_data$significant <- ifelse(combined_data$adj.p < significance_cutoff, "Significant", "Not_Significant")


# Create a forest plot
forest_plot <- ggplot(combined_data, aes(x = hr, y = fct_reorder(X, hr), color = cohort, shape = cohort)) +
  geom_point(size = 4) +
  geom_errorbarh(aes(xmin = lower_ci, xmax = upper_ci), height = 2) +
  geom_vline(xintercept = 1, color = "red", linetype = "dashed") +
  scale_color_manual(values = color_scale) +
  scale_shape_manual(values = shape_scale) +
  xlim(c(0,3))+
  labs(x = "Hazard Ratio", y = "")+
  theme_classic()+
  theme(axis.text.y= element_text(face = "bold", size = 20),
        axis.text.x = element_text(face = "bold", size = 20), 
        axis.title.x=element_text(face = "bold", size = 24))

pdf(file = "forest_test.pdf", height = 20, width = 28)
forest_plot
dev.off()


#plot all thenm together using forest plot function 
#order by hr 
# install.packages("devtools")
devtools::install_github("NightingaleHealth/ggforestplot")

combined_data <- combined_data %>% filter(X!=c("meta.Age", "meta$age_at_index","CXCL1.1"))
combined_data <- na.omit(combined_data)
combined_data <- combined_data %>% 
  mutate(upper_ci= as.numeric(upper_ci)) %>% 
  mutate(lower_ci= as.numeric(lower_ci)) %>% 
  mutate(hr= as.numeric(hr)) %>% 
  arrange(., desc(hr))
combined_data$se <- (combined_data$upper_ci - combined_data$lower_ci) / (2 * 1.96)
combined_data$cohort <- factor(combined_data$cohort, levels = c("NYU", "TCGA"))

library(ggforestplot)


# Create the forest plot without error bars
forest_plot <- ggforestplot::forestplot(df = combined_data,
                                        name = X,
                                        estimate = hr,
                                        pvalue = adj.p,
                                        colour = cohort,
                                        shape = cohort,
                                        logodds = FALSE,
                                        psignif = 0.2,
                                        ci = 0.95)


forest_plot <- forest_plot +
  xlim(c(0, 2.6)) +
  geom_effect(ggplot2::aes(xmin=lower_ci, xmax=upper_ci, color=cohort, shape=cohort))+
  labs(x = "Hazard Ratio 95% CI", y = "") +
  theme_forest() +
  theme(legend.position = "top")


pdf(file = "all_cohorts_lung_forest_plot_greg.pdf", height = 13, width = 8)
forest_plot
dev.off()



#wrap figures 
pdf(file = "all_cohorts_lung_forest_greg_Data_wrap.pdf", height = 13, width = 18)
ggplot(combined_data, aes(x = hr, y = fct_reorder(X, hr))) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = lower_ci, xmax = upper_ci), height = 0.5) +
  geom_vline(xintercept = 1, color = "red", linetype = "dashed") +
  xlim(c(0,2.6))+
  labs(x = "Hazard Ratio 95% CI", y = "")+
  facet_wrap(~cohort)+
  theme_bw()+
  theme(axis.text.y= element_text(face = "bold", size = 16),
        axis.text.x = element_text(face = "bold", size = 16), 
        axis.title.x=element_text(face = "bold", size = 18))
dev.off()


######## forest plot repeat in lung old 


NYU_res <- read.csv(file = "greg_cox_test_old_lung.csv")
TCGA_res <- read.csv(file = "TCGA_greg_cox_test_old_lung.csv")

combined_data <- bind_rows(
  mutate(NYU_res, cohort = "NYU"),
  mutate(TCGA_res, cohort = "TCGA"))

combined_data <- combined_data %>% filter(X!="CXCL1.1")
combined_data <- combined_data %>% filter(X!=c("meta$age_at_index"))
combined_data <- na.omit(combined_data)


# Define colors and shapes for each cohort
color_scale <- c("NYU" = "blue", "TCGA" = "goldenrod")
shape_scale <- c("NYU" = 16, "TCGA" = 15)
size_scale <- c("NYU" = 5, "TCGA" = 5)

# Define a significance cutoff
significance_cutoff <- 0.2

# Add a column to indicate significance
combined_data$significant <- ifelse(combined_data$adj.p < significance_cutoff, "Significant", "Not_Significant")




#plot all thenm together using forest plot function 
#order by hr 

combined_data <- combined_data %>% 
  mutate(upper_ci= as.numeric(upper_ci)) %>% 
  mutate(lower_ci= as.numeric(lower_ci)) %>% 
  mutate(hr= as.numeric(hr)) %>% 
  arrange(., desc(hr))
combined_data$se <- (combined_data$upper_ci - combined_data$lower_ci) / (2 * 1.96)
combined_data$cohort <- factor(combined_data$cohort, levels = c("NYU", "TCGA", "TRACER"))
library(ggforestplot)


# Create the forest plot without error bars
forest_plot <- ggforestplot::forestplot(df = combined_data,
                                        name = X,
                                        estimate = hr,
                                        pvalue = adj.p,
                                        colour = cohort,
                                        shape = cohort,
                                        logodds = FALSE,
                                        psignif = 0.2,
                                        ci = 0.95)


forest_plot <- forest_plot +
  xlim(c(0, 2.6)) +
  geom_effect(ggplot2::aes(xmin=lower_ci, xmax=upper_ci, color=cohort, shape=cohort))+
  labs(x = "Hazard Ratio 95% CI", y = "") +
  theme_forest() +
  theme(legend.position = "top")


pdf(file = "all_cohorts_lung_forest_plot_greg_old.pdf", height = 13, width = 8)
forest_plot
dev.off()



#wrap figures 
pdf(file = "all_cohorts_lung_forest_greg_Data_wrap_old.pdf", height = 13, width = 18)
ggplot(combined_data, aes(x = hr, y = fct_reorder(X, hr))) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = lower_ci, xmax = upper_ci), height = 0.5) +
  geom_vline(xintercept = 1, color = "red", linetype = "dashed") +
  xlim(c(0,6.5))+
  labs(x = "Hazard Ratio 95% CI", y = "")+
  facet_wrap(~cohort)+
  theme_bw()+
  theme(axis.text.y= element_text(face = "bold", size = 16),
        axis.text.x = element_text(face = "bold", size = 16), 
        axis.title.x=element_text(face = "bold", size = 18))
dev.off()






#repeat in lung young 


NYU_res <- read.csv(file = "greg_cox_test_young_lung.csv")
TCGA_res <- read.csv(file = "TCGA_greg_cox_test_young_lung.csv")


combined_data <- bind_rows(
  mutate(NYU_res, cohort = "NYU"),
  mutate(TCGA_res, cohort = "TCGA"))

combined_data <- combined_data %>% filter(X!="CXCL1.1")
combined_data <- combined_data %>% filter(X!=c("meta$age_at_index"))
combined_data <- na.omit(combined_data)


# Define colors and shapes for each cohort
color_scale <- c("NYU" = "blue", "TCGA" = "goldenrod")
shape_scale <- c("NYU" = 16, "TCGA" = 15)
size_scale <- c("NYU" = 5, "TCGA" = 5)

# Define a significance cutoff
significance_cutoff <- 0.2

# Add a column to indicate significance
combined_data$significant <- ifelse(combined_data$adj.p < significance_cutoff, "Significant", "Not_Significant")




#plot all thenm together using forest plot function 
#order by hr 

combined_data <- combined_data %>% 
  mutate(upper_ci= as.numeric(upper_ci)) %>% 
  mutate(lower_ci= as.numeric(lower_ci)) %>% 
  mutate(hr= as.numeric(hr)) %>% 
  arrange(., desc(hr))
combined_data$se <- (combined_data$upper_ci - combined_data$lower_ci) / (2 * 1.96)
combined_data$cohort <- factor(combined_data$cohort, levels = c("NYU", "TCGA", "TRACER"))
library(ggforestplot)


# Create the forest plot without error bars
forest_plot <- ggforestplot::forestplot(df = combined_data,
                                        name = X,
                                        estimate = hr,
                                        pvalue = adj.p,
                                        colour = cohort,
                                        shape = cohort,
                                        logodds = FALSE,
                                        psignif = 0.2,
                                        ci = 0.95)


forest_plot <- forest_plot +
  xlim(c(0, 2.6)) +
  geom_effect(ggplot2::aes(xmin=lower_ci, xmax=upper_ci, color=cohort, shape=cohort))+
  labs(x = "Hazard Ratio 95% CI", y = "") +
  theme_forest() +
  theme(legend.position = "top")


pdf(file = "all_cohorts_lung_forest_plot_greg_young.pdf", height = 13, width = 8)
forest_plot
dev.off()



#wrap figures 
pdf(file = "all_cohorts_lung_forest_greg_Data_wrap_young.pdf", height = 13, width = 18)
ggplot(combined_data, aes(x = hr, y = fct_reorder(X, hr))) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = lower_ci, xmax = upper_ci), height = 0.5) +
  geom_vline(xintercept = 1, color = "red", linetype = "dashed") +
  xlim(c(0,6.5))+
  labs(x = "Hazard Ratio 95% CI", y = "")+
  facet_wrap(~cohort)+
  theme_bw()+
  theme(axis.text.y= element_text(face = "bold", size = 16),
        axis.text.x = element_text(face = "bold", size = 16), 
        axis.title.x=element_text(face = "bold", size = 18))
dev.off()















################# clustering and UMAP in NYU ################

meta <- RNA.data %>% data.frame %>% filter(ProgType_Lab!="Secondary.Primary")



vsd

num_var_genes = 10000
vst_mat <- assay(vsd)
vst_mat <- vst_mat[,rownames(meta)]


rv = matrixStats::rowVars(vst_mat)
select = order(rv, decreasing = TRUE)[1:num_var_genes]
vst_mat = vst_mat[select, ]
vst_mat = vst_mat[sort(rownames(vst_mat)), ]
dim(vst_mat)
vst_mat %>% rowMeans() %>% quantile() %>% round(3)
vst_mat <- vst_mat %>% as.data.frame(rownames = "gene")

zscore_mat = scale(vst_mat)

set.seed(123)
pca_res = prcomp(zscore_mat, center = FALSE, scale. = FALSE)
head(pca_res$sdev)
pca_mat = pca_res$x
round(pca_mat[1:5, 1:5], 3)

pca_tbl = as_tibble(pca_mat[, 1:2])
pca_plot =
  ggplot(pca_tbl, aes(PC1, PC2)) +
  geom_point(color = "black", size = 0.5, alpha = 0.5) +
  theme_cowplot() +
  theme(plot.background = element_rect(fill = "white"), aspect.ratio = 1, axis.text = element_blank(), axis.ticks = element_blank(), legend.title = element_blank())


pca_plot
pca_scree_plot = factoextra::fviz_eig(pca_res, ncp = 30) + theme_cowplot()
pca_scree_plot
factoextra::fviz_pca_var(pca_res)

# UMAP

dims = 10
num_n = 10
min_d = 0.3

set.seed(123)
umap_mat = uwot::umap(zscore_mat, pca = dims, n_neighbors = num_n, min_dist = min_d)
umap_mat = round(umap_mat, 5)
colnames(umap_mat) = c("UMAP1", "UMAP2")
umap_tbl = tibble(gene = rownames(zscore_mat), UMAP1 = umap_mat[, 1], UMAP2 = umap_mat[, 2])

umap_plot =
  umap_tbl %>%
  sample_frac() %>%
  ggplot(aes(UMAP1, UMAP2)) +
  geom_point(color = "black", size = 0.5) +
  theme_cowplot() +
  theme(plot.background = element_rect(fill = "white"), aspect.ratio = 1, axis.text = element_blank(), axis.ticks = element_blank(), legend.title = element_blank())

umap_plot










num_var_genes = 10000
pca_dims = 10
num_n = 10
min_d = 0.3

n_clust = 20
zscore_mat 
dim(zscore_mat)
pca_mat

zscore_mat %>% quantile() %>% round(3)
zscore_mat %>% rowMeans() %>% quantile() %>% round(3)

# PAM clustering
dim(pca_mat)
pca_mat = pca_mat[, 1:pca_dims]
dim(pca_mat)
pam_res = cluster::pam(pca_mat, k = n_clust, cluster.only = TRUE, pamonce = 5)
str(pam_res)



#generate a table of clusters

modules_tbl = enframe(pam_res, name = "gene", value = "module")
modules_tbl$module = str_pad(modules_tbl$module, width = 2, side = "left", pad = "0")
modules_tbl
modules_tbl %>% dplyr::count(module, sort = TRUE)


#UMAP plot with modules

umap_tbl = inner_join(umap_tbl, modules_tbl, by = "gene")

color_scheme = c(brewer.pal(9, "Set1"), brewer.pal(8, "Accent"), brewer.pal(8, "Dark2"))
if (n_distinct(umap_tbl$module) > 25) {
  color_scheme = c(ggsci::pal_igv("default")(51), ggsci::pal_ucscgb()(26))
}

umap_plot =
  umap_tbl %>%
  sample_frac() %>%
  ggplot(aes(UMAP1, UMAP2)) +
  geom_point(aes(color = module), size = 0.5) +
  theme_cowplot() +
  theme(plot.background = element_rect(fill = "white"), aspect.ratio = 1, axis.text = element_blank(), axis.ticks = element_blank(), legend.title = element_blank()) +
  guides(color = guide_legend(override.aes = list(size = 5))) +
  scale_color_manual(values = color_scheme)

pdf(file = "umap_test.pdf", height = 8, width = 8)
umap_plot
dev.off()








# average expression per module

modules_list = split(x = modules_tbl$gene, f = modules_tbl$module)
str(modules_list)

zscore_avg_mat = matrix(nrow = length(modules_list), ncol = ncol(zscore_mat))
rownames(zscore_avg_mat) = names(modules_list)
colnames(zscore_avg_mat) = colnames(zscore_mat)
zscore_avg_mat[, 1:5]

colMeans(zscore_mat)

for (module in names(modules_list)) {
  zscore_avg_mat[module, ] = colMeans(as.matrix(zscore_mat[modules_list[[module]], ]))
}


zscore_avg_tbl = zscore_avg_mat %>% round(5) %>% as_tibble(rownames = "module")
zscore_avg_tbl
colnames(zscore_avg_tbl)

# write_csv(zscore_avg_tbl, glue("{out_prefix}.scores.csv"))
write_csv(zscore_avg_tbl, "rna-modules-scores-n246.csv")


# Identify the length of the longest sublist
max_length <- max(sapply(modules_list, length))

# Pad the sublists with NAs to make them equal in length
padded_list <- lapply(modules_list, function(x) c(x, rep(NA, max_length - length(x))))

# Combine the sublists into a data frame
df <- as.data.frame(padded_list)

# Specify the file path and name
csv_file <- "module_list.csv"

# Write the data frame to a CSV file with tab as the separator
write.table(df, file = csv_file, sep = "\t", row.names = FALSE)


#plot with gene expression according to age 


dge_list <- read.csv(file = "Results/RNA/edgeR.results_age_grp_lung_no_second_primary.csv")
dge_list$gene <- dge_list$Gene.symbol

plot_tbl = inner_join(umap_tbl, dge_list, by = "gene")
dim(plot_tbl)
head(plot_tbl)

plot_tbl$logFC %>% quantile(seq(0, 1, 0.1)) %>% round(2)
fc_cutoff = plot_tbl$logFC %>% abs() %>% quantile(0.99)
plot_tbl =
  plot_tbl %>%
  mutate(
    log2FC = logFC,
    log2FC = if_else(log2FC > fc_cutoff, fc_cutoff, log2FC),
    log2FC = if_else(log2FC < -fc_cutoff, -fc_cutoff, log2FC)
  )
plot_tbl$log2FC %>% quantile(seq(0, 1, 0.1)) %>% round(2)

#UMAP plot with modules

plot_tbl = plot_tbl %>% sample_frac()
#save 
write.csv(plot_tbl, file = "plot_tbl_lung_old_vs_young.csv")

umap_plot =
  ggplot(plot_tbl, aes(UMAP1, UMAP2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "green4", mid = "#FFFFFF", high = "darkblue")


pdf(file = "UMAP_lung_old_vs_young.pdf", height = 8, width = 8)
umap_plot
dev.off()


##### repeat this one with selected genes from SASP factors 
relevant_genes <- c(SASP_factors, transc_up_senscent)
duplicated(relevant_genes)

#check for genes in the plot 
setdiff(relevant_genes, plot_tbl$gene)

length(relevant_genes)
relevant_genes = intersect(relevant_genes, plot_tbl$gene)
length(relevant_genes)

#UMAP plot with selected genes

# default is 0.25
text_pad = 0.1
if (length(relevant_genes) < 30) { text_pad = 0.2 }
if (length(relevant_genes) < 20) { text_pad = 0.5 }


set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% relevant_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "green4", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_lung_old_vs_young_all_relev_genes.pdf", height = 8, width = 8)
umap_plot
dev.off()


#now go for sig genes only 


sig_genes = plot_tbl %>% filter(FDR < 0.2, gene %in% relevant_genes) %>% pull(gene)
length(sig_genes)

set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% sig_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "green4", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_lung_old_vs_young_sig_genes.pdf", height = 8, width = 8)
umap_plot
dev.off()











dge_list <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_lung_no_second_primary.csv")
dge_list$gene <- dge_list$Gene.symbol

plot_tbl = inner_join(umap_tbl, dge_list, by = "gene")
dim(plot_tbl)
head(plot_tbl)

plot_tbl$logFC %>% quantile(seq(0, 1, 0.1)) %>% round(2)
fc_cutoff = plot_tbl$logFC %>% abs() %>% quantile(0.99)
plot_tbl =
  plot_tbl %>%
  mutate(
    log2FC = logFC,
    log2FC = if_else(log2FC > fc_cutoff, fc_cutoff, log2FC),
    log2FC = if_else(log2FC < -fc_cutoff, -fc_cutoff, log2FC)
  )
plot_tbl$log2FC %>% quantile(seq(0, 1, 0.1)) %>% round(2)

#UMAP plot with modules

plot_tbl = plot_tbl %>% sample_frac()

#save 
write.csv(plot_tbl, file = "plot_tbl_lung_old_rec_no_rec.csv")

umap_plot =
  ggplot(plot_tbl, aes(UMAP1, UMAP2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "orangered", mid = "#FFFFFF", high = "darkred")

pdf(file = "UMAP_lung_rec_no_rec_old.pdf", height = 8, width = 8)
umap_plot
dev.off()



##### repeat this one with selected genes from SASP factors 
relevant_genes <- c(SASP_factors, transc_up_senscent)
duplicated(relevant_genes)

#check for genes in the plot 
setdiff(relevant_genes, plot_tbl$gene)

length(relevant_genes)
relevant_genes = intersect(relevant_genes, plot_tbl$gene)
length(relevant_genes)
# 41 genes are in the plot (out of 49)

#UMAP plot with selected genes

# default is 0.25
text_pad = 0.1
if (length(relevant_genes) < 30) { text_pad = 0.2 }
if (length(relevant_genes) < 20) { text_pad = 0.5 }


set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% relevant_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "orangered", mid = "#FFFFFF", high = "darkred")

pdf(file = "UMAP_lung_rec_no_rec_old_all_relev_genes.pdf", height = 8, width = 8)
umap_plot
dev.off()


#now go for sig genes only 


sig_genes = plot_tbl %>% filter(FDR < 0.2, gene %in% relevant_genes) %>% pull(gene)
length(sig_genes)

set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% sig_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "orangered", mid = "#FFFFFF", high = "darkred")

pdf(file = "UMAP_lung_rec_no_rec_old_sig_genes.pdf", height = 8, width = 8)
umap_plot
dev.off()

















######## lung young 

dge_list <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_lung_no_second_primary.csv")
dge_list$gene <- dge_list$Gene.symbol

plot_tbl = inner_join(umap_tbl, dge_list, by = "gene")
dim(plot_tbl)
head(plot_tbl)

plot_tbl$logFC %>% quantile(seq(0, 1, 0.1)) %>% round(2)
fc_cutoff = plot_tbl$logFC %>% abs() %>% quantile(0.99)
plot_tbl =
  plot_tbl %>%
  mutate(
    log2FC = logFC,
    log2FC = if_else(log2FC > fc_cutoff, fc_cutoff, log2FC),
    log2FC = if_else(log2FC < -fc_cutoff, -fc_cutoff, log2FC)
  )
plot_tbl$log2FC %>% quantile(seq(0, 1, 0.1)) %>% round(2)

#UMAP plot with modules

plot_tbl = plot_tbl %>% sample_frac()

#save 
write.csv(plot_tbl, file = "plot_tbl_lung_young_rec_no_rec.csv")

umap_plot =
  ggplot(plot_tbl, aes(UMAP1, UMAP2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "skyblue2", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_lung_rec_no_rec_young.pdf", height = 8, width = 8)
umap_plot
dev.off()







##### repeat this one with selected genes from SASP factors 
relevant_genes <- c(SASP_factors, transc_up_senscent)
duplicated(relevant_genes)

#check for genes in the plot 
setdiff(relevant_genes, plot_tbl$gene)

length(relevant_genes)
relevant_genes = intersect(relevant_genes, plot_tbl$gene)
length(relevant_genes)
# 41 genes are in the plot (out of 49)

#UMAP plot with selected genes

# default is 0.25
text_pad = 0.1
if (length(relevant_genes) < 30) { text_pad = 0.2 }
if (length(relevant_genes) < 20) { text_pad = 0.5 }


set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% relevant_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "skyblue2", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_lung_rec_no_rec_young_all_relev_genes.pdf", height = 8, width = 8)
umap_plot
dev.off()


#now go for sig genes only 


sig_genes = plot_tbl %>% filter(FDR < 0.2, gene %in% relevant_genes) %>% pull(gene)
length(sig_genes)

set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% sig_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "skyblue2", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_lung_rec_no_rec_young_sig_genes.pdf", height = 8, width = 8)
umap_plot
dev.off()
















#### tumor 



dge_list <- read.csv(file = "Results/RNA/edgeR.results_age_grp_tumor_no_second_primary.csv")
dge_list$gene <- dge_list$Gene.symbol

plot_tbl = inner_join(umap_tbl, dge_list, by = "gene")
dim(plot_tbl)
head(plot_tbl)

plot_tbl$logFC %>% quantile(seq(0, 1, 0.1)) %>% round(2)
fc_cutoff = plot_tbl$logFC %>% abs() %>% quantile(0.99)
plot_tbl =
  plot_tbl %>%
  mutate(
    log2FC = logFC,
    log2FC = if_else(log2FC > fc_cutoff, fc_cutoff, log2FC),
    log2FC = if_else(log2FC < -fc_cutoff, -fc_cutoff, log2FC)
  )
plot_tbl$log2FC %>% quantile(seq(0, 1, 0.1)) %>% round(2)

#UMAP plot with modules

plot_tbl = plot_tbl %>% sample_frac()
#save 
write.csv(plot_tbl, file = "plot_tbl_tumor_old_vs_young.csv")

umap_plot =
  ggplot(plot_tbl, aes(UMAP1, UMAP2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "green4", mid = "#FFFFFF", high = "darkblue")


pdf(file = "UMAP_tumor_old_vs_young.pdf", height = 8, width = 8)
umap_plot
dev.off()




##### repeat this one with selected genes from SASP factors 
relevant_genes <- c(SASP_factors, transc_up_senscent)
duplicated(relevant_genes)

#check for genes in the plot 
setdiff(relevant_genes, plot_tbl$gene)

length(relevant_genes)
relevant_genes = intersect(relevant_genes, plot_tbl$gene)
length(relevant_genes)

#UMAP plot with selected genes

# default is 0.25
text_pad = 0.1
if (length(relevant_genes) < 30) { text_pad = 0.2 }
if (length(relevant_genes) < 20) { text_pad = 0.5 }


set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% relevant_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "green4", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_tumor_old_vs_young_all_relev_genes.pdf", height = 8, width = 8)
umap_plot
dev.off()


#now go for sig genes only 


sig_genes = plot_tbl %>% filter(FDR < 0.2, gene %in% relevant_genes) %>% pull(gene)
length(sig_genes)

set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% sig_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "green4", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_tumor_old_vs_young_sig_genes.pdf", height = 8, width = 8)
umap_plot
dev.off()






dge_list <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_tumor_no_second_primary.csv")
dge_list$gene <- dge_list$Gene.symbol

plot_tbl = inner_join(umap_tbl, dge_list, by = "gene")
dim(plot_tbl)
head(plot_tbl)

plot_tbl$logFC %>% quantile(seq(0, 1, 0.1)) %>% round(2)
fc_cutoff = plot_tbl$logFC %>% abs() %>% quantile(0.99)
plot_tbl =
  plot_tbl %>%
  mutate(
    log2FC = logFC,
    log2FC = if_else(log2FC > fc_cutoff, fc_cutoff, log2FC),
    log2FC = if_else(log2FC < -fc_cutoff, -fc_cutoff, log2FC)
  )
plot_tbl$log2FC %>% quantile(seq(0, 1, 0.1)) %>% round(2)

#UMAP plot with modules

plot_tbl = plot_tbl %>% sample_frac()

#save 
write.csv(plot_tbl, file = "plot_tbl_tumor_old_rec_no_rec.csv")

umap_plot =
  ggplot(plot_tbl, aes(UMAP1, UMAP2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "orange", mid = "#FFFFFF", high = "red")

pdf(file = "UMAP_tumor_rec_no_rec_old.pdf", height = 8, width = 8)
umap_plot
dev.off()









##### repeat this one with selected genes from SASP factors 
relevant_genes <- c(SASP_factors, transc_up_senscent)
duplicated(relevant_genes)

#check for genes in the plot 
setdiff(relevant_genes, plot_tbl$gene)

length(relevant_genes)
relevant_genes = intersect(relevant_genes, plot_tbl$gene)
length(relevant_genes)
# 41 genes are in the plot (out of 49)

#UMAP plot with selected genes

# default is 0.25
text_pad = 0.1
if (length(relevant_genes) < 30) { text_pad = 0.2 }
if (length(relevant_genes) < 20) { text_pad = 0.5 }


set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% relevant_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "orange", mid = "#FFFFFF", high = "red")

pdf(file = "UMAP_tumor_rec_no_rec_old_all_relev_genes.pdf", height = 8, width = 8)
umap_plot
dev.off()


#now go for sig genes only 


sig_genes = plot_tbl %>% filter(FDR < 0.2, gene %in% relevant_genes) %>% pull(gene)
length(sig_genes)

set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% sig_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "orange", mid = "#FFFFFF", high = "red")

pdf(file = "UMAP_tumor_rec_no_rec_old_sig_genes.pdf", height = 8, width = 8)
umap_plot
dev.off()





###### tumor young 

dge_list <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_tumor_no_second_primary.csv")
dge_list$gene <- dge_list$Gene.symbol

plot_tbl = inner_join(umap_tbl, dge_list, by = "gene")
dim(plot_tbl)
head(plot_tbl)

plot_tbl$logFC %>% quantile(seq(0, 1, 0.1)) %>% round(2)
fc_cutoff = plot_tbl$logFC %>% abs() %>% quantile(0.99)
plot_tbl =
  plot_tbl %>%
  mutate(
    log2FC = logFC,
    log2FC = if_else(log2FC > fc_cutoff, fc_cutoff, log2FC),
    log2FC = if_else(log2FC < -fc_cutoff, -fc_cutoff, log2FC)
  )
plot_tbl$log2FC %>% quantile(seq(0, 1, 0.1)) %>% round(2)

#UMAP plot with modules

plot_tbl = plot_tbl %>% sample_frac()

#save 
write.csv(plot_tbl, file = "plot_tbl_tumor_young_rec_no_rec.csv")

umap_plot =
  ggplot(plot_tbl, aes(UMAP1, UMAP2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "skyblue", mid = "#FFFFFF", high = "blue")

pdf(file = "UMAP_tumor_rec_no_rec_young.pdf", height = 8, width = 8)
umap_plot
dev.off()





##### repeat this one with selected genes from SASP factors 
relevant_genes <- c(SASP_factors, transc_up_senscent)
duplicated(relevant_genes)

#check for genes in the plot 
setdiff(relevant_genes, plot_tbl$gene)

length(relevant_genes)
relevant_genes = intersect(relevant_genes, plot_tbl$gene)
length(relevant_genes)
# 41 genes are in the plot (out of 49)

#UMAP plot with selected genes

# default is 0.25
text_pad = 0.1
if (length(relevant_genes) < 30) { text_pad = 0.2 }
if (length(relevant_genes) < 20) { text_pad = 0.5 }


set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% relevant_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "skyblue", mid = "#FFFFFF", high = "blue")

pdf(file = "UMAP_tumor_rec_no_rec_young_all_relev_genes.pdf", height = 8, width = 8)
umap_plot
dev.off()


#now go for sig genes only 


sig_genes = plot_tbl %>% filter(FDR < 0.2, gene %in% relevant_genes) %>% pull(gene)
length(sig_genes)

set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% sig_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "skyblue", mid = "#FFFFFF", high = "blue")

pdf(file = "UMAP_tumor_rec_no_rec_young_sig_genes.pdf", height = 8, width = 8)
umap_plot
dev.off()








####compare between clusters ####

meta
temp_meta <- meta %>% dplyr::select(c(Sample_Type_Involved, age_grp, Progression))
samples_tbl <- temp_meta
samples_tbl <- samples_tbl %>% mutate(age_rec=case_when(
  age_grp=="greater_70" & Progression=="0" ~"old_no_rec", 
  age_grp=="greater_70" & Progression=="1" ~"old_rec", 
  age_grp=="less_equal_70" & Progression=="0" ~"young_no_rec", 
  age_grp=="less_equal_70" & Progression=="1" ~"young_rec", 
))
samples_tbl$age_rec <- factor(samples_tbl$age_rec, levels = c("young_no_rec", "young_rec", "old_no_rec", "old_rec"))
samples_tbl$sample_name <- rownames(samples_tbl)
zscore_avg_tbl


modules_tbl 
head(modules_tbl)
modules_tbl %>% dplyr::count(module)

scores_tbl = zscore_avg_tbl

head(scores_tbl)

#get average expression per module

modules_list
str(modules_list)

scores_mat = scores_tbl %>% column_to_rownames("module") %>% as.matrix()
scores_mat[, 1:5]


scores_mat %>% quantile() %>% round(3)


# plot

#combine samples and scores


scores_long_tbl =
  scores_mat %>% t() %>% as_tibble(rownames = "sample_name") %>%
  pivot_longer(!sample_name, names_to = "module", values_to = "exp")
head(scores_long_tbl)

plot_tbl = inner_join(samples_tbl, scores_long_tbl, by = "sample_name")
plot_tbl


n_distinct(plot_tbl$sample_name)
color_scheme = c(brewer.pal(9, "Set1"), brewer.pal(8, "Accent"), brewer.pal(8, "Dark2"))

#adjust plot settings based on the number of modules
num_modules = n_distinct(plot_tbl$module)
pt_size = 0.3
box_width = 0.3
facet_rows = 2
if (num_modules > 20) {
  pt_size = 0.2
  box_width = 0.5
  facet_rows = 4
}





#plot old_vs_young in tumor 

vln_plot =
  plot_tbl %>%
  filter(Sample_Type_Involved=="Lung.Tissue.In") %>% 
  ggplot(aes(x = age_grp, y = exp)) +
  geom_violin(aes(fill = age_grp), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  scale_fill_manual(values = color_scheme[c(2, 1)]) +
  labs(
    title = "Module Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(module), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_tumor_old_vs_young.pdf", height = 14, width = 20)
vln_plot
dev.off()








temp <- plot_tbl %>% filter(Sample_Type_Involved=="Lung.Tissue.In")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_grp), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in rownames(scores_mat)) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = plot_tbl %>% filter(module == module_name, age_grp == group1) %>%
      pull(exp)
    val_group2 = plot_tbl %>% filter(module == module_name, age_grp == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(module = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.tumor_old_vs_young.csv")












vln_plot =
  plot_tbl %>%
  filter(Sample_Type_Involved=="Lung.Tissue.In") %>% 
  ggplot(aes(x = age_rec, y = exp)) +
  geom_violin(aes(fill = age_rec), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  #scale_fill_manual(values = color_scheme[c(2, 1)]) +
  labs(
    title = "Module Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(module), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_tumor_old_vs_young_rec.pdf", height = 14, width = 20)
vln_plot
dev.off()





temp <- plot_tbl %>% filter(Sample_Type_Involved=="Lung.Tissue.In")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_rec), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in rownames(scores_mat)) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = plot_tbl %>% filter(module == module_name, age_rec == group1) %>%
      pull(exp)
    val_group2 = plot_tbl %>% filter(module == module_name, age_rec == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(module = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.tumor_old_vs_young_rec.csv")























######Lung 


#plot old_vs_young in lung 
vln_plot =
  plot_tbl %>%
  filter(Sample_Type_Involved=="Lung.Tissue.UnIn") %>% 
  ggplot(aes(x = age_grp, y = exp)) +
  geom_violin(aes(fill = age_grp), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  scale_fill_manual(values = color_scheme[c(2, 1)]) +
  labs(
    title = "Module Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(module), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_lung_old_vs_young.pdf", height = 14, width = 20)
vln_plot
dev.off()





temp <- plot_tbl %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_grp), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in rownames(scores_mat)) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = plot_tbl %>% filter(module == module_name, age_grp == group1) %>%
      pull(exp)
    val_group2 = plot_tbl %>% filter(module == module_name, age_grp == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(module = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.lung_old_vs_young.csv")









vln_plot =
  plot_tbl %>%
  filter(Sample_Type_Involved=="Lung.Tissue.UnIn") %>% 
  ggplot(aes(x = age_rec, y = exp)) +
  geom_violin(aes(fill = age_rec), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  #scale_fill_manual(values = color_scheme[c(2, 1)]) +
  labs(
    title = "Module Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(module), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_lung_old_vs_young_rec.pdf", height = 14, width = 20)
vln_plot
dev.off()





temp <- plot_tbl %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_rec), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in rownames(scores_mat)) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = temp %>% filter(module == module_name, age_rec == group1) %>%
      pull(exp)
    val_group2 = temp %>% filter(module == module_name, age_rec == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(module = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.lung_old_vs_young_rec.csv")













################# clustering and UMAP in TCGA ################

meta <- tcga_metadata_stage_I_no_NA %>% data.frame

#counts 
tcga_counts_stage_I_no_NA

#run deseq to get vsd and create vst matrix 

#Deseq 
#Convert Count Table into a Numeic Data Frame
d1 = data.frame(lapply(tcga_counts_stage_I_no_NA, function(x) as.numeric(as.character(x))), check.names=F, row.names = rownames(tcga_counts_stage_I_no_NA))

#Convert Data to Integers to Run DESEq
d1[] <- lapply(d1, as.integer)


dds <- DESeqDataSetFromMatrix(countData = d1, colData = meta, design = ~ age_grp_new + DFS_STATUS)

#Normalization Step 
dds <- estimateSizeFactors(dds)


#Filtering
#filter out genes where there are less than 3 samples with normalized counts greater than or equal to 100.
idx <- rowSums( counts(dds, normalized=TRUE) >= 100 ) >= 3
dds <- dds[idx,]

#Transform Data
vsd <- varianceStabilizingTransformation(dds)

#now get vst matrix 
num_var_genes = 10000
vst_mat <- assay(vsd)
vst_mat <- vst_mat[,rownames(meta)]


rv = matrixStats::rowVars(vst_mat)
select = order(rv, decreasing = TRUE)[1:num_var_genes]
vst_mat = vst_mat[select, ]
vst_mat = vst_mat[sort(rownames(vst_mat)), ]
dim(vst_mat)
vst_mat %>% rowMeans() %>% quantile() %>% round(3)
vst_mat <- vst_mat %>% as.data.frame(rownames = "gene")

zscore_mat = scale(vst_mat)

set.seed(123)
pca_res = prcomp(zscore_mat, center = FALSE, scale. = FALSE)
head(pca_res$sdev)
pca_mat = pca_res$x
round(pca_mat[1:5, 1:5], 3)

pca_tbl = as_tibble(pca_mat[, 1:2])
pca_plot =
  ggplot(pca_tbl, aes(PC1, PC2)) +
  geom_point(color = "black", size = 0.5, alpha = 0.5) +
  theme_cowplot() +
  theme(plot.background = element_rect(fill = "white"), aspect.ratio = 1, axis.text = element_blank(), axis.ticks = element_blank(), legend.title = element_blank())


pca_plot
pca_scree_plot = factoextra::fviz_eig(pca_res, ncp = 30) + theme_cowplot()
pca_scree_plot
factoextra::fviz_pca_var(pca_res)

# UMAP

dims = 10
num_n = 10
min_d = 0.3

set.seed(123)
umap_mat = uwot::umap(zscore_mat, pca = dims, n_neighbors = num_n, min_dist = min_d)
umap_mat = round(umap_mat, 5)
colnames(umap_mat) = c("UMAP1", "UMAP2")
umap_tbl = tibble(gene = rownames(zscore_mat), UMAP1 = umap_mat[, 1], UMAP2 = umap_mat[, 2])

umap_plot =
  umap_tbl %>%
  sample_frac() %>%
  ggplot(aes(UMAP1, UMAP2)) +
  geom_point(color = "black", size = 0.5) +
  theme_cowplot() +
  theme(plot.background = element_rect(fill = "white"), aspect.ratio = 1, axis.text = element_blank(), axis.ticks = element_blank(), legend.title = element_blank())

umap_plot










num_var_genes = 10000
pca_dims = 10
num_n = 10
min_d = 0.3

n_clust = 20
zscore_mat 
dim(zscore_mat)
pca_mat

zscore_mat %>% quantile() %>% round(3)
zscore_mat %>% rowMeans() %>% quantile() %>% round(3)

# PAM clustering
dim(pca_mat)
pca_mat = pca_mat[, 1:pca_dims]
dim(pca_mat)
pam_res = cluster::pam(pca_mat, k = n_clust, cluster.only = TRUE, pamonce = 5)
str(pam_res)



#generate a table of clusters

modules_tbl = enframe(pam_res, name = "gene", value = "module")
modules_tbl$module = str_pad(modules_tbl$module, width = 2, side = "left", pad = "0")
modules_tbl
modules_tbl %>% dplyr::count(module, sort = TRUE)


#UMAP plot with modules

umap_tbl = inner_join(umap_tbl, modules_tbl, by = "gene")

color_scheme = c(brewer.pal(9, "Set1"), brewer.pal(8, "Accent"), brewer.pal(8, "Dark2"))
if (n_distinct(umap_tbl$module) > 25) {
  color_scheme = c(ggsci::pal_igv("default")(51), ggsci::pal_ucscgb()(26))
}

umap_plot =
  umap_tbl %>%
  sample_frac() %>%
  ggplot(aes(UMAP1, UMAP2)) +
  geom_point(aes(color = module), size = 0.5) +
  theme_cowplot() +
  theme(plot.background = element_rect(fill = "white"), aspect.ratio = 1, axis.text = element_blank(), axis.ticks = element_blank(), legend.title = element_blank()) +
  guides(color = guide_legend(override.aes = list(size = 5))) +
  scale_color_manual(values = color_scheme)

pdf(file = "umap_test_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()








# average expression per module

modules_list = split(x = modules_tbl$gene, f = modules_tbl$module)
str(modules_list)

zscore_avg_mat = matrix(nrow = length(modules_list), ncol = ncol(zscore_mat))
rownames(zscore_avg_mat) = names(modules_list)
colnames(zscore_avg_mat) = colnames(zscore_mat)
zscore_avg_mat[, 1:5]

colMeans(zscore_mat)

for (module in names(modules_list)) {
  zscore_avg_mat[module, ] = colMeans(as.matrix(zscore_mat[modules_list[[module]], ]))
}


zscore_avg_tbl = zscore_avg_mat %>% round(5) %>% as_tibble(rownames = "module")
zscore_avg_tbl
colnames(zscore_avg_tbl)

# write_csv(zscore_avg_tbl, glue("{out_prefix}.scores.csv"))
write_csv(zscore_avg_tbl, "rna-modules-scores-n246_TCGA.csv")


# Identify the length of the longest sublist
max_length <- max(sapply(modules_list, length))

# Pad the sublists with NAs to make them equal in length
padded_list <- lapply(modules_list, function(x) c(x, rep(NA, max_length - length(x))))

# Combine the sublists into a data frame
df <- as.data.frame(padded_list)

# Specify the file path and name
csv_file <- "module_list_TCGA.csv"

# Write the data frame to a CSV file with tab as the separator
write.table(df, file = csv_file, sep = "\t", row.names = FALSE)


#plot with gene expression according to age 


dge_list <- read.csv(file = "Results/RNA/edgeR.results_lung_stage_I_TCGA_age_grp_new.csv")
dge_list$gene <- dge_list$Gene.symbol

plot_tbl = inner_join(umap_tbl, dge_list, by = "gene")
dim(plot_tbl)
head(plot_tbl)

plot_tbl$logFC %>% quantile(seq(0, 1, 0.1)) %>% round(2)
fc_cutoff = plot_tbl$logFC %>% abs() %>% quantile(0.99)
plot_tbl =
  plot_tbl %>%
  mutate(
    log2FC = logFC,
    log2FC = if_else(log2FC > fc_cutoff, fc_cutoff, log2FC),
    log2FC = if_else(log2FC < -fc_cutoff, -fc_cutoff, log2FC)
  )
plot_tbl$log2FC %>% quantile(seq(0, 1, 0.1)) %>% round(2)

#UMAP plot with modules

plot_tbl = plot_tbl %>% sample_frac()
#save 
write.csv(plot_tbl, file = "plot_tbl_lung_old_vs_young_TCGA.csv")

umap_plot =
  ggplot(plot_tbl, aes(UMAP1, UMAP2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "green4", mid = "#FFFFFF", high = "darkblue")


pdf(file = "UMAP_lung_old_vs_young_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()


##### repeat this one with selected genes from SASP factors 
relevant_genes <- c(SASP_factors, transc_up_senscent)
duplicated(relevant_genes)

#check for genes in the plot 
setdiff(relevant_genes, plot_tbl$gene)

length(relevant_genes)
relevant_genes = intersect(relevant_genes, plot_tbl$gene)
length(relevant_genes)

#UMAP plot with selected genes

# default is 0.25
text_pad = 0.1
if (length(relevant_genes) < 30) { text_pad = 0.2 }
if (length(relevant_genes) < 20) { text_pad = 0.5 }


set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% relevant_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "green4", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_lung_old_vs_young_all_relev_genes_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()


#now go for sig genes only 


sig_genes = plot_tbl %>% filter(FDR < 0.2, gene %in% relevant_genes) %>% pull(gene)
length(sig_genes)

set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% sig_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "green4", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_lung_old_vs_young_sig_genes_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()











dge_list <- read.csv(file = "Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")
dge_list$gene <- dge_list$Gene.symbol

plot_tbl = inner_join(umap_tbl, dge_list, by = "gene")
dim(plot_tbl)
head(plot_tbl)

plot_tbl$logFC %>% quantile(seq(0, 1, 0.1)) %>% round(2)
fc_cutoff = plot_tbl$logFC %>% abs() %>% quantile(0.99)
plot_tbl =
  plot_tbl %>%
  mutate(
    log2FC = logFC,
    log2FC = if_else(log2FC > fc_cutoff, fc_cutoff, log2FC),
    log2FC = if_else(log2FC < -fc_cutoff, -fc_cutoff, log2FC)
  )
plot_tbl$log2FC %>% quantile(seq(0, 1, 0.1)) %>% round(2)

#UMAP plot with modules

plot_tbl = plot_tbl %>% sample_frac()

#save 
write.csv(plot_tbl, file = "plot_tbl_lung_old_rec_no_rec_TCGA.csv")

umap_plot =
  ggplot(plot_tbl, aes(UMAP1, UMAP2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "orangered", mid = "#FFFFFF", high = "darkred")

pdf(file = "UMAP_lung_rec_no_rec_old_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()



##### repeat this one with selected genes from SASP factors 
relevant_genes <- c(SASP_factors, transc_up_senscent)
duplicated(relevant_genes)

#check for genes in the plot 
setdiff(relevant_genes, plot_tbl$gene)

length(relevant_genes)
relevant_genes = intersect(relevant_genes, plot_tbl$gene)
length(relevant_genes)
# 41 genes are in the plot (out of 49)

#UMAP plot with selected genes

# default is 0.25
text_pad = 0.1
if (length(relevant_genes) < 30) { text_pad = 0.2 }
if (length(relevant_genes) < 20) { text_pad = 0.5 }


set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% relevant_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "orangered", mid = "#FFFFFF", high = "darkred")

pdf(file = "UMAP_lung_rec_no_rec_old_all_relev_genes_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()


#now go for sig genes only 


sig_genes = plot_tbl %>% filter(FDR < 0.2, gene %in% relevant_genes) %>% pull(gene)
length(sig_genes)

set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% sig_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "orangered", mid = "#FFFFFF", high = "darkred")

pdf(file = "UMAP_lung_rec_no_rec_old_sig_genes_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()

















######## lung young 

dge_list <- read.csv(file = "Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")
dge_list$gene <- dge_list$Gene.symbol

plot_tbl = inner_join(umap_tbl, dge_list, by = "gene")
dim(plot_tbl)
head(plot_tbl)

plot_tbl$logFC %>% quantile(seq(0, 1, 0.1)) %>% round(2)
fc_cutoff = plot_tbl$logFC %>% abs() %>% quantile(0.99)
plot_tbl =
  plot_tbl %>%
  mutate(
    log2FC = logFC,
    log2FC = if_else(log2FC > fc_cutoff, fc_cutoff, log2FC),
    log2FC = if_else(log2FC < -fc_cutoff, -fc_cutoff, log2FC)
  )
plot_tbl$log2FC %>% quantile(seq(0, 1, 0.1)) %>% round(2)

#UMAP plot with modules

plot_tbl = plot_tbl %>% sample_frac()

#save 
write.csv(plot_tbl, file = "plot_tbl_lung_young_rec_no_rec_TCGA.csv")

umap_plot =
  ggplot(plot_tbl, aes(UMAP1, UMAP2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "skyblue2", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_lung_rec_no_rec_young_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()







##### repeat this one with selected genes from SASP factors 
relevant_genes <- c(SASP_factors, transc_up_senscent)
duplicated(relevant_genes)

#check for genes in the plot 
setdiff(relevant_genes, plot_tbl$gene)

length(relevant_genes)
relevant_genes = intersect(relevant_genes, plot_tbl$gene)
length(relevant_genes)
# 41 genes are in the plot (out of 49)

#UMAP plot with selected genes

# default is 0.25
text_pad = 0.1
if (length(relevant_genes) < 30) { text_pad = 0.2 }
if (length(relevant_genes) < 20) { text_pad = 0.5 }


set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% relevant_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "skyblue2", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_lung_rec_no_rec_young_all_relev_genes_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()


#now go for sig genes only 


sig_genes = plot_tbl %>% filter(FDR < 0.2, gene %in% relevant_genes) %>% pull(gene)
length(sig_genes)

set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% sig_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "skyblue2", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_lung_rec_no_rec_young_sig_genes_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()
















#### tumor 



dge_list <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_age_grp_new.csv")
dge_list$gene <- dge_list$Gene.symbol

plot_tbl = inner_join(umap_tbl, dge_list, by = "gene")
dim(plot_tbl)
head(plot_tbl)

plot_tbl$logFC %>% quantile(seq(0, 1, 0.1)) %>% round(2)
fc_cutoff = plot_tbl$logFC %>% abs() %>% quantile(0.99)
plot_tbl =
  plot_tbl %>%
  mutate(
    log2FC = logFC,
    log2FC = if_else(log2FC > fc_cutoff, fc_cutoff, log2FC),
    log2FC = if_else(log2FC < -fc_cutoff, -fc_cutoff, log2FC)
  )
plot_tbl$log2FC %>% quantile(seq(0, 1, 0.1)) %>% round(2)

#UMAP plot with modules

plot_tbl = plot_tbl %>% sample_frac()
#save 
write.csv(plot_tbl, file = "plot_tbl_tumor_old_vs_young_TCGA.csv")

umap_plot =
  ggplot(plot_tbl, aes(UMAP1, UMAP2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "green4", mid = "#FFFFFF", high = "darkblue")


pdf(file = "UMAP_tumor_old_vs_young_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()




##### repeat this one with selected genes from SASP factors 
relevant_genes <- c(SASP_factors, transc_up_senscent)
duplicated(relevant_genes)

#check for genes in the plot 
setdiff(relevant_genes, plot_tbl$gene)

length(relevant_genes)
relevant_genes = intersect(relevant_genes, plot_tbl$gene)
length(relevant_genes)

#UMAP plot with selected genes

# default is 0.25
text_pad = 0.1
if (length(relevant_genes) < 30) { text_pad = 0.2 }
if (length(relevant_genes) < 20) { text_pad = 0.5 }


set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% relevant_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "green4", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_tumor_old_vs_young_all_relev_genes_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()


#now go for sig genes only 


sig_genes = plot_tbl %>% filter(FDR < 0.2, gene %in% relevant_genes) %>% pull(gene)
length(sig_genes)

set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% sig_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "green4", mid = "#FFFFFF", high = "darkblue")

pdf(file = "UMAP_tumor_old_vs_young_sig_genes_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()






dge_list <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")
dge_list$gene <- dge_list$Gene.symbol

plot_tbl = inner_join(umap_tbl, dge_list, by = "gene")
dim(plot_tbl)
head(plot_tbl)

plot_tbl$logFC %>% quantile(seq(0, 1, 0.1)) %>% round(2)
fc_cutoff = plot_tbl$logFC %>% abs() %>% quantile(0.99)
plot_tbl =
  plot_tbl %>%
  mutate(
    log2FC = logFC,
    log2FC = if_else(log2FC > fc_cutoff, fc_cutoff, log2FC),
    log2FC = if_else(log2FC < -fc_cutoff, -fc_cutoff, log2FC)
  )
plot_tbl$log2FC %>% quantile(seq(0, 1, 0.1)) %>% round(2)

#UMAP plot with modules

plot_tbl = plot_tbl %>% sample_frac()

#save 
write.csv(plot_tbl, file = "plot_tbl_tumor_old_rec_no_rec_TCGA.csv")

umap_plot =
  ggplot(plot_tbl, aes(UMAP1, UMAP2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "orange", mid = "#FFFFFF", high = "red")

pdf(file = "UMAP_tumor_rec_no_rec_old_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()









##### repeat this one with selected genes from SASP factors 
relevant_genes <- c(SASP_factors, transc_up_senscent)
duplicated(relevant_genes)

#check for genes in the plot 
setdiff(relevant_genes, plot_tbl$gene)

length(relevant_genes)
relevant_genes = intersect(relevant_genes, plot_tbl$gene)
length(relevant_genes)
# 41 genes are in the plot (out of 49)

#UMAP plot with selected genes

# default is 0.25
text_pad = 0.1
if (length(relevant_genes) < 30) { text_pad = 0.2 }
if (length(relevant_genes) < 20) { text_pad = 0.5 }


set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% relevant_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "orange", mid = "#FFFFFF", high = "red")

pdf(file = "UMAP_tumor_rec_no_rec_old_all_relev_genes_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()


#now go for sig genes only 


sig_genes = plot_tbl %>% filter(FDR < 0.2, gene %in% relevant_genes) %>% pull(gene)
length(sig_genes)

set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% sig_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "orange", mid = "#FFFFFF", high = "red")

pdf(file = "UMAP_tumor_rec_no_rec_old_sig_genes_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()





###### tumor young 

dge_list <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")
dge_list$gene <- dge_list$Gene.symbol

plot_tbl = inner_join(umap_tbl, dge_list, by = "gene")
dim(plot_tbl)
head(plot_tbl)

plot_tbl$logFC %>% quantile(seq(0, 1, 0.1)) %>% round(2)
fc_cutoff = plot_tbl$logFC %>% abs() %>% quantile(0.99)
plot_tbl =
  plot_tbl %>%
  mutate(
    log2FC = logFC,
    log2FC = if_else(log2FC > fc_cutoff, fc_cutoff, log2FC),
    log2FC = if_else(log2FC < -fc_cutoff, -fc_cutoff, log2FC)
  )
plot_tbl$log2FC %>% quantile(seq(0, 1, 0.1)) %>% round(2)

#UMAP plot with modules

plot_tbl = plot_tbl %>% sample_frac()

#save 
write.csv(plot_tbl, file = "plot_tbl_tumor_young_rec_no_rec_TCGA.csv")

umap_plot =
  ggplot(plot_tbl, aes(UMAP1, UMAP2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "skyblue", mid = "#FFFFFF", high = "blue")

pdf(file = "UMAP_tumor_rec_no_rec_young_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()





##### repeat this one with selected genes from SASP factors 
relevant_genes <- c(SASP_factors, transc_up_senscent)
duplicated(relevant_genes)

#check for genes in the plot 
setdiff(relevant_genes, plot_tbl$gene)

length(relevant_genes)
relevant_genes = intersect(relevant_genes, plot_tbl$gene)
length(relevant_genes)
# 41 genes are in the plot (out of 49)

#UMAP plot with selected genes

# default is 0.25
text_pad = 0.1
if (length(relevant_genes) < 30) { text_pad = 0.2 }
if (length(relevant_genes) < 20) { text_pad = 0.5 }


set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% relevant_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "skyblue", mid = "#FFFFFF", high = "blue")

pdf(file = "UMAP_tumor_rec_no_rec_young_all_relev_genes_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()


#now go for sig genes only 


sig_genes = plot_tbl %>% filter(FDR < 0.2, gene %in% relevant_genes) %>% pull(gene)
length(sig_genes)

set.seed(1234)
plot_tbl =
  plot_tbl %>%
  mutate(gene_label = if_else(gene %in% sig_genes, gene, "")) %>%
  arrange(gene_label)
umap_plot =
  ggplot(plot_tbl, aes(x = UMAP1, y = UMAP2, label = gene_label)) +
  # geom_point(aes(color = log2FC), size = ifelse(plot_tbl$gene_label == "", 0.5, 2)) +
  geom_point(aes(color = log2FC), size = 0.5) +
  geom_text_repel(color = "black", segment.color = "gray20", box.padding = text_pad, max.overlaps = Inf) +
  #labs(title = plot_title, subtitle = plot_subtitle) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    aspect.ratio = 1,
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  scale_color_gradient2(low = "skyblue", mid = "#FFFFFF", high = "blue")

pdf(file = "UMAP_tumor_rec_no_rec_young_sig_genes_TCGA.pdf", height = 8, width = 8)
umap_plot
dev.off()








####compare between clusters ####

meta
temp_meta <- meta %>% dplyr::select(c(shortLetterCode, age_grp_new, DFS_STATUS))
samples_tbl <- temp_meta
samples_tbl <- samples_tbl %>% mutate(age_rec=case_when(
  age_grp_new=="greater_70" & DFS_STATUS=="No.Recurrence" ~"old_no_rec", 
  age_grp_new=="greater_70" & DFS_STATUS=="Recurrence" ~"old_rec", 
  age_grp_new=="less_equal_70" & DFS_STATUS=="No.Recurrence" ~"young_no_rec", 
  age_grp_new=="less_equal_70" & DFS_STATUS=="Recurrence" ~"young_rec", 
))
samples_tbl$age_rec <- factor(samples_tbl$age_rec, levels = c("young_no_rec", "young_rec", "old_no_rec", "old_rec"))
samples_tbl$sample_name <- rownames(samples_tbl)
zscore_avg_tbl


modules_tbl 
head(modules_tbl)
modules_tbl %>% dplyr::count(module)

scores_tbl = zscore_avg_tbl

head(scores_tbl)

#get average expression per module

modules_list
str(modules_list)

scores_mat = scores_tbl %>% column_to_rownames("module") %>% as.matrix()
scores_mat[, 1:5]


scores_mat %>% quantile() %>% round(3)


# plot

#combine samples and scores


scores_long_tbl =
  scores_mat %>% t() %>% as_tibble(rownames = "sample_name") %>%
  pivot_longer(!sample_name, names_to = "module", values_to = "exp")
head(scores_long_tbl)

plot_tbl = inner_join(samples_tbl, scores_long_tbl, by = "sample_name")
plot_tbl


n_distinct(plot_tbl$sample_name)
color_scheme = c(brewer.pal(9, "Set1"), brewer.pal(8, "Accent"), brewer.pal(8, "Dark2"))

#adjust plot settings based on the number of modules
num_modules = n_distinct(plot_tbl$module)
pt_size = 0.3
box_width = 0.3
facet_rows = 2
if (num_modules > 20) {
  pt_size = 0.2
  box_width = 0.5
  facet_rows = 4
}



library(ggbeeswarm)

#plot old_vs_young in tumor 

vln_plot =
  plot_tbl %>%
  filter(shortLetterCode=="TP") %>% 
  ggplot(aes(x = age_grp_new, y = exp)) +
  geom_violin(aes(fill = age_grp_new), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  scale_fill_manual(values = color_scheme[c(2, 1)]) +
  labs(
    title = "Module Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(module), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_tumor_old_vs_young_TCGA.pdf", height = 14, width = 20)
vln_plot
dev.off()








temp <- plot_tbl %>% filter(shortLetterCode=="TP")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_grp_new), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in rownames(scores_mat)) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = plot_tbl %>% filter(module == module_name, age_grp_new == group1) %>%
      pull(exp)
    val_group2 = plot_tbl %>% filter(module == module_name, age_grp_new == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(module = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.tumor_old_vs_young_TCGA.csv")












vln_plot =
  plot_tbl %>%
  filter(shortLetterCode=="TP") %>% 
  ggplot(aes(x = age_rec, y = exp)) +
  geom_violin(aes(fill = age_rec), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  #scale_fill_manual(values = color_scheme[c(2, 1)]) +
  labs(
    title = "Module Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(module), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_tumor_old_vs_young_rec_TCGA.pdf", height = 14, width = 20)
vln_plot
dev.off()





temp <- plot_tbl %>% filter(shortLetterCode=="TP")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_rec), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in rownames(scores_mat)) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = plot_tbl %>% filter(module == module_name, age_rec == group1) %>%
      pull(exp)
    val_group2 = plot_tbl %>% filter(module == module_name, age_rec == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(module = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.tumor_old_vs_young_rec_TCGA.csv")























######Lung 


#plot old_vs_young in lung 
vln_plot =
  plot_tbl %>%
  filter(shortLetterCode=="NT") %>% 
  ggplot(aes(x = age_grp_new, y = exp)) +
  geom_violin(aes(fill = age_grp_new), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  scale_fill_manual(values = color_scheme[c(2, 1)]) +
  labs(
    title = "Module Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(module), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_lung_old_vs_young_TCGA.pdf", height = 14, width = 20)
vln_plot
dev.off()





temp <- plot_tbl %>% filter(shortLetterCode=="NT")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_grp_new), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in rownames(scores_mat)) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = plot_tbl %>% filter(module == module_name, age_grp_new == group1) %>%
      pull(exp)
    val_group2 = plot_tbl %>% filter(module == module_name, age_grp_new == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(module = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.lung_old_vs_young_TCGA.csv")









vln_plot =
  plot_tbl %>%
  filter(shortLetterCode=="NT") %>% 
  ggplot(aes(x = age_rec, y = exp)) +
  geom_violin(aes(fill = age_rec), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  #scale_fill_manual(values = color_scheme[c(2, 1)]) +
  labs(
    title = "Module Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(module), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_lung_old_vs_young_rec_TCGA.pdf", height = 14, width = 20)
vln_plot
dev.off()





temp <- plot_tbl %>% filter(shortLetterCode=="NT")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_rec), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in rownames(scores_mat)) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = temp %>% filter(module == module_name, age_rec == group1) %>%
      pull(exp)
    val_group2 = temp %>% filter(module == module_name, age_rec == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(module = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.lung_old_vs_young_rec_TCGA.csv")

























####### ssGSEA again NYU##### 
ssGSEA_res_t_no_second_prim$age_grp <- meta$age_grp

ssGSEA_res_t_no_second_prim <- ssGSEA_res_t_no_second_prim %>% mutate(age_rec=case_when(
  age_grp=="greater_70" & Progression_Lab=="No.Recurrence" ~"old_no_rec", 
  age_grp=="greater_70" & Progression_Lab=="Recurrence" ~"old_rec", 
  age_grp=="less_equal_70" & Progression_Lab=="No.Recurrence" ~"young_no_rec", 
  age_grp=="less_equal_70" & Progression_Lab=="Recurrence" ~"young_rec", 
))
ssGSEA_res_t_no_second_prim$age_rec <- factor(ssGSEA_res_t_no_second_prim$age_rec, levels = c("young_no_rec", "young_rec", "old_no_rec", "old_rec"))

ssGSEA_res_t_no_second_prim[,1:52] <- scale(ssGSEA_res_t_no_second_prim[,1:52])


ssGSEA_res_scaled_mat <- 
  ssGSEA_res_t_no_second_prim %>% 
  dplyr::select(-c(Age, age_3_grps, Sample_Type_Involved, Progression_Lab_Inv, 
                   Progression_Lab, age_grp, ProgType_Lab, age_rec))
  
ssGSEA_res_t_no_second_prim$sample_name <- rownames(ssGSEA_res_t_no_second_prim)
ssGSEA_res_meta <- ssGSEA_res_t_no_second_prim %>% dplyr::select(Age, age_grp, Sample_Type_Involved, Progression_Lab,age_rec, sample_name)
ssGSEA_res_scaled_mat_long<- 
  ssGSEA_res_scaled_mat %>% as.tibble(rownames="sample_name") %>% 
  pivot_longer(!sample_name, names_to = "Pathway", values_to = "exp")
head(ssGSEA_res_scaled_mat_long)


plot_tbl = inner_join(ssGSEA_res_scaled_mat_long, ssGSEA_res_meta, by = "sample_name")
plot_tbl


n_distinct(plot_tbl$sample_name)

#adjust plot settings based on the number of modules
num_pathway = n_distinct(plot_tbl$Pathway)
pt_size = 0.3
box_width = 0.3
facet_rows = 2
if (num_pathway > 20) {
  pt_size = 0.2
  box_width = 0.5
  facet_rows = 6
}





#plot old_vs_young in tumor 

vln_plot =
  plot_tbl %>%
  filter(Sample_Type_Involved=="Lung.Tissue.In") %>% 
  ggplot(aes(x = age_rec, y = exp)) +
  geom_violin(aes(fill = age_rec), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  scale_fill_manual(values = c("lightblue","blue", "orange", "red")) +
  labs(
    title = "Pathway Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(Pathway), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_tumor_ssgsea_Age_rec.pdf", height = 20, width = 40)
vln_plot
dev.off()



temp <- plot_tbl %>% filter(Sample_Type_Involved=="Lung.Tissue.In")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_rec), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in colnames(ssGSEA_res_scaled_mat)[1:52]) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = temp %>% filter(Pathway == module_name, age_rec == group1) %>%
      pull(exp)
    val_group2 = temp %>% filter(Pathway == module_name, age_rec == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(Pathway = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.tumor_ssgsea_age_rec.csv")










##Lung 
vln_plot =
  plot_tbl %>%
  filter(Sample_Type_Involved=="Lung.Tissue.UnIn") %>% 
  ggplot(aes(x = age_rec, y = exp)) +
  geom_violin(aes(fill = age_rec), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  scale_fill_manual(values = c("skyblue", "darkblue", "orangered", "darkred"))+
  labs(
    title = "Pathway Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(Pathway), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_lung_ssgsea_Age_rec.pdf", height = 20, width = 40)
vln_plot
dev.off()







temp <- plot_tbl %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_rec), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in colnames(ssGSEA_res_scaled_mat)[1:52]) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = temp %>% filter(Pathway == module_name, age_rec == group1) %>%
      pull(exp)
    val_group2 = temp %>% filter(Pathway == module_name, age_rec == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(Pathway = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.lung_ssgsea_age_rec.csv")
















####### do the same for cibersort 
cibersort_res_no_seond_prim

cibersort_res_no_seond_prim$age_rec <- factor(cibersort_res_no_seond_prim$age_rec, levels = c("young_no_rec", "young_rec", "old_no_rec", "old_rec"))

cibersort_res_no_seond_prim[,1:22] <- scale(cibersort_res_no_seond_prim[,1:22])


cibersort_res_scaled_mat <- 
  cibersort_res_no_seond_prim %>% 
  dplyr::select(-c(P.value, Correlation, RMSE,age_3_grps, Sample_Type_Involved, Progression_Lab_Inv, 
                   ProgType_Lab, age_grp, Progression, age_rec))

cibersort_res_no_seond_prim$sample_name <- rownames(cibersort_res_no_seond_prim)
cibersort_res_meta <- cibersort_res_no_seond_prim %>% dplyr::select(c(age_3_grps, Sample_Type_Involved, Progression_Lab_Inv, 
                                                                    ProgType_Lab, age_grp, Progression, age_rec, sample_name))
cibersort_res_scaled_mat_long <- 
  cibersort_res_scaled_mat %>% as.tibble(rownames="sample_name") %>% 
  pivot_longer(!sample_name, names_to = "cell", values_to = "exp")
head(cibersort_res_scaled_mat_long)


plot_tbl = inner_join(cibersort_res_scaled_mat_long, cibersort_res_meta, by = "sample_name")
plot_tbl


n_distinct(plot_tbl$sample_name)

#adjust plot settings based on the number of modules
num_pathway = n_distinct(plot_tbl$cell)
pt_size = 0.3
box_width = 0.3
facet_rows = 2
if (num_pathway > 20) {
  pt_size = 0.2
  box_width = 0.5
  facet_rows = 6
}





#plot old_vs_young in tumor 

vln_plot =
  plot_tbl %>%
  filter(Sample_Type_Involved=="Lung.Tissue.In") %>% 
  ggplot(aes(x = age_rec, y = exp)) +
  geom_violin(aes(fill = age_rec), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  scale_fill_manual(values = c("lightblue","blue", "orange", "red")) +
  labs(
    title = "Pathway Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(cell), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_tumor_cibersort_Age_rec.pdf", height = 10, width = 16)
vln_plot
dev.off()



temp <- plot_tbl %>% filter(Sample_Type_Involved=="Lung.Tissue.In")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_rec), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in colnames(cibersort_res)[1:22]) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = temp %>% filter(cell == module_name, age_rec == group1) %>%
      pull(exp)
    val_group2 = temp %>% filter(cell == module_name, age_rec == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(cell = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.tumor_cibersort_age_rec.csv")










##Lung 
vln_plot =
  plot_tbl %>%
  filter(Sample_Type_Involved=="Lung.Tissue.UnIn") %>% 
  ggplot(aes(x = age_rec, y = exp)) +
  geom_violin(aes(fill = age_rec), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  scale_fill_manual(values = c("skyblue", "darkblue", "orangered", "darkred"))+
  labs(
    title = "Pathway Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(cell), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_lung_cibersort_Age_rec.pdf", height = 10, width = 16)
vln_plot
dev.off()







temp <- plot_tbl %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_rec), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in colnames(cibersort_res)[1:22]) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = temp %>% filter(cell == module_name, age_rec == group1) %>%
      pull(exp)
    val_group2 = temp %>% filter(cell == module_name, age_rec == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(cell = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.lung_cibersrot_age_rec.csv")





######### repeat in TCGA  cibersrot ##### 
####### do the same for cibersort 
cibersort_res_TCGA

cibersort_res_TCGA$age_rec <- factor(cibersort_res_TCGA$age_rec, levels = c("young_no_rec", "young_rec", "old_no_rec", "old_rec"))

cibersort_res_TCGA[,1:22] <- scale(cibersort_res_TCGA[,1:22])


cibersort_res_scaled_mat <- 
  cibersort_res_TCGA %>% 
  dplyr::select(-c(P.value, Correlation, RMSE,age_3_grps, dead_or_not_five_years, DFS_STATUS, 
                   shortLetterCode, age_grp_new, age_rec))

cibersort_res_TCGA$sample_name <- rownames(cibersort_res_TCGA)
cibersort_res_meta <- cibersort_res_TCGA %>% dplyr::select(c(age_grp_new, DFS_STATUS, shortLetterCode, 
                                                                       age_rec, sample_name))
cibersort_res_scaled_mat_long <- 
  cibersort_res_scaled_mat %>% as.tibble(rownames="sample_name") %>% 
  pivot_longer(!sample_name, names_to = "cell", values_to = "exp")
head(cibersort_res_scaled_mat_long)


plot_tbl = inner_join(cibersort_res_scaled_mat_long, cibersort_res_meta, by = "sample_name")
plot_tbl


n_distinct(plot_tbl$sample_name)

#adjust plot settings based on the number of modules
num_pathway = n_distinct(plot_tbl$cell)
pt_size = 0.3
box_width = 0.3
facet_rows = 2
if (num_pathway > 20) {
  pt_size = 0.2
  box_width = 0.5
  facet_rows = 6
}



library(ggbeeswarm)

#plot old_vs_young age rec in tumor 

vln_plot =
  plot_tbl %>%
  filter(shortLetterCode=="TP") %>% 
  ggplot(aes(x = age_rec, y = exp)) +
  geom_violin(aes(fill = age_rec), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  scale_fill_manual(values = c("lightblue","blue", "orange", "red")) +
  labs(
    title = "Pathway Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(cell), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_tumor_cibersort_Age_rec_TCGA.pdf", height = 10, width = 16)
vln_plot
dev.off()



temp <- plot_tbl %>% filter(shortLetterCode=="TP")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_rec), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in colnames(cibersort_res)[1:22]) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = temp %>% filter(cell == module_name, age_rec == group1) %>%
      pull(exp)
    val_group2 = temp %>% filter(cell == module_name, age_rec == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(cell = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.tumor_cibersort_age_rec_TCGA.csv")










##Lung 
vln_plot =
  plot_tbl %>%
  filter(shortLetterCode=="NT") %>% 
  ggplot(aes(x = age_rec, y = exp)) +
  geom_violin(aes(fill = age_rec), scale = "width", color = NA) +
  geom_quasirandom(bandwidth = 0.8, color = "gray10", size = pt_size, alpha = 0.5) +
  geom_boxplot(width = box_width, color = "gray20", fill = "white", outlier.colour = NA, position = position_dodge(0.9)) +
  scale_fill_manual(values = c("skyblue", "darkblue", "orangered", "darkred"))+
  labs(
    title = "Pathway Scores",
    x = "Group",
    y = "Score"
  ) +
  theme_cowplot() +
  theme(
    plot.background = element_rect(fill = "white"),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    # axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.background = element_blank(), strip.placement = "outside",
    legend.title = element_blank()
    # panel.grid.major.y = element_line(colour = "gray50", linetype = "dotted")
  ) +
  facet_wrap(vars(cell), nrow = facet_rows, scales = "free", strip.position = "bottom")
#save_plot
vln_plot
pdf(file = "violin_plot_lung_cibersort_Age_rec_TCGA.pdf", height = 10, width = 16)
vln_plot
dev.off()







temp <- plot_tbl %>% filter(shortLetterCode=="NT")
#calculate p-values for all combinations of subtypes

group_combinations = combn(unique(temp$age_rec), m = 2, simplify = TRUE)

stats_tbl = tibble()
for (module_name in colnames(cibersort_res)[1:22]) {
  # scores_mat[module, ] = colMeans(scores_mat[modules_list[[module]], ])
  for (combination_num in 1:ncol(group_combinations)) {
    
    group1 = group_combinations[1, combination_num] %>% as.character()
    group2 = group_combinations[2, combination_num] %>% as.character()
    # message(glue("comparison : {group1} vs {group2}"))
    
    # calculate stats
    val_group1 = temp %>% filter(cell == module_name, age_rec == group1) %>%
      pull(exp)
    val_group2 = temp %>% filter(cell == module_name, age_rec == group2) %>%
      pull(exp)
    p_val = wilcox.test(x = val_group1, y = val_group2)$p.value
    if (is.na(p_val)) { p_val = 1 }
    if (p_val > 0.001) {
      p_val = round(p_val, 3)
    } else {
      p_val = scales::scientific(p_val, digits = 3)
    }
    # message(glue("p : {p_val}"))
    
    stats_tbl = stats_tbl %>%
      bind_rows(
        c(cell = module_name,
          min_val = round(min(val_group1, val_group2), 3),
          max_val = round(max(val_group1, val_group2), 3),
          group1 = group1,
          group2 = group2,
          group1_n = length(val_group1),
          group2_n = length(val_group2),
          group1_median = round(median(val_group1), 3),
          group2_median = round(median(val_group2), 3),
          p_val = p_val)
      )
    
  }
}

stats_tbl = stats_tbl %>%
  mutate_at(
    c("min_val", "max_val", "group1_n", "group2_n", "group1_median", "group2_median"),
    as.numeric
  )

write_csv(stats_tbl, "stats.lung_cibersrot_age_rec_TCGA.csv")











########### machine learning model for recurrence in each age group : NYU cohort ##########
##########random forest first#######

#### tumor subset, old patients####
# Load the required libraries
library(randomForest)
library(pROC)
library(caret)

# choose only genes with more than 200 counts in at elast 3 samples 
all_genes <- mycounts[apply(mycounts, 1, function(x) sum(x>=200)>=3),]

# select metadata 
meta <- RNA.data %>% data.frame(.) %>% filter(Sample_Type_Involved=="Lung.Tissue.In", 
                                              age_grp=="greater_70", 
                                              ProgType_Lab!="Secondary.Primary")


#get final genes 
genes <- all_genes %>% dplyr::select(rownames(meta))

# transform to log count
genes=apply(genes, 2, function(x) return(log(x+1)))

###############Run model
#transpose
genes.transposed <- as.data.frame(t(genes))

#get metadata 
metadata.for.RF <- meta

#define outcome 
outcome <- as.factor(metadata.for.RF$Progression)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

str(rf.data_complete)
#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

str(rf.data_complete)

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)

str(rf.data_complete)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)
# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich



#leave out genes with 0 value of Gini that don't affct the model (don't use filter, use slice to include that first 0 value )
#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::filter(Gini>0)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
Genes.1.per <- Gini %>% 
  dplyr::slice(1:round(0.01*nrow(Gini.100.per)))

#top 5%
Genes.5.per <- Gini %>% 
  dplyr::slice(1:round(0.05*nrow(Gini.100.per)))

#top 10%
Genes.10.per <- Gini %>% 
  dplyr::slice(1:round(0.1*nrow(Gini.100.per)))

#top 20%
Genes.20.per <- Gini %>% 
  dplyr::slice(1:round(0.2*nrow(Gini.100.per)))

#top 50%
Genes.50.per <- Gini %>% 
  dplyr::slice(1:round(0.5*nrow(Gini.100.per)))

#top 75%
Genes.75.per <- Gini %>% 
  dplyr::slice(1:round(0.75*nrow(Gini.100.per)))

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [nrow(Genes.1.per) :nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [nrow(Genes.5.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [nrow(Genes.10.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [nrow(Genes.20.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [nrow(Genes.50.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [nrow(Genes.75.per):nrow(Ginidf.to.save)] <- NA

write.csv(Ginidf.to.save, file = "RF_new/RF_results_tumor_old.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF_new/roc.plot_tumor_old_100_per.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_old_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_old_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_old_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_old_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_old_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_old_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()











# Old lung 
# select metadata 
meta <- RNA.data %>% data.frame(.) %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn", 
                                              age_grp=="greater_70", 
                                              ProgType_Lab!="Secondary.Primary")


#get final genes 
genes <- all_genes %>% dplyr::select(rownames(meta))

# transform to log count
genes=apply(genes, 2, function(x) return(log(x+1)))

###############Run model
#transpose
genes.transposed <- as.data.frame(t(genes))

#get metadata 
metadata.for.RF <- meta

#define outcome 
outcome <- as.factor(metadata.for.RF$Progression)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

str(rf.data_complete)
#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

str(rf.data_complete)

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)

str(rf.data_complete)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)
# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich



#leave out genes with 0 value of Gini that don't affct the model (don't use filter, use slice to include that first 0 value )
#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::filter(Gini>0)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
Genes.1.per <- Gini %>% 
  dplyr::slice(1:round(0.01*nrow(Gini.100.per)))

#top 5%
Genes.5.per <- Gini %>% 
  dplyr::slice(1:round(0.05*nrow(Gini.100.per)))

#top 10%
Genes.10.per <- Gini %>% 
  dplyr::slice(1:round(0.1*nrow(Gini.100.per)))

#top 20%
Genes.20.per <- Gini %>% 
  dplyr::slice(1:round(0.2*nrow(Gini.100.per)))

#top 50%
Genes.50.per <- Gini %>% 
  dplyr::slice(1:round(0.5*nrow(Gini.100.per)))

#top 75%
Genes.75.per <- Gini %>% 
  dplyr::slice(1:round(0.75*nrow(Gini.100.per)))

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [nrow(Genes.1.per) :nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [nrow(Genes.5.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [nrow(Genes.10.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [nrow(Genes.20.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [nrow(Genes.50.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [nrow(Genes.75.per):nrow(Ginidf.to.save)] <- NA

write.csv(Ginidf.to.save, file = "RF_new/RF_results_lung_old.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF_new/roc.plot_lung_old_100_per.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_old_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_old_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_old_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_old_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_old_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_old_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()






















#### tumor subset, young patients####
# Load the required libraries
library(randomForest)
library(pROC)
library(caret)

# choose only genes with more than 200 counts in at elast 3 samples 
all_genes <- mycounts[apply(mycounts, 1, function(x) sum(x>=200)>=3),]

# select metadata 
meta <- RNA.data %>% data.frame(.) %>% filter(Sample_Type_Involved=="Lung.Tissue.In", 
                                              age_grp=="less_equal_70", 
                                              ProgType_Lab!="Secondary.Primary")


#get final genes 
genes <- all_genes %>% dplyr::select(rownames(meta))

# transform to log count
genes=apply(genes, 2, function(x) return(log(x+1)))

###############Run model
#transpose
genes.transposed <- as.data.frame(t(genes))

#get metadata 
metadata.for.RF <- meta

#define outcome 
outcome <- as.factor(metadata.for.RF$Progression)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

str(rf.data_complete)
#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

str(rf.data_complete)

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)

str(rf.data_complete)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)
# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich



#leave out genes with 0 value of Gini that don't affct the model (don't use filter, use slice to include that first 0 value )
#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::filter(Gini>0)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
Genes.1.per <- Gini %>% 
  dplyr::slice(1:round(0.01*nrow(Gini.100.per)))

#top 5%
Genes.5.per <- Gini %>% 
  dplyr::slice(1:round(0.05*nrow(Gini.100.per)))

#top 10%
Genes.10.per <- Gini %>% 
  dplyr::slice(1:round(0.1*nrow(Gini.100.per)))

#top 20%
Genes.20.per <- Gini %>% 
  dplyr::slice(1:round(0.2*nrow(Gini.100.per)))

#top 50%
Genes.50.per <- Gini %>% 
  dplyr::slice(1:round(0.5*nrow(Gini.100.per)))

#top 75%
Genes.75.per <- Gini %>% 
  dplyr::slice(1:round(0.75*nrow(Gini.100.per)))

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [nrow(Genes.1.per) :nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [nrow(Genes.5.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [nrow(Genes.10.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [nrow(Genes.20.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [nrow(Genes.50.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [nrow(Genes.75.per):nrow(Ginidf.to.save)] <- NA

write.csv(Ginidf.to.save, file = "RF_new/RF_results_tumor_young.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF_new/roc.plot_tumor_young_100_per.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_young_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_young_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_young_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_young_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_young_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_young_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()











# young lung 
# select metadata 
meta <- RNA.data %>% data.frame(.) %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn", 
                                              age_grp=="less_equal_70", 
                                              ProgType_Lab!="Secondary.Primary")


#get final genes 
genes <- all_genes %>% dplyr::select(rownames(meta))

# transform to log count
genes=apply(genes, 2, function(x) return(log(x+1)))

###############Run model
#transpose
genes.transposed <- as.data.frame(t(genes))

#get metadata 
metadata.for.RF <- meta

#define outcome 
outcome <- as.factor(metadata.for.RF$Progression)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

str(rf.data_complete)
#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

str(rf.data_complete)

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)

str(rf.data_complete)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)
# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich



#leave out genes with 0 value of Gini that don't affct the model (don't use filter, use slice to include that first 0 value )
#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::filter(Gini>0)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
Genes.1.per <- Gini %>% 
  dplyr::slice(1:round(0.01*nrow(Gini.100.per)))

#top 5%
Genes.5.per <- Gini %>% 
  dplyr::slice(1:round(0.05*nrow(Gini.100.per)))

#top 10%
Genes.10.per <- Gini %>% 
  dplyr::slice(1:round(0.1*nrow(Gini.100.per)))

#top 20%
Genes.20.per <- Gini %>% 
  dplyr::slice(1:round(0.2*nrow(Gini.100.per)))

#top 50%
Genes.50.per <- Gini %>% 
  dplyr::slice(1:round(0.5*nrow(Gini.100.per)))

#top 75%
Genes.75.per <- Gini %>% 
  dplyr::slice(1:round(0.75*nrow(Gini.100.per)))

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [nrow(Genes.1.per) :nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [nrow(Genes.5.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [nrow(Genes.10.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [nrow(Genes.20.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [nrow(Genes.50.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [nrow(Genes.75.per):nrow(Ginidf.to.save)] <- NA

write.csv(Ginidf.to.save, file = "RF_new/RF_results_lung_young.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF_new/roc.plot_lung_young_100_per.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_young_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_young_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_young_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_young_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_young_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_young_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()





#######Plot AUC########
perc <- c(1, 5, 10, 20, 50, 75, 100)

#Combined plot
AUC_tumor_old <- c(0.54, 0.46, 0.57, 0.63, 0.57, 0.63, 0.61)
AUC_tumor_young <- c(0.85, 0.73, 0.36, 0.64, 0.76, 0.7,0.76)
AUC_lung_old <- c(0.77, 0.65, 0.75, 0.77, 0.8, 0.8 ,0.81)
AUC_lung_young <- c(0.79, 0.67, 0.75, 0.83, 0.75, 0.75,0.83)


AUC.df <- data.frame(perc, AUC_tumor_old, AUC_tumor_young, AUC_lung_old, AUC_lung_young)
AUC.df
colors <- c( "AUC_tumor_old" = "red", "AUC_tumor_young"="blue", "AUC_lung_old" = "darkred", "AUC_lung_young"="darkblue")

AUC.combined.plot <- ggplot(AUC.df, aes(x=perc))+
  geom_line(aes(y=AUC_tumor_old, color="AUC_tumor_old"))+
  geom_point(aes(y=AUC_tumor_old, color="AUC_tumor_old"))+
  geom_line(aes(y=AUC_tumor_young, color="AUC_tumor_young"))+
  geom_point(aes(y=AUC_tumor_young, color="AUC_tumor_young"))+
  geom_line(aes(y=AUC_lung_old, color="AUC_lung_old"))+
  geom_point(aes(y=AUC_lung_old, color="AUC_lung_old"))+
  geom_line(aes(y=AUC_lung_young, color="AUC_lung_young"))+
  geom_point(aes(y=AUC_lung_young, color="AUC_lung_young"))+
  scale_x_continuous(breaks = seq(0,100,10))+
  xlab("% Top Genes")+
  ylab("AUC")+
  labs(color="Legend")+
  scale_color_manual(values = colors)+
  ggtitle("AUC according to sample type at Genes level")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"),
        axis.text.y = element_text(size = 20, face = "bold"),
        axis.title.x = element_text(size = 26, face = "bold"),
        axis.title.y = element_text(size = 26, face = "bold"),
        legend.title = element_blank(),
        legend.text = element_text(size = 20),
        legend.position = "top")
#save 
pdf(file = "RF_new/AUC.combined.Genes.level.pdf", width = 12, height = 6)
AUC.combined.plot
dev.off()
















































############# RF model  while using upregulated genes in each group ############


#### tumor subset, old patients####
# Load the required libraries
library(randomForest)
library(pROC)
library(caret)

temp <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_tumor_no_second_primary.csv")
temp <- temp %>% filter(FDR<=0.2, logFC>0) %>% dplyr::select(Gene.symbol)

# choose only genes with more than 200 counts in at elast 3 samples 
all_genes <- mycounts[temp$Gene.symbol,]

# select metadata 
meta <- RNA.data %>% data.frame(.) %>% filter(Sample_Type_Involved=="Lung.Tissue.In", 
                                              age_grp=="greater_70", 
                                              ProgType_Lab!="Secondary.Primary")


#get final genes 
genes <- all_genes %>% dplyr::select(rownames(meta))

# transform to log count
genes=apply(genes, 2, function(x) return(log(x+1)))

###############Run model
#transpose
genes.transposed <- as.data.frame(t(genes))

#get metadata 
metadata.for.RF <- meta

#define outcome 
outcome <- as.factor(metadata.for.RF$Progression)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

str(rf.data_complete)
#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

str(rf.data_complete)

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)

str(rf.data_complete)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)
# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich



#leave out genes with 0 value of Gini that don't affct the model (don't use filter, use slice to include that first 0 value )
#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::filter(Gini>0)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
Genes.1.per <- Gini %>% 
  dplyr::slice(1:round(0.01*nrow(Gini.100.per)))

#top 5%
Genes.5.per <- Gini %>% 
  dplyr::slice(1:round(0.05*nrow(Gini.100.per)))

#top 10%
Genes.10.per <- Gini %>% 
  dplyr::slice(1:round(0.1*nrow(Gini.100.per)))

#top 20%
Genes.20.per <- Gini %>% 
  dplyr::slice(1:round(0.2*nrow(Gini.100.per)))

#top 50%
Genes.50.per <- Gini %>% 
  dplyr::slice(1:round(0.5*nrow(Gini.100.per)))

#top 75%
Genes.75.per <- Gini %>% 
  dplyr::slice(1:round(0.75*nrow(Gini.100.per)))

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [nrow(Genes.1.per) :nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [nrow(Genes.5.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [nrow(Genes.10.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [nrow(Genes.20.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [nrow(Genes.50.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [nrow(Genes.75.per):nrow(Ginidf.to.save)] <- NA

write.csv(Ginidf.to.save, file = "RF_new/RF_results_tumor_old_upreg.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF_new/roc.plot_tumor_old_100_per_upreg.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()











# Old lung 

temp <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_lung_no_second_primary.csv")
temp <- temp %>% filter(FDR<=0.2, logFC>0) %>% dplyr::select(Gene.symbol)

# choose only genes with more than 200 counts in at elast 3 samples 
all_genes <- mycounts[temp$Gene.symbol,]

# select metadata 
meta <- RNA.data %>% data.frame(.) %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn", 
                                              age_grp=="greater_70", 
                                              ProgType_Lab!="Secondary.Primary")


#get final genes 
genes <- all_genes %>% dplyr::select(rownames(meta))

# transform to log count
genes=apply(genes, 2, function(x) return(log(x+1)))

###############Run model
#transpose
genes.transposed <- as.data.frame(t(genes))

#get metadata 
metadata.for.RF <- meta

#define outcome 
outcome <- as.factor(metadata.for.RF$Progression)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

str(rf.data_complete)
#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

str(rf.data_complete)

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)

str(rf.data_complete)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)
# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich



#leave out genes with 0 value of Gini that don't affct the model (don't use filter, use slice to include that first 0 value )
#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::filter(Gini>0)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
Genes.1.per <- Gini %>% 
  dplyr::slice(1:round(0.01*nrow(Gini.100.per)))

#top 5%
Genes.5.per <- Gini %>% 
  dplyr::slice(1:round(0.05*nrow(Gini.100.per)))

#top 10%
Genes.10.per <- Gini %>% 
  dplyr::slice(1:round(0.1*nrow(Gini.100.per)))

#top 20%
Genes.20.per <- Gini %>% 
  dplyr::slice(1:round(0.2*nrow(Gini.100.per)))

#top 50%
Genes.50.per <- Gini %>% 
  dplyr::slice(1:round(0.5*nrow(Gini.100.per)))

#top 75%
Genes.75.per <- Gini %>% 
  dplyr::slice(1:round(0.75*nrow(Gini.100.per)))

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [nrow(Genes.1.per) :nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [nrow(Genes.5.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [nrow(Genes.10.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [nrow(Genes.20.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [nrow(Genes.50.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [nrow(Genes.75.per):nrow(Ginidf.to.save)] <- NA

write.csv(Ginidf.to.save, file = "RF_new/RF_results_lung_old_upregu.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF_new/roc.plot_lung_old_100_per_upregu.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()













temp <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_tumor_no_second_primary.csv")
temp <- temp %>% filter(FDR<=0.2, logFC>0) %>% dplyr::select(Gene.symbol)

# choose only genes with more than 200 counts in at elast 3 samples 
all_genes <- mycounts[temp$Gene.symbol,]

# select metadata 
meta <- RNA.data %>% data.frame(.) %>% filter(Sample_Type_Involved=="Lung.Tissue.In", 
                                              age_grp=="less_equal_70", 
                                              ProgType_Lab!="Secondary.Primary")


#get final genes 
genes <- all_genes %>% dplyr::select(rownames(meta))

# transform to log count
genes=apply(genes, 2, function(x) return(log(x+1)))

###############Run model
#transpose
genes.transposed <- as.data.frame(t(genes))

#get metadata 
metadata.for.RF <- meta

#define outcome 
outcome <- as.factor(metadata.for.RF$Progression)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

str(rf.data_complete)
#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

str(rf.data_complete)

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)

str(rf.data_complete)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)
# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich



#leave out genes with 0 value of Gini that don't affct the model (don't use filter, use slice to include that first 0 value )
#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::filter(Gini>0)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
Genes.1.per <- Gini %>% 
  dplyr::slice(1:round(0.01*nrow(Gini.100.per)))

#top 5%
Genes.5.per <- Gini %>% 
  dplyr::slice(1:round(0.05*nrow(Gini.100.per)))

#top 10%
Genes.10.per <- Gini %>% 
  dplyr::slice(1:round(0.1*nrow(Gini.100.per)))

#top 20%
Genes.20.per <- Gini %>% 
  dplyr::slice(1:round(0.2*nrow(Gini.100.per)))

#top 50%
Genes.50.per <- Gini %>% 
  dplyr::slice(1:round(0.5*nrow(Gini.100.per)))

#top 75%
Genes.75.per <- Gini %>% 
  dplyr::slice(1:round(0.75*nrow(Gini.100.per)))

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [nrow(Genes.1.per) :nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [nrow(Genes.5.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [nrow(Genes.10.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [nrow(Genes.20.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [nrow(Genes.50.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [nrow(Genes.75.per):nrow(Ginidf.to.save)] <- NA

write.csv(Ginidf.to.save, file = "RF_new/RF_results_tumor_young_upreg.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF_new/roc.plot_tumor_young_100_per_upreg.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.tumor_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()











# young lung 

temp <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_lung_no_second_primary.csv")
temp <- temp %>% filter(FDR<=0.2, logFC>0) %>% dplyr::select(Gene.symbol)

# choose only genes with more than 200 counts in at elast 3 samples 
all_genes <- mycounts[temp$Gene.symbol,]

# select metadata 
meta <- RNA.data %>% data.frame(.) %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn", 
                                              age_grp=="less_equal_70", 
                                              ProgType_Lab!="Secondary.Primary")


#get final genes 
genes <- all_genes %>% dplyr::select(rownames(meta))

# transform to log count
genes=apply(genes, 2, function(x) return(log(x+1)))

###############Run model
#transpose
genes.transposed <- as.data.frame(t(genes))

#get metadata 
metadata.for.RF <- meta

#define outcome 
outcome <- as.factor(metadata.for.RF$Progression)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

str(rf.data_complete)
#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

str(rf.data_complete)

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)

str(rf.data_complete)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)
# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich



#leave out genes with 0 value of Gini that don't affct the model (don't use filter, use slice to include that first 0 value )
#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::filter(Gini>0)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
Genes.1.per <- Gini %>% 
  dplyr::slice(1:round(0.01*nrow(Gini.100.per)))

#top 5%
Genes.5.per <- Gini %>% 
  dplyr::slice(1:round(0.05*nrow(Gini.100.per)))

#top 10%
Genes.10.per <- Gini %>% 
  dplyr::slice(1:round(0.1*nrow(Gini.100.per)))

#top 20%
Genes.20.per <- Gini %>% 
  dplyr::slice(1:round(0.2*nrow(Gini.100.per)))

#top 50%
Genes.50.per <- Gini %>% 
  dplyr::slice(1:round(0.5*nrow(Gini.100.per)))

#top 75%
Genes.75.per <- Gini %>% 
  dplyr::slice(1:round(0.75*nrow(Gini.100.per)))

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [nrow(Genes.1.per) :nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [nrow(Genes.5.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [nrow(Genes.10.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [nrow(Genes.20.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [nrow(Genes.50.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [nrow(Genes.75.per):nrow(Ginidf.to.save)] <- NA

write.csv(Ginidf.to.save, file = "RF_new/RF_results_lung_young_upregu.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF_new/roc.plot_lung_young_100_per_upregu.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$X1

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/roc.plot.lung_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()







#######Plot AUC########
perc <- c(1, 5, 10, 20, 50, 75, 100)

#Combined plot
AUC_tumor_old <- c(0.67, 0.69, 0.77, 0.86, 0.83, 0.86,0.83)
AUC_lung_old <- c(0.8, 0.65, 0.72, 0.84, 0.8, 0.85 ,0.92)
AUC_tumor_young <- c(0.61, 0.45, 0.61, 0.58, 0.67, 0.64 ,0.76)
AUC_lung_young <- c(0.58, 0.62, 0.67, 0.67, 0.58, 0.54 ,0.54)


AUC.df <- data.frame(perc, AUC_tumor_old, AUC_tumor_young, AUC_lung_old, AUC_lung_young)
AUC.df
colors <- c("AUC_tumor_old" = "red", "AUC_tumor_young"="blue", "AUC_lung_old" = "darkred", "AUC_lung_young"="darkblue")
shapes <- c("AUC_tumor_old" = 1, "AUC_tumor_young"=1, "AUC_lung_old" = 2, "AUC_lung_young"=2)

AUC.combined.plot <- ggplot(AUC.df, aes(x=perc))+
  geom_line(aes(y=AUC_tumor_old, color="AUC_tumor_old"))+
  geom_point(aes(y=AUC_tumor_old, color="AUC_tumor_old", shape="AUC_tumor_old" ))+
  geom_line(aes(y=AUC_tumor_young, color="AUC_tumor_young"))+
  geom_point(aes(y=AUC_tumor_young, color="AUC_tumor_young", shape="AUC_tumor_young"))+
  geom_line(aes(y=AUC_lung_old, color="AUC_lung_old"))+
  geom_point(aes(y=AUC_lung_old, color="AUC_lung_old", shape="AUC_lung_old"))+
  geom_line(aes(y=AUC_lung_young, color="AUC_lung_young"))+
  geom_point(aes(y=AUC_lung_young, color="AUC_lung_young", shape="AUC_lung_young"))+
  scale_x_continuous(breaks = seq(0,100,10))+
  xlab("% Top Genes")+
  ylim(c(0.4,1))+
  ylab("AUC")+
  labs(color="Legend")+
  scale_color_manual(values = colors)+
  scale_shape_manual(values = shapes)+
  ggtitle("AUC according to sample type at Genes level")+
  guides(shape="none")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"),
        axis.text.y = element_text(size = 20, face = "bold"),
        axis.title.x = element_text(size = 26, face = "bold"),
        axis.title.y = element_text(size = 26, face = "bold"),
        legend.title = element_blank(),
        legend.text = element_text(size = 20),
        legend.position = "top")
#save 
pdf(file = "RF_new/AUC.combined.Genes.level_upregu.pdf", width = 12, height = 6)
AUC.combined.plot
dev.off()


#another figure with different colors for ATS

colors <- c("AUC_tumor_old" = "red", "AUC_tumor_young"="blue", "AUC_lung_old" = "orange", "AUC_lung_young"="green3")
shapes <- c("AUC_tumor_old" = 1, "AUC_tumor_young"=1, "AUC_lung_old" = 2, "AUC_lung_young"=2)

AUC.combined.plot <- ggplot(AUC.df, aes(x=perc))+
  geom_line(aes(y=AUC_tumor_old, color="AUC_tumor_old"))+
  geom_point(aes(y=AUC_tumor_old, color="AUC_tumor_old", shape="AUC_tumor_old" ))+
  geom_line(aes(y=AUC_tumor_young, color="AUC_tumor_young"))+
  geom_point(aes(y=AUC_tumor_young, color="AUC_tumor_young", shape="AUC_tumor_young"))+
  geom_line(aes(y=AUC_lung_old, color="AUC_lung_old"))+
  geom_point(aes(y=AUC_lung_old, color="AUC_lung_old", shape="AUC_lung_old"))+
  geom_line(aes(y=AUC_lung_young, color="AUC_lung_young"))+
  geom_point(aes(y=AUC_lung_young, color="AUC_lung_young", shape="AUC_lung_young"))+
  scale_x_continuous(breaks = seq(0,100,10))+
  xlab("% Top Genes")+
  ylim(c(0.4,1))+
  ylab("AUC")+
  labs(color="Legend")+
  scale_color_manual(values = colors)+
  scale_shape_manual(values = shapes)+
  ggtitle("AUC according to sample type at Genes level")+
  guides(shape="none")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"),
        axis.text.y = element_text(size = 20, face = "bold"),
        axis.title.x = element_text(size = 26, face = "bold"),
        axis.title.y = element_text(size = 26, face = "bold"),
        legend.title = element_blank(),
        legend.text = element_text(size = 20),
        legend.position = "top")
#save 
pdf(file = "RF_new/AUC.combined.Genes.level_upregu_for_ATS_dif_colors.pdf", width = 12, height = 6)
AUC.combined.plot
dev.off()


































########### random forest TCGa COHORT of upregulated genes in edgeR########








#### tumor subset, old patients###
# Load the required libraries
library(randomForest)
library(pROC)
library(caret)

temp <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")
temp <- temp %>% filter(FDR<=0.2, logFC>0) %>% dplyr::select(Gene.symbol)

# choose only genes with more than 200 counts in at elast 3 samples 
all_genes <- tcga_counts_stage_I_no_NA[temp$Gene.symbol,]

# select metadata 
meta <- tcga_metadata_stage_I_no_NA %>% data.frame(.) %>% filter(definition=="Primary solid Tumor", 
                                                                 age_grp_new=="greater_70")


#get final genes 
genes <- all_genes %>% dplyr::select(rownames(meta))

# transform to log count
genes=apply(genes, 2, function(x) return(log(x+1)))

###############Run model
#transpose
genes.transposed <- as.data.frame(t(genes))

#get metadata 
metadata.for.RF <- meta

#define outcome 
outcome <- as.factor(metadata.for.RF$DFS_STATUS)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

str(rf.data_complete)
#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

str(rf.data_complete)

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)

str(rf.data_complete)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)
# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich



#leave out genes with 0 value of Gini that don't affct the model (don't use filter, use slice to include that first 0 value )
#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::filter(Gini>0)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
Genes.1.per <- Gini %>% 
  dplyr::slice(1:round(0.01*nrow(Gini.100.per)))

#top 5%
Genes.5.per <- Gini %>% 
  dplyr::slice(1:round(0.05*nrow(Gini.100.per)))

#top 10%
Genes.10.per <- Gini %>% 
  dplyr::slice(1:round(0.1*nrow(Gini.100.per)))

#top 20%
Genes.20.per <- Gini %>% 
  dplyr::slice(1:round(0.2*nrow(Gini.100.per)))

#top 50%
Genes.50.per <- Gini %>% 
  dplyr::slice(1:round(0.5*nrow(Gini.100.per)))

#top 75%
Genes.75.per <- Gini %>% 
  dplyr::slice(1:round(0.75*nrow(Gini.100.per)))

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [nrow(Genes.1.per) :nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [nrow(Genes.5.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [nrow(Genes.10.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [nrow(Genes.20.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [nrow(Genes.50.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [nrow(Genes.75.per):nrow(Ginidf.to.save)] <- NA

write.csv(Ginidf.to.save, file = "RF_new/TCGA/TCGA_RF_results_tumor_old_upreg.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF_new/TCGA/TCGA_roc.plot_tumor_old_100_per_upreg.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.tumor_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.tumor_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.tumor_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.tumor_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.tumor_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.tumor_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()











# Old lung 

temp <- read.csv(file = "Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")
temp <- temp %>% filter(FDR<=0.2, logFC>0) %>% dplyr::select(Gene.symbol)

# choose only genes with more than 200 counts in at elast 3 samples 
all_genes <- tcga_counts_stage_I_no_NA[temp$Gene.symbol,]

# select metadata 
meta <- tcga_metadata_stage_I_no_NA %>% data.frame(.) %>% filter(definition=="Solid Tissue Normal", 
                                                                 age_grp_new=="greater_70")


#get final genes 
genes <- all_genes %>% dplyr::select(rownames(meta))

# transform to log count
genes=apply(genes, 2, function(x) return(log(x+1)))

###############Run model
#transpose
genes.transposed <- as.data.frame(t(genes))

#get metadata 
metadata.for.RF <- meta

#define outcome 
outcome <- as.factor(metadata.for.RF$DFS_STATUS)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

str(rf.data_complete)
#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

str(rf.data_complete)

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)

str(rf.data_complete)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)
# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich



#leave out genes with 0 value of Gini that don't affct the model (don't use filter, use slice to include that first 0 value )
#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::filter(Gini>0)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
Genes.1.per <- Gini %>% 
  dplyr::slice(1:round(0.01*nrow(Gini.100.per)))

#top 5%
Genes.5.per <- Gini %>% 
  dplyr::slice(1:round(0.05*nrow(Gini.100.per)))

#top 10%
Genes.10.per <- Gini %>% 
  dplyr::slice(1:round(0.1*nrow(Gini.100.per)))

#top 20%
Genes.20.per <- Gini %>% 
  dplyr::slice(1:round(0.2*nrow(Gini.100.per)))

#top 50%
Genes.50.per <- Gini %>% 
  dplyr::slice(1:round(0.5*nrow(Gini.100.per)))

#top 75%
Genes.75.per <- Gini %>% 
  dplyr::slice(1:round(0.75*nrow(Gini.100.per)))

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [nrow(Genes.1.per) :nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [nrow(Genes.5.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [nrow(Genes.10.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [nrow(Genes.20.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [nrow(Genes.50.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [nrow(Genes.75.per):nrow(Ginidf.to.save)] <- NA

write.csv(Ginidf.to.save, file = "RF_new/TCGA/TCGA_RF_results_lung_old_upregu.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF_new/TCGA/TCGA_roc.plot_lung_old_100_per_upregu.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.lung_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.lung_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.lung_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.lung_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.lung_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.lung_old_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()













#### tumor subset, young patients###
# Load the required libraries
library(randomForest)
library(pROC)
library(caret)

temp <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")
temp <- temp %>% filter(FDR<=0.2, logFC>0) %>% dplyr::select(Gene.symbol)

# choose only genes with more than 200 counts in at elast 3 samples 
all_genes <- tcga_counts_stage_I_no_NA[temp$Gene.symbol,]

# select metadata 
meta <- tcga_metadata_stage_I_no_NA %>% data.frame(.) %>% filter(definition=="Primary solid Tumor", 
                                                                 age_grp_new=="greater_70")


#get final genes 
genes <- all_genes %>% dplyr::select(rownames(meta))

# transform to log count
genes=apply(genes, 2, function(x) return(log(x+1)))

###############Run model
#transpose
genes.transposed <- as.data.frame(t(genes))

#get metadata 
metadata.for.RF <- meta

#define outcome 
outcome <- as.factor(metadata.for.RF$DFS_STATUS)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

str(rf.data_complete)
#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

str(rf.data_complete)

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)

str(rf.data_complete)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)
# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich



#leave out genes with 0 value of Gini that don't affct the model (don't use filter, use slice to include that first 0 value )
#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::filter(Gini>0)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
Genes.1.per <- Gini %>% 
  dplyr::slice(1:round(0.01*nrow(Gini.100.per)))

#top 5%
Genes.5.per <- Gini %>% 
  dplyr::slice(1:round(0.05*nrow(Gini.100.per)))

#top 10%
Genes.10.per <- Gini %>% 
  dplyr::slice(1:round(0.1*nrow(Gini.100.per)))

#top 20%
Genes.20.per <- Gini %>% 
  dplyr::slice(1:round(0.2*nrow(Gini.100.per)))

#top 50%
Genes.50.per <- Gini %>% 
  dplyr::slice(1:round(0.5*nrow(Gini.100.per)))

#top 75%
Genes.75.per <- Gini %>% 
  dplyr::slice(1:round(0.75*nrow(Gini.100.per)))

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [nrow(Genes.1.per) :nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [nrow(Genes.5.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [nrow(Genes.10.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [nrow(Genes.20.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [nrow(Genes.50.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [nrow(Genes.75.per):nrow(Ginidf.to.save)] <- NA

write.csv(Ginidf.to.save, file = "RF_new/TCGA/TCGA_RF_results_tumor_young_upreg.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF_new/TCGA/TCGA_roc.plot_tumor_young_100_per_upreg.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.tumor_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.tumor_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.tumor_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.tumor_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.tumor_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.tumor_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()











# young lung 

temp <- read.csv(file = "Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")
temp <- temp %>% filter(FDR<=0.2, logFC>0) %>% dplyr::select(Gene.symbol)

# choose only genes with more than 200 counts in at elast 3 samples 
all_genes <- tcga_counts_stage_I_no_NA[temp$Gene.symbol,]

# select metadata 
meta <- tcga_metadata_stage_I_no_NA %>% data.frame(.) %>% filter(definition=="Solid Tissue Normal", 
                                                                 age_grp_new=="greater_70")


#get final genes 
genes <- all_genes %>% dplyr::select(rownames(meta))

# transform to log count
genes=apply(genes, 2, function(x) return(log(x+1)))

###############Run model
#transpose
genes.transposed <- as.data.frame(t(genes))

#get metadata 
metadata.for.RF <- meta

#define outcome 
outcome <- as.factor(metadata.for.RF$DFS_STATUS)

#build a data frame 
rf.data_complete <- data.frame(genes.transposed, outcome)

str(rf.data_complete)
#prepare data 
#remove na 
rf.data_complete <- rf.data_complete %>% 
  drop_na()

str(rf.data_complete)

#be sure data is numerical 
lapply(rf.data_complete, as.integer)

#replace infinite data 
rf.data_complete[mapply(is.infinite, rf.data_complete)] <- NA

rf.data_complete <- rf.data_complete %>% 
  mutate_if(is.character, as.factor)

str(rf.data_complete)


# Split the data into training and testing sets
set.seed(1234)
train_index <- sample(nrow(rf.data_complete), 0.8 * nrow(rf.data_complete))
train_data <- rf.data_complete[train_index, ]
test_data <- rf.data_complete[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data_complete))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get variable importance 
# Extract the mean decrease impurity (MDI) values for each feature
mdi <- randomForest::importance(fit)
mdi <- mdi %>% 
  data.frame() %>% 
  dplyr::select(MeanDecreaseGini)
# Normalize the MDI values
Gini <- mdi %>% 
  dplyr::mutate(Norm.Gini= MeanDecreaseGini/sum(MeanDecreaseGini)) %>% 
  dplyr::mutate(Gini = Norm.Gini/max(Norm.Gini)) %>% 
  dplyr::arrange(desc(Gini)) %>% 
  dplyr::select(Gini)


#add enrich group (or outcome)
gene.means <- by(t(genes), outcome, colMeans)
gene.means <- do.call(cbind, gene.means)
idx_enrich <- apply(gene.means, 1, which.max)
group_enrich <- colnames(gene.means)[idx_enrich]

Gini$enrich_group <- group_enrich



#leave out genes with 0 value of Gini that don't affct the model (don't use filter, use slice to include that first 0 value )
#leave out genes with 0 value of Gini that don't affct the model (need to change every time you run it)
Gini.100.per<- Gini %>% 
  dplyr::filter(Gini>0)

#from here subset genes of increasing percentage so you will use later to fit the model 

#top 1%
Genes.1.per <- Gini %>% 
  dplyr::slice(1:round(0.01*nrow(Gini.100.per)))

#top 5%
Genes.5.per <- Gini %>% 
  dplyr::slice(1:round(0.05*nrow(Gini.100.per)))

#top 10%
Genes.10.per <- Gini %>% 
  dplyr::slice(1:round(0.1*nrow(Gini.100.per)))

#top 20%
Genes.20.per <- Gini %>% 
  dplyr::slice(1:round(0.2*nrow(Gini.100.per)))

#top 50%
Genes.50.per <- Gini %>% 
  dplyr::slice(1:round(0.5*nrow(Gini.100.per)))

#top 75%
Genes.75.per <- Gini %>% 
  dplyr::slice(1:round(0.75*nrow(Gini.100.per)))

#Finally get one df to export 
Ginidf.to.save <- Gini %>% 
  dplyr::mutate(one_per = Gini) %>% 
  dplyr::mutate(five_per = Gini) %>% 
  dplyr::mutate(ten_per = Gini) %>% 
  dplyr::mutate(twent_per = Gini) %>% 
  dplyr::mutate(fifty_per = Gini) %>% 
  dplyr::mutate(sevent_fiv_per = Gini) %>% 
  dplyr::mutate(one_hund = Gini) %>% 
  dplyr::select(-Gini)
#replace with NA in each column 
nrow(Ginidf.to.save)
Ginidf.to.save$one_per [nrow(Genes.1.per) :nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$five_per [nrow(Genes.5.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$ten_per [nrow(Genes.10.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$twent_per [nrow(Genes.20.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$fifty_per [nrow(Genes.50.per):nrow(Ginidf.to.save)] <- NA
Ginidf.to.save$sevent_fiv_per [nrow(Genes.75.per):nrow(Ginidf.to.save)] <- NA

write.csv(Ginidf.to.save, file = "RF_new/TCGA/TCGA_RF_results_lung_young_upregu.csv")

######get ROC plor and AUC
#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = "RF_new/TCGA/TCGA_roc.plot_lung_young_100_per_upregu.pdf", height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 1%####
n <- 1

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.1.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.lung_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 5%####
n <- 5

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.5.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.lung_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 10%####
n <- 10

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.10.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.lung_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()



####repeat model for 20%####
n <- 20

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.20.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.lung_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()


####repeat model for 50%####
n <- 50

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.50.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.lung_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()




####repeat model for 75%####
n <- 75

# Split the data into training and testing sets
rf.data <- rf.data_complete %>% 
  dplyr::select(., rownames(Genes.75.per), outcome)

set.seed(1234)
train_index <- sample(nrow(rf.data), 0.8 * nrow(rf.data))
train_data <- rf.data[train_index, ]
test_data <- rf.data[-train_index, ]

#tune 
mtry <- sqrt(ncol(rf.data))
tunegrid <- expand.grid(.mtry=mtry)
metric <- "ROC"
control <- trainControl(method = 'repeatedcv', number = 10, repeats = 2, search = 'random', savePredictions = TRUE, sampling = NULL, classProbs = TRUE)

######### 
#run the model
set.seed(1234)

fit <- randomForest(outcome~., data = train_data, trControl=control, metric=metric, 
                    ntree=500, preProcess=c("BoxCox"), importance=TRUE, scale=TRUE)

#get predictions 
predictions <- predict(fit, newdata = test_data[,-ncol(test_data)], type = "prob")
predictions <- data.frame(predictions)

#extract prediciton of. the outcome of interset (recurrence in this case)
predictions <- predictions$Recurrence

#build ROC object 
roc <- roc(test_data[, ncol(test_data)], predictions)

library(pROC)
#using ggplot 
roc.df <- data.frame(roc$sensitivities, roc$specificities, roc$thresholds)

roc.plot <- roc.df %>%
  arrange(roc.thresholds) %>%
  ggplot() +
  geom_path(aes(x=1 - roc.specificities, y=roc.sensitivities)) + # connect the points in the order in which they appear in the data to form a curve
  geom_abline(intercept = 0, slope = 1, linetype = "dotted") + # add a reference line by convention
  coord_equal()+
  xlab("1- Specificity")+ ylab("Sensitivity")+
  theme_bw()+
  ggtitle(paste0("AUC = ", paste0(round(roc$auc,2))))

pdf(roc.plot, file = paste0("RF_new/TCGA/TCGA_roc.plot.lung_young_upregu_", paste0(n, paste0("_per.pdf"))), height = 8, width = 8)
roc.plot
dev.off()






### plot AUC for tumor only of TCGA cohort #### 
perc <- c(1, 5, 10, 20, 50, 75, 100)

#Combined plot
AUC_tumor_old <- c(0.67, 0.69, 0.77, 0.86, 0.83, 0.86,0.83)
#AUC_lung_old <- c(0.8, 0.65, 0.72, 0.84, 0.8, 0.85 ,0.92)
AUC_tumor_young <- c(0.61, 0.45, 0.61, 0.58, 0.67, 0.64 ,0.76)
#AUC_lung_young <- c(0.58, 0.62, 0.67, 0.67, 0.58, 0.54 ,0.54)


AUC.df <- data.frame(perc, AUC_tumor_old, AUC_tumor_young)
AUC.df
colors <- c("AUC_tumor_old" = "red", "AUC_tumor_young"="blue")
shapes <- c("AUC_tumor_old" = 1, "AUC_tumor_young"=1, "AUC_lung_old" = 2, "AUC_lung_young"=2)

AUC.combined.plot <- ggplot(AUC.df, aes(x=perc))+
  geom_line(aes(y=AUC_tumor_old, color="AUC_tumor_old"))+
  geom_point(aes(y=AUC_tumor_old, color="AUC_tumor_old", shape="AUC_tumor_old" ))+
  geom_line(aes(y=AUC_tumor_young, color="AUC_tumor_young"))+
  geom_point(aes(y=AUC_tumor_young, color="AUC_tumor_young", shape="AUC_tumor_young"))+
  #geom_line(aes(y=AUC_lung_old, color="AUC_lung_old"))+
  #geom_point(aes(y=AUC_lung_old, color="AUC_lung_old", shape="AUC_lung_old"))+
  #geom_line(aes(y=AUC_lung_young, color="AUC_lung_young"))+
  #geom_point(aes(y=AUC_lung_young, color="AUC_lung_young", shape="AUC_lung_young"))+
  scale_x_continuous(breaks = seq(0,100,10))+
  ylim(c(0.4,1))+
  xlab("% Top Genes")+
  ylab("AUC")+
  labs(color="Legend")+
  scale_color_manual(values = colors)+
  scale_shape_manual(values = shapes)+
  ggtitle("AUC according to sample type at Genes level")+
  guides(shape="none")+
  theme_bw()+
  theme(axis.text.x = element_text(size = 20, face = "bold"),
        axis.text.y = element_text(size = 20, face = "bold"),
        axis.title.x = element_text(size = 26, face = "bold"),
        axis.title.y = element_text(size = 26, face = "bold"),
        legend.title = element_blank(),
        legend.text = element_text(size = 20),
        legend.position = "top")
#save 
pdf(file = "RF_new/TCGA/TCGA_AUC.combined.Genes.level_upregu.pdf", width = 12, height = 6)
AUC.combined.plot
dev.off()






















####################### GSEA anslysis ################# 

##### get NYU file 
res <- read.csv(file = "Results/RNA/edgeR.results_age_grp_tumor_no_second_primary.csv")

#cerate preranked list and export 
x <-
  res %>% 
  dplyr::filter(!is.na(FDR)) 
x$fcSign<-sign(x$logFC)
x$logP   <- -log10(x$FDR)
x$metric <- x$logP/x$fcSign

y<-x %>% 
  dplyr::select(Gene.symbol, metric) %>% 
  dplyr::rename(SYMBOL=Gene.symbol)
baseline.rnk=y
write_tsv(y, file= paste0("Results/RNA/GSEA/", paste0("GSEA_edgeR_",paste0("_tumor_old_vs_young.rnk"))), col_names=FALSE)




##### get NYU file 
res <- read.csv(file = "Results/RNA/edgeR.results_age_grp_lung_no_second_primary.csv")

#cerate preranked list and export 
x <-
  res %>% 
  dplyr::filter(!is.na(FDR)) 
x$fcSign<-sign(x$logFC)
x$logP   <- -log10(x$FDR)
x$metric <- x$logP/x$fcSign

y<-x %>% 
  dplyr::select(Gene.symbol, metric) %>% 
  dplyr::rename(SYMBOL=Gene.symbol)
baseline.rnk=y
write_tsv(y, file= paste0("Results/RNA/GSEA/", paste0("GSEA_edgeR_",paste0("_lung_old_vs_young.rnk"))), col_names=FALSE)




##### get NYU file 
res <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_tumor_no_second_primary.csv")

#cerate preranked list and export 
x <-
  res %>% 
  dplyr::filter(!is.na(FDR)) 
x$fcSign<-sign(x$logFC)
x$logP   <- -log10(x$FDR)
x$metric <- x$logP/x$fcSign

y<-x %>% 
  dplyr::select(Gene.symbol, metric) %>% 
  dplyr::rename(SYMBOL=Gene.symbol)
baseline.rnk=y
write_tsv(y, file= paste0("Results/RNA/GSEA/", paste0("GSEA_edgeR_",paste0("_tumor_old_rec_vs_norec.rnk"))), col_names=FALSE)


##### get NYU file 
res <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_tumor_no_second_primary.csv")

#cerate preranked list and export 
x <-
  res %>% 
  dplyr::filter(!is.na(FDR)) 
x$fcSign<-sign(x$logFC)
x$logP   <- -log10(x$FDR)
x$metric <- x$logP/x$fcSign

y<-x %>% 
  dplyr::select(Gene.symbol, metric) %>% 
  dplyr::rename(SYMBOL=Gene.symbol)
baseline.rnk=y
write_tsv(y, file= paste0("Results/RNA/GSEA/", paste0("GSEA_edgeR_",paste0("_tumor_young_rec_vs_norec.rnk"))), col_names=FALSE)



##### get NYU file 
res <- read.csv(file = "Results/RNA/edgeR.results_young_rec_vs_no_rec_lung_no_second_primary.csv")

#cerate preranked list and export 
x <-
  res %>% 
  dplyr::filter(!is.na(FDR)) 
x$fcSign<-sign(x$logFC)
x$logP   <- -log10(x$FDR)
x$metric <- x$logP/x$fcSign

y<-x %>% 
  dplyr::select(Gene.symbol, metric) %>% 
  dplyr::rename(SYMBOL=Gene.symbol)
baseline.rnk=y
write_tsv(y, file= paste0("Results/RNA/GSEA/", paste0("GSEA_edgeR_",paste0("_lung_young_rec_vs_norec.rnk"))), col_names=FALSE)



##### get NYU file 
res <- read.csv(file = "Results/RNA/edgeR.results_old_rec_vs_no_rec_lung_no_second_primary.csv")

#cerate preranked list and export 
x <-
  res %>% 
  dplyr::filter(!is.na(FDR)) 
x$fcSign<-sign(x$logFC)
x$logP   <- -log10(x$FDR)
x$metric <- x$logP/x$fcSign

y<-x %>% 
  dplyr::select(Gene.symbol, metric) %>% 
  dplyr::rename(SYMBOL=Gene.symbol)
baseline.rnk=y
write_tsv(y, file= paste0("Results/RNA/GSEA/", paste0("GSEA_edgeR_",paste0("_lung_old_rec_vs_norec.rnk"))), col_names=FALSE)





##########TCGA 


##### get TCGA file 
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_age_grp_new.csv")

#cerate preranked list and export 
x <-
  res %>% 
  dplyr::filter(!is.na(FDR)) 
x$fcSign<-sign(x$logFC)
x$logP   <- -log10(x$FDR)
x$metric <- x$logP/x$fcSign

y<-x %>% 
  dplyr::select(Gene.symbol, metric) %>% 
  dplyr::rename(SYMBOL=Gene.symbol)
baseline.rnk=y
write_tsv(y, file= paste0("Results/RNA/GSEA/", paste0("GSEA_edgeR_",paste0("_tumor_old_vs_young_TCGA.rnk"))), col_names=FALSE)




##### get TCGA file 
res <- read.csv(file = "Results/RNA/edgeR.results_lung_stage_I_TCGA_age_grp_new.csv")

#cerate preranked list and export 
x <-
  res %>% 
  dplyr::filter(!is.na(FDR)) 
x$fcSign<-sign(x$logFC)
x$logP   <- -log10(x$FDR)
x$metric <- x$logP/x$fcSign

y<-x %>% 
  dplyr::select(Gene.symbol, metric) %>% 
  dplyr::rename(SYMBOL=Gene.symbol)
baseline.rnk=y
write_tsv(y, file= paste0("Results/RNA/GSEA/", paste0("GSEA_edgeR_",paste0("_lung_old_vs_young_TCGA.rnk"))), col_names=FALSE)




##### get TCGA file 
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")

#cerate preranked list and export 
x <-
  res %>% 
  dplyr::filter(!is.na(FDR)) 
x$fcSign<-sign(x$logFC)
x$logP   <- -log10(x$FDR)
x$metric <- x$logP/x$fcSign

y<-x %>% 
  dplyr::select(Gene.symbol, metric) %>% 
  dplyr::rename(SYMBOL=Gene.symbol)
baseline.rnk=y
write_tsv(y, file= paste0("Results/RNA/GSEA/", paste0("GSEA_edgeR_",paste0("_tumor_old_rec_vs_norec_TCGA.rnk"))), col_names=FALSE)


##### get TCGA file 
res <- read.csv(file = "Results/RNA/edgeR.results_tumor_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")

#cerate preranked list and export 
x <-
  res %>% 
  dplyr::filter(!is.na(FDR)) 
x$fcSign<-sign(x$logFC)
x$logP   <- -log10(x$FDR)
x$metric <- x$logP/x$fcSign

y<-x %>% 
  dplyr::select(Gene.symbol, metric) %>% 
  dplyr::rename(SYMBOL=Gene.symbol)
baseline.rnk=y
write_tsv(y, file= paste0("Results/RNA/GSEA/", paste0("GSEA_edgeR_",paste0("_tumor_young_rec_vs_norec_TCGA.rnk"))), col_names=FALSE)



##### get TCGA file 
res <- read.csv(file = "Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_young_age_cutoff_70.csv")

#cerate preranked list and export 
x <-
  res %>% 
  dplyr::filter(!is.na(FDR)) 
x$fcSign<-sign(x$logFC)
x$logP   <- -log10(x$FDR)
x$metric <- x$logP/x$fcSign

y<-x %>% 
  dplyr::select(Gene.symbol, metric) %>% 
  dplyr::rename(SYMBOL=Gene.symbol)
baseline.rnk=y
write_tsv(y, file= paste0("Results/RNA/GSEA/", paste0("GSEA_edgeR_",paste0("_lung_young_rec_vs_norec_TCGA.rnk"))), col_names=FALSE)



##### get TCGA file 
res <- read.csv(file = "Results/RNA/edgeR.results_Lung_stage_I_TCGA_DFS_STATUS_old_age_cutoff_70.csv")

#cerate preranked list and export 
x <-
  res %>% 
  dplyr::filter(!is.na(FDR)) 
x$fcSign<-sign(x$logFC)
x$logP   <- -log10(x$FDR)
x$metric <- x$logP/x$fcSign

y<-x %>% 
  dplyr::select(Gene.symbol, metric) %>% 
  dplyr::rename(SYMBOL=Gene.symbol)
baseline.rnk=y
write_tsv(y, file= paste0("Results/RNA/GSEA/", paste0("GSEA_edgeR_",paste0("_lung_old_rec_vs_norec_TCGA.rnk"))), col_names=FALSE)




################## load all gsea results and plot ##########




























######## x Cell analysis ####### 
#load package
library(xCell)

meta <- RNA.data %>% data.frame() %>% filter(ProgType_Lab!="Secondary.Primary")

temp <- mycounts %>% dplyr::select(rownames(meta))

#perform analysis and save in object
res_xcell <- xCellAnalysis(temp)

# transpose the object so that samples become rows and build a new category column 
res_xcell_df<- t(res_xcell) %>% 
  data.frame()

#add necesssary metadata columns 
res_xcell_df<- res_xcell_df %>% 
  mutate(Age = meta$Age) %>% 
  mutate(., age_grp = meta$age_grp) %>% 
  mutate(Sample_Type_Involved = meta$Sample_Type_Involved) %>% 
  mutate(Progression = meta$Progression) %>% 
  mutate(age_rec=case_when(
    age_grp =="greater_70"& Progression=="1"~"old_rec", 
    age_grp =="greater_70"& Progression=="0"~"old_no_rec", 
    age_grp =="less_equal_70"& Progression=="1"~"young_rec", 
    age_grp =="less_equal_70"& Progression=="0"~"young_no_rec"
  )) %>% 
  mutate(age_rec=factor(age_rec, levels=c("young_no_rec", "young_rec", "old_no_rec", "old_rec")))


#compare immune score, stromal score and microenvorment score 

col_names <- colnames(res_xcell_df)[65:67]

#tumor
plot_df <- res_xcell_df %>% filter(Sample_Type_Involved=="Lung.Tissue.In")

#tumor boxplots 

for (i in col_names){
  
  p <- ggplot(plot_df, aes_string(x= plot_df$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("lightblue",  "blue","orange", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("xcell/NYU/tumor/",paste0("xcell_boxplot_all_figures_", paste0("age_rec", paste0("_", paste0("tumor", paste0("_", paste0(i, paste0("_NYU", paste0(".pdf")))))))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}

#tumor correlation with age 

for (i in col_names){
  
  p <- ggplot(plot_df, aes_string(x= plot_df$Age, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")+
    facet_grid(. ~ Progression)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("xcell/NYU/tumor/",paste0("xcell_score_correlation_", paste0("Age", paste0("_", paste0("tumor", paste0("_", paste0(i, paste0("_NYU", paste0(".pdf")))))))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


#lung 
plot_df <- res_xcell_df %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")

#lung boxplots 
for (i in col_names){
  
  p <- ggplot(plot_df, aes_string(x= plot_df$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("lightblue",  "blue","orange", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("xcell/NYU/lung/",paste0("xcell_boxplot_all_figures_", paste0("age_rec", paste0("_", paste0("lung", paste0("_", paste0(i, paste0("_NYU", paste0(".pdf")))))))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


#lung correlation with age 


for (i in col_names){
  
  p <- ggplot(plot_df, aes_string(x= plot_df$Age, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")+
    facet_grid(. ~ Progression)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("xcell/NYU/lung/",paste0("xcell_score_correlation_", paste0("Age", paste0("_", paste0("lung", paste0("_", paste0(i, paste0("_NYU", paste0(".pdf")))))))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


######### cells analysis 
plot_df <- res_xcell_df

#Now lop over and create image for each cell type 
#creating a function to loop over 
col_names <- colnames(res_xcell_df)
col_names <- col_names[1:64]

#loop over columns 


####boxplots of age_rec
plot_df <- res_xcell_df %>% filter(Sample_Type_Involved=="Lung.Tissue.In")
plot_df[,1:64] <- scale(plot_df[1:64])

plot_list <- list()

for (i in col_names){
  
  p <- ggplot(plot_df, aes_string(x= plot_df$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("lightblue",  "blue","orange", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("xcell/NYU/tumor/",paste0("xcell_boxplot_all_figures_", paste0("age_rec", paste0("_", paste0("tumor", paste0("_", paste0(i, paste0("_NYU", paste0(".pdf")))))))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("xcell/NYU/tumor/",paste0("xcell_boxplot_all_figures_", paste0("age_rec", paste0("_", paste0("tumor", paste0("_", paste0("combined", paste0("_NYU", paste0(".pdf")))))))))

pdf(file = combined_pdf_output, height = 40, width = 38)
grid.arrange(grobs = plot_list, ncol = 8)  # Adjust ncol based on your desired layout
dev.off()


#repeat for lung 
####boxplots of age_rec
plot_df <- res_xcell_df %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn")
plot_df[,1:64] <- scale(plot_df[1:64])

plot_list <- list()

for (i in col_names){
  
  p <- ggplot(plot_df, aes_string(x= plot_df$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("lightblue",  "blue","orange", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("xcell/NYU/lung/",paste0("xcell_boxplot_all_figures_", paste0("age_rec", paste0("_", paste0("lung", paste0("_", paste0(i, paste0("_NYU", paste0(".pdf")))))))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("xcell/NYU/lung/",paste0("xcell_boxplot_all_figures_", paste0("age_rec", paste0("_", paste0("lung", paste0("_", paste0("combined", paste0("_NYU", paste0(".pdf")))))))))

pdf(file = combined_pdf_output, height = 40, width = 38)
grid.arrange(grobs = plot_list, ncol = 8)  # Adjust ncol based on your desired layout
dev.off()














############ xcell for TCGA ########

library(xCell)

meta <- tcga_metadata_stage_I_no_NA

temp <- tcga_counts_stage_I_no_NA %>% dplyr::select(rownames(meta))

#perform analysis and save in object
res_xcell <- xCellAnalysis(temp)

# transpose the object so that samples become rows and build a new category column 
res_xcell_df<- t(res_xcell) %>% 
  data.frame()

#add necesssary metadata columns 
res_xcell_df<- res_xcell_df %>% 
  mutate(Age = meta$age_at_index) %>% 
  mutate(., age_grp_new = meta$age_grp_new) %>% 
  mutate(shortLetterCode = meta$shortLetterCode) %>% 
  mutate(DFS_STATUS = meta$DFS_STATUS) %>% 
  mutate(age_rec=case_when(
    age_grp_new =="greater_70"& DFS_STATUS=="Recurrence"~"old_rec", 
    age_grp_new =="greater_70"& DFS_STATUS=="No.Recurrence"~"old_no_rec", 
    age_grp_new =="less_equal_70"& DFS_STATUS=="Recurrence"~"young_rec", 
    age_grp_new =="less_equal_70"& DFS_STATUS=="No.Recurrence"~"young_no_rec"
  )) %>% 
  mutate(age_rec=factor(age_rec, levels=c("young_no_rec", "young_rec", "old_no_rec", "old_rec")))


#compare immune score, stromal score and microenvorment score 

col_names <- colnames(res_xcell_df)[65:67]

#tumor
plot_df <- res_xcell_df %>% filter(shortLetterCode=="TP")

#tumor boxplots 

for (i in col_names){
  
  p <- ggplot(plot_df, aes_string(x= plot_df$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("lightblue",  "blue","orange", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("xcell/TCGA/tumor/",paste0("xcell_boxplot_all_figures_", paste0("age_rec", paste0("_", paste0("tumor", paste0("_", paste0(i, paste0("_TCGA", paste0(".pdf")))))))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}

#tumor correlation with age 

for (i in col_names){
  
  p <- ggplot(plot_df, aes_string(x= plot_df$Age, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")+
    facet_grid(. ~ DFS_STATUS)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("xcell/TCGA/tumor/",paste0("xcell_score_correlation_", paste0("Age", paste0("_", paste0("tumor", paste0("_", paste0(i, paste0("_TCGA", paste0(".pdf")))))))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


#lung 
plot_df <- res_xcell_df %>% filter(shortLetterCode=="NT")

#lung boxplots 
for (i in col_names){
  
  p <- ggplot(plot_df, aes_string(x= plot_df$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("lightblue",  "blue","orange", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("xcell/TCGA/lung/",paste0("xcell_boxplot_all_figures_", paste0("age_rec", paste0("_", paste0("lung", paste0("_", paste0(i, paste0("_TCGA", paste0(".pdf")))))))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


#lung correlation with age 


for (i in col_names){
  
  p <- ggplot(plot_df, aes_string(x= plot_df$Age, y=i))+
    geom_point()+
    geom_smooth(method = "lm")+
    stat_cor(method = "spearman")+
    xlab("Age")+ylab("")+ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")+
    facet_grid(. ~ DFS_STATUS)  # Facet by the "DFS_STATUS" column
  
  #save it 
  pdf_output <- paste0("xcell/TCGA/lung/",paste0("xcell_score_correlation_", paste0("Age", paste0("_", paste0("lung", paste0("_", paste0(i, paste0("_TCGA", paste0(".pdf")))))))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
}


######### cells analysis 
plot_df <- res_xcell_df

#Now lop over and create image for each cell type 
#creating a function to loop over 
col_names <- colnames(res_xcell_df)
col_names <- col_names[1:64]

#loop over columns 


####boxplots of age_rec
plot_df <- res_xcell_df %>% filter(shortLetterCode=="TP")
plot_df[,1:64] <- scale(plot_df[1:64])

plot_list <- list()

for (i in col_names){
  
  p <- ggplot(plot_df, aes_string(x= plot_df$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("lightblue",  "blue","orange", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("xcell/TCGA/tumor/",paste0("xcell_boxplot_all_figures_", paste0("age_rec", paste0("_", paste0("tumor", paste0("_", paste0(i, paste0("_TCGA", paste0(".pdf")))))))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("xcell/TCGA/tumor/",paste0("xcell_boxplot_all_figures_", paste0("age_rec", paste0("_", paste0("tumor", paste0("_", paste0("combined", paste0("_TCGA", paste0(".pdf")))))))))

pdf(file = combined_pdf_output, height = 40, width = 38)
grid.arrange(grobs = plot_list, ncol = 8)  # Adjust ncol based on your desired layout
dev.off()


#repeat for lung 
####boxplots of age_rec
plot_df <- res_xcell_df %>% filter(shortLetterCode=="NT")
plot_df[,1:64] <- scale(plot_df[1:64])

plot_list <- list()

for (i in col_names){
  
  p <- ggplot(plot_df, aes_string(x= plot_df$age_rec, y=i))+
    geom_boxplot()+
    geom_jitter(aes(alpha=0.7, color=age_rec))+
    stat_compare_means(comparisons = list(c("young_no_rec", "young_rec"), 
                                          c("old_no_rec", "old_rec"), 
                                          c("young_rec", "old_rec"), 
                                          c("young_no_rec", "old_no_rec")))+
    scale_color_manual(values = c("lightblue",  "blue","orange", "red"))+
    scale_x_discrete(breaks= c("young_no_rec", "young_rec","old_no_rec", "old_rec"),
                     labels= c(glue("Young<br>No Recurrence"),
                               glue("Young<br>Recurrence"),
                               glue("Old<br>No Recurrence"),
                               glue("Old<br>Recurrence")))+
    xlab("")+
    ylab("")+
    ggtitle(i)+
    theme_classic()+
    theme(axis.text.x = element_markdown(size = 14, face = "bold"), 
          axis.text.y = element_text(size = 20, face = "bold"), 
          axis.title.y = element_text(size = 20, face = "bold"), 
          axis.title.x = element_text(size = 20, face = "bold"), 
          legend.position = "none")
  #save it 
  pdf_output <- paste0("xcell/TCGA/lung/",paste0("xcell_boxplot_all_figures_", paste0("age_rec", paste0("_", paste0("lung", paste0("_", paste0(i, paste0("_TCGA", paste0(".pdf")))))))))
  pdf(file=pdf_output,height = 8, width = 8)
  show(p)
  dev.off()
  # Add the saved PDF file to the list
  plot_list <- append(plot_list, list(p))
}

combined_pdf_output <- paste0("xcell/TCGA/lung/",paste0("xcell_boxplot_all_figures_", paste0("age_rec", paste0("_", paste0("lung", paste0("_", paste0("combined", paste0("_TCGA", paste0(".pdf")))))))))

pdf(file = combined_pdf_output, height = 40, width = 38)
grid.arrange(grobs = plot_list, ncol = 8)  # Adjust ncol based on your desired layout
dev.off()












########## COX model on clinical data ######

df <- RNA.data %>% data.frame()
df$ProgType_Lab
df <- df %>% filter(ProgType_Lab!="Secondary.Primary")

colnames(df)

df <- df %>% dplyr::select(Sample_Type_Involved, RACE, Male_1, Smoking_status, Age, LVI, 
                           Pleural_Invasion,Progression, New_TTP,
                           ProgType_Lab, age_grp)

df_tumor <- df %>% filter(Sample_Type_Involved=="Lung.Tissue.In") %>% dplyr::select(-Sample_Type_Involved)
df_lung <- df %>% filter(Sample_Type_Involved=="Lung.Tissue.UnIn") %>% dplyr::select(-Sample_Type_Involved)

delta <- as.numeric(df_tumor$Progression)
obstime <- as.numeric(df_tumor$New_TTP)

model_data <- data.frame(obstime, delta, df_tumor)
model_data <- model_data %>% dplyr::select(-c(New_TTP, Progression))
model_data <- na.omit(model_data)

cox.results <- NULL

for(i in 1:nrow(model_data)){
  # Create a data frame with selected columns
  data <- t(model_data)
  
  # Fit Cox proportional hazards regression model
  fit.surv <- coxph(Surv(obstime, delta) ~ ., data = model_data)
  
  # Extract coefficients and p-value
  coef_summary <- summary(fit.surv)
}

# Extract HR (hazard ratio)
hr <- coef_summary$coef[, "exp(coef)"]

# Extract lower and upper CI bounds
lower_ci <- summary(fit.surv)$conf.int[,"lower .95"]
upper_ci <- summary(fit.surv)$conf.int[,"upper .95"]

# Extract p-values
p_values <- coef_summary$coef[, "Pr(>|z|)"]


# Now you have HR, lower and upper CI bounds, and p-values for each gene
cox.results <- data.frame(hr, lower_ci, upper_ci, p_values)
cox.results$p_values=as.numeric(cox.results$p_values)
cox.results$adj.p=p.adjust(cox.results$p_values,method = "BH")


write.csv(cox.results, file = "cox_clinical_data_nyu_test.csv")



nrow(tcga_metadata_stage_I_no_NA %>% 
  filter(shortLetterCode=="TP"))

nrow(tcga_metadata_stage_I_no_NA %>% 
       filter(shortLetterCode=="NT"))




















########### TCGA figure 1F alternative top 10 pathways ##########


IPA_res <- read.csv(file = "IPA/TCGA/Figure_1F_alternative_top_10.csv")

#get max and min values 
max(IPA_res$Old, na.rm = TRUE)
min(IPA_res$Old, na.rm = TRUE)
max(IPA_res$Young, na.rm = TRUE)
min(IPA_res$Young, na.rm = TRUE)

#####plot heatmap using complex heatmaps 

# Define colors for each levels of qualitative variables
library(circlize)
col_fun = colorRamp2(c(-4.131, 0, 8.185), c("blue", "white", "orange"))
col_fun(seq(-4.131, 0, 8.185))

#convert data to matrix 
IPA_res <- IPA_res %>% arrange(desc(Old))

IPA_res_mat <- IPA_res


#set pathways as rownames
rownames(IPA_res_mat) <- IPA_res_mat$Pathway

#get rid of extra columns
IPA_res_mat <- IPA_res_mat[,-1]

#convert to matrix 
IPA_res_mat <- as.matrix(IPA_res_mat)

######ploting
#na colors as white 
#add lines between cells 
#bold rownames
#set size 
pdf(file = "Figures/RNA/IPA_TCGA_figure_1F_alternative_top10.pdf", height = 12, width = 16)
ComplexHeatmap::Heatmap(IPA_res_mat, 
                        rect_gp = gpar(col = "black", lwd = 1),
                        na_col = "white",
                        row_names_side = "left",
                        column_names_side = "top",
                        column_title = "", row_title = "", 
                        col = col_fun, 
                        row_names_gp = gpar(fontface="bold"),
                        column_names_gp = gpar(fontace="bold"),
                        row_title_side = "left", 
                        column_title_side = "top", 
                        cluster_rows = FALSE, 
                        cluster_columns = FALSE, 
                        heatmap_legend_param = list(title="Z-Score", title_position = "lefttop-rot"),
                        row_labels =IPA_res$Pathway, 
                        width = unit(2, "cm"))
dev.off()










library(utils)
rforge <- "http://r-forge.r-project.org"
install.packages("estimate", repos=rforge, dependencies=TRUE)


library(estimate)

normalized_data<- log2(mycounts + 1)

write.table(normalized_data, file = "normalized_rna_seq_data.gct", sep = "\t", quote = FALSE)

# Filter common genes
filterCommonGenes(input.f = "normalized_rna_seq_data.gct", output.f = "filtered_normalized_rna_seq_data.gct", id="GeneSymbol")

# Calculate ESTIMATE scores
estimateScore(input.ds = "filtered_normalized_rna_seq_data.gct", output.ds = "estimate_scores.gct")

# Read the scores
scores <- read.table("estimate_scores.gct", skip = 2, header = TRUE, sep = "\t", row.names = 1)




save.image("early_lung_cancer_by_age_RNA.RData")
